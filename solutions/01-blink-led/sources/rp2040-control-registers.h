#pragma once

//------------------------------------------------------------------------------
// RP2040
//------------------------------------------------------------------------------

#include <stdint.h>

//------------------------------------------------------------------------------
// Peripheral ADC: Control and data interface to SAR ADC
//------------------------------------------------------------------------------

//---  Register CS: ADC Control and Status
  static volatile uint32_t & ADC_CS __attribute__((unused)) = * ((volatile uint32_t *) (0x4004C000 + 0)) ;

  // Field EN: Power on ADC and enable its clock.\n 1 - enabled. 0 - disabled.
    const uint32_t ADC_CS_EN = 1U << 0 ;

  // Field TS_EN: Power on temperature sensor. 1 - enabled. 0 - disabled.
    const uint32_t ADC_CS_TS_EN = 1U << 1 ;

  // Field START_ONCE: Start a single conversion. Self-clearing. Ignored if start_many is asserted.
    const uint32_t ADC_CS_START_ONCE = 1U << 2 ;

  // Field START_MANY: Continuously perform conversions whilst this bit is 1. A new conversion will start immediately after the previous finishes.
    const uint32_t ADC_CS_START_MANY = 1U << 3 ;

  // Field READY: 1 if the ADC is ready to start a new conversion. Implies any previous conversion has completed.\n 0 whilst conversion in progress.
    const uint32_t ADC_CS_READY = 1U << 8 ;

  // Field ERR: The most recent ADC conversion encountered an error; result is undefined or noisy.
    const uint32_t ADC_CS_ERR = 1U << 9 ;

  // Field ERR_STICKY: Some past ADC conversion encountered an error. Write 1 to clear.
    const uint32_t ADC_CS_ERR_STICKY = 1U << 10 ;

  // Field AINSEL: Select analog mux input. Updated automatically in round-robin mode.
    inline uint32_t ADC_CS_AINSEL (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field RROBIN: Round-robin sampling. 1 bit per channel. Set all bits to 0 to disable.\n Otherwise, the ADC will cycle through each enabled channel in a round-robin fashion.\n The first channel to be sampled will be the one currently indicated by AINSEL.\n AINSEL will be updated after each conversion with the newly-selected channel.
    inline uint32_t ADC_CS_RROBIN (const uint32_t inValue) {return (inValue & 0x1FU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register RESULT: Result of most recent ADC conversion
  static volatile uint32_t & ADC_RESULT __attribute__((unused)) = * ((volatile uint32_t *) (0x4004C000 + 4)) ;

  // Field RESULT: 
    inline uint32_t ADC_RESULT_RESULT (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FCS: FIFO control and status
  static volatile uint32_t & ADC_FCS __attribute__((unused)) = * ((volatile uint32_t *) (0x4004C000 + 8)) ;

  // Field EN: If 1: write result to the FIFO after each conversion.
    const uint32_t ADC_FCS_EN = 1U << 0 ;

  // Field SHIFT: If 1: FIFO results are right-shifted to be one byte in size. Enables DMA to byte buffers.
    const uint32_t ADC_FCS_SHIFT = 1U << 1 ;

  // Field ERR: If 1: conversion error bit appears in the FIFO alongside the result
    const uint32_t ADC_FCS_ERR = 1U << 2 ;

  // Field DREQ_EN: If 1: assert DMA requests when FIFO contains data
    const uint32_t ADC_FCS_DREQ_EN = 1U << 3 ;

  // Field EMPTY: 
    const uint32_t ADC_FCS_EMPTY = 1U << 8 ;

  // Field FULL: 
    const uint32_t ADC_FCS_FULL = 1U << 9 ;

  // Field UNDER: 1 if the FIFO has been underflowed. Write 1 to clear.
    const uint32_t ADC_FCS_UNDER = 1U << 10 ;

  // Field OVER: 1 if the FIFO has been overflowed. Write 1 to clear.
    const uint32_t ADC_FCS_OVER = 1U << 11 ;

  // Field LEVEL: The number of conversion results currently waiting in the FIFO
    inline uint32_t ADC_FCS_LEVEL (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field THRESH: DREQ/IRQ asserted when level >= threshold
    inline uint32_t ADC_FCS_THRESH (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register FIFO: Conversion result FIFO
  static volatile uint32_t & ADC_FIFO __attribute__((unused)) = * ((volatile uint32_t *) (0x4004C000 + 12)) ;

  // Field VAL: 
    inline uint32_t ADC_FIFO_VAL (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

  // Field ERR: 1 if this particular sample experienced a conversion error. Remains in the same location if the sample is shifted.
    const uint32_t ADC_FIFO_ERR = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register DIV: Clock divider. If non-zero, CS_START_MANY will start conversions\n at regular intervals rather than back-to-back.\n The divider is reset when either of these fields are written.\n Total period is 1 + INT + FRAC / 256
  static volatile uint32_t & ADC_DIV __attribute__((unused)) = * ((volatile uint32_t *) (0x4004C000 + 16)) ;

  // Field FRAC: Fractional part of clock divisor. First-order delta-sigma.
    inline uint32_t ADC_DIV_FRAC (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field INT: Integer part of clock divisor.
    inline uint32_t ADC_DIV_INT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register INTR: Raw Interrupts
  static volatile uint32_t & ADC_INTR __attribute__((unused)) = * ((volatile uint32_t *) (0x4004C000 + 20)) ;

  // Field FIFO: Triggered when the sample FIFO reaches a certain level.\n This level can be programmed via the FCS_THRESH field.
    const uint32_t ADC_INTR_FIFO = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register INTE: Interrupt Enable
  static volatile uint32_t & ADC_INTE __attribute__((unused)) = * ((volatile uint32_t *) (0x4004C000 + 24)) ;

  // Field FIFO: Triggered when the sample FIFO reaches a certain level.\n This level can be programmed via the FCS_THRESH field.
    const uint32_t ADC_INTE_FIFO = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register INTF: Interrupt Force
  static volatile uint32_t & ADC_INTF __attribute__((unused)) = * ((volatile uint32_t *) (0x4004C000 + 28)) ;

  // Field FIFO: Triggered when the sample FIFO reaches a certain level.\n This level can be programmed via the FCS_THRESH field.
    const uint32_t ADC_INTF_FIFO = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register INTS: Interrupt status after masking & forcing
  static volatile uint32_t & ADC_INTS __attribute__((unused)) = * ((volatile uint32_t *) (0x4004C000 + 32)) ;

  // Field FIFO: Triggered when the sample FIFO reaches a certain level.\n This level can be programmed via the FCS_THRESH field.
    const uint32_t ADC_INTS_FIFO = 1U << 0 ;

//------------------------------------------------------------------------------
// Peripheral BUSCTRL: Register block for busfabric control signals and performance counters
//------------------------------------------------------------------------------

//---  Register BUS_PRIORITY: Set the priority of each master for bus arbitration.
  static volatile uint32_t & BUSCTRL_BUS_PRIORITY __attribute__((unused)) = * ((volatile uint32_t *) (0x40030000 + 0)) ;

  // Field PROC0: 0 - low priority, 1 - high priority
    const uint32_t BUSCTRL_BUS_PRIORITY_PROC0 = 1U << 0 ;

  // Field PROC1: 0 - low priority, 1 - high priority
    const uint32_t BUSCTRL_BUS_PRIORITY_PROC1 = 1U << 4 ;

  // Field DMA_R: 0 - low priority, 1 - high priority
    const uint32_t BUSCTRL_BUS_PRIORITY_DMA_R = 1U << 8 ;

  // Field DMA_W: 0 - low priority, 1 - high priority
    const uint32_t BUSCTRL_BUS_PRIORITY_DMA_W = 1U << 12 ;

//------------------------------------------------------------------------------

//---  Register BUS_PRIORITY_ACK: Bus priority acknowledge
  static volatile uint32_t & BUSCTRL_BUS_PRIORITY_ACK __attribute__((unused)) = * ((volatile uint32_t *) (0x40030000 + 4)) ;

  // Field BUS_PRIORITY_ACK: Goes to 1 once all arbiters have registered the new global priority levels.\n Arbiters update their local priority when servicing a new nonsequential access.\n In normal circumstances this will happen almost immediately.
    const uint32_t BUSCTRL_BUS_PRIORITY_ACK_BUS_PRIORITY_ACK = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register PERFCTR0: Bus fabric performance counter 0
  static volatile uint32_t & BUSCTRL_PERFCTR0 __attribute__((unused)) = * ((volatile uint32_t *) (0x40030000 + 8)) ;

  // Field PERFCTR0: Busfabric saturating performance counter 0\n Count some event signal from the busfabric arbiters.\n Write any value to clear. Select an event to count using PERFSEL0
    inline uint32_t BUSCTRL_PERFCTR0_PERFCTR0 (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register PERFSEL0: Bus fabric performance event select for PERFCTR0
  static volatile uint32_t & BUSCTRL_PERFSEL0 __attribute__((unused)) = * ((volatile uint32_t *) (0x40030000 + 12)) ;

  // Field PERFSEL0: Select a performance event for PERFCTR0
    inline uint32_t BUSCTRL_PERFSEL0_PERFSEL0 (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register PERFCTR1: Bus fabric performance counter 1
  static volatile uint32_t & BUSCTRL_PERFCTR1 __attribute__((unused)) = * ((volatile uint32_t *) (0x40030000 + 16)) ;

  // Field PERFCTR1: Busfabric saturating performance counter 1\n Count some event signal from the busfabric arbiters.\n Write any value to clear. Select an event to count using PERFSEL1
    inline uint32_t BUSCTRL_PERFCTR1_PERFCTR1 (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register PERFSEL1: Bus fabric performance event select for PERFCTR1
  static volatile uint32_t & BUSCTRL_PERFSEL1 __attribute__((unused)) = * ((volatile uint32_t *) (0x40030000 + 20)) ;

  // Field PERFSEL1: Select a performance event for PERFCTR1
    inline uint32_t BUSCTRL_PERFSEL1_PERFSEL1 (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register PERFCTR2: Bus fabric performance counter 2
  static volatile uint32_t & BUSCTRL_PERFCTR2 __attribute__((unused)) = * ((volatile uint32_t *) (0x40030000 + 24)) ;

  // Field PERFCTR2: Busfabric saturating performance counter 2\n Count some event signal from the busfabric arbiters.\n Write any value to clear. Select an event to count using PERFSEL2
    inline uint32_t BUSCTRL_PERFCTR2_PERFCTR2 (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register PERFSEL2: Bus fabric performance event select for PERFCTR2
  static volatile uint32_t & BUSCTRL_PERFSEL2 __attribute__((unused)) = * ((volatile uint32_t *) (0x40030000 + 28)) ;

  // Field PERFSEL2: Select a performance event for PERFCTR2
    inline uint32_t BUSCTRL_PERFSEL2_PERFSEL2 (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register PERFCTR3: Bus fabric performance counter 3
  static volatile uint32_t & BUSCTRL_PERFCTR3 __attribute__((unused)) = * ((volatile uint32_t *) (0x40030000 + 32)) ;

  // Field PERFCTR3: Busfabric saturating performance counter 3\n Count some event signal from the busfabric arbiters.\n Write any value to clear. Select an event to count using PERFSEL3
    inline uint32_t BUSCTRL_PERFCTR3_PERFCTR3 (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register PERFSEL3: Bus fabric performance event select for PERFCTR3
  static volatile uint32_t & BUSCTRL_PERFSEL3 __attribute__((unused)) = * ((volatile uint32_t *) (0x40030000 + 36)) ;

  // Field PERFSEL3: Select a performance event for PERFCTR3
    inline uint32_t BUSCTRL_PERFSEL3_PERFSEL3 (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral CLOCKS: 
//------------------------------------------------------------------------------

//---  Register CLK_GPOUT0_CTRL: Clock control, can be changed on-the-fly (except for auxsrc)
  static volatile uint32_t & CLOCKS_CLK_GPOUT0_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 0)) ;

  // Field AUXSRC: Selects the auxiliary clock source, will glitch when switching
    inline uint32_t CLOCKS_CLK_GPOUT0_CTRL_AUXSRC (const uint32_t inValue) {return (inValue & 0xFU) << 5 ; }

  // Field KILL: Asynchronously kills the clock generator
    const uint32_t CLOCKS_CLK_GPOUT0_CTRL_KILL = 1U << 10 ;

  // Field ENABLE: Starts and stops the clock generator cleanly
    const uint32_t CLOCKS_CLK_GPOUT0_CTRL_ENABLE = 1U << 11 ;

  // Field DC50: Enables duty cycle correction for odd divisors
    const uint32_t CLOCKS_CLK_GPOUT0_CTRL_DC50 = 1U << 12 ;

  // Field PHASE: This delays the enable signal by up to 3 cycles of the input clock\n This must be set before the clock is enabled to have any effect
    inline uint32_t CLOCKS_CLK_GPOUT0_CTRL_PHASE (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field NUDGE: An edge on this signal shifts the phase of the output by 1 cycle of the input clock\n This can be done at any time
    const uint32_t CLOCKS_CLK_GPOUT0_CTRL_NUDGE = 1U << 20 ;

//------------------------------------------------------------------------------

//---  Register CLK_GPOUT0_DIV: Clock divisor, can be changed on-the-fly
  static volatile uint32_t & CLOCKS_CLK_GPOUT0_DIV __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 4)) ;

  // Field FRAC: Fractional component of the divisor
    inline uint32_t CLOCKS_CLK_GPOUT0_DIV_FRAC (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field INT: Integer component of the divisor, 0 -> divide by 2^16
    inline uint32_t CLOCKS_CLK_GPOUT0_DIV_INT (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register CLK_GPOUT0_SELECTED: Indicates which src is currently selected (one-hot)
  static volatile uint32_t const & CLOCKS_CLK_GPOUT0_SELECTED __attribute__((unused)) = * ((const volatile uint32_t *) (0x40008000 + 8)) ;

//------------------------------------------------------------------------------

//---  Register CLK_GPOUT1_CTRL: Clock control, can be changed on-the-fly (except for auxsrc)
  static volatile uint32_t & CLOCKS_CLK_GPOUT1_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 12)) ;

  // Field AUXSRC: Selects the auxiliary clock source, will glitch when switching
    inline uint32_t CLOCKS_CLK_GPOUT1_CTRL_AUXSRC (const uint32_t inValue) {return (inValue & 0xFU) << 5 ; }

  // Field KILL: Asynchronously kills the clock generator
    const uint32_t CLOCKS_CLK_GPOUT1_CTRL_KILL = 1U << 10 ;

  // Field ENABLE: Starts and stops the clock generator cleanly
    const uint32_t CLOCKS_CLK_GPOUT1_CTRL_ENABLE = 1U << 11 ;

  // Field DC50: Enables duty cycle correction for odd divisors
    const uint32_t CLOCKS_CLK_GPOUT1_CTRL_DC50 = 1U << 12 ;

  // Field PHASE: This delays the enable signal by up to 3 cycles of the input clock\n This must be set before the clock is enabled to have any effect
    inline uint32_t CLOCKS_CLK_GPOUT1_CTRL_PHASE (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field NUDGE: An edge on this signal shifts the phase of the output by 1 cycle of the input clock\n This can be done at any time
    const uint32_t CLOCKS_CLK_GPOUT1_CTRL_NUDGE = 1U << 20 ;

//------------------------------------------------------------------------------

//---  Register CLK_GPOUT1_DIV: Clock divisor, can be changed on-the-fly
  static volatile uint32_t & CLOCKS_CLK_GPOUT1_DIV __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 16)) ;

  // Field FRAC: Fractional component of the divisor
    inline uint32_t CLOCKS_CLK_GPOUT1_DIV_FRAC (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field INT: Integer component of the divisor, 0 -> divide by 2^16
    inline uint32_t CLOCKS_CLK_GPOUT1_DIV_INT (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register CLK_GPOUT1_SELECTED: Indicates which src is currently selected (one-hot)
  static volatile uint32_t const & CLOCKS_CLK_GPOUT1_SELECTED __attribute__((unused)) = * ((const volatile uint32_t *) (0x40008000 + 20)) ;

//------------------------------------------------------------------------------

//---  Register CLK_GPOUT2_CTRL: Clock control, can be changed on-the-fly (except for auxsrc)
  static volatile uint32_t & CLOCKS_CLK_GPOUT2_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 24)) ;

  // Field AUXSRC: Selects the auxiliary clock source, will glitch when switching
    inline uint32_t CLOCKS_CLK_GPOUT2_CTRL_AUXSRC (const uint32_t inValue) {return (inValue & 0xFU) << 5 ; }

  // Field KILL: Asynchronously kills the clock generator
    const uint32_t CLOCKS_CLK_GPOUT2_CTRL_KILL = 1U << 10 ;

  // Field ENABLE: Starts and stops the clock generator cleanly
    const uint32_t CLOCKS_CLK_GPOUT2_CTRL_ENABLE = 1U << 11 ;

  // Field DC50: Enables duty cycle correction for odd divisors
    const uint32_t CLOCKS_CLK_GPOUT2_CTRL_DC50 = 1U << 12 ;

  // Field PHASE: This delays the enable signal by up to 3 cycles of the input clock\n This must be set before the clock is enabled to have any effect
    inline uint32_t CLOCKS_CLK_GPOUT2_CTRL_PHASE (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field NUDGE: An edge on this signal shifts the phase of the output by 1 cycle of the input clock\n This can be done at any time
    const uint32_t CLOCKS_CLK_GPOUT2_CTRL_NUDGE = 1U << 20 ;

//------------------------------------------------------------------------------

//---  Register CLK_GPOUT2_DIV: Clock divisor, can be changed on-the-fly
  static volatile uint32_t & CLOCKS_CLK_GPOUT2_DIV __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 28)) ;

  // Field FRAC: Fractional component of the divisor
    inline uint32_t CLOCKS_CLK_GPOUT2_DIV_FRAC (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field INT: Integer component of the divisor, 0 -> divide by 2^16
    inline uint32_t CLOCKS_CLK_GPOUT2_DIV_INT (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register CLK_GPOUT2_SELECTED: Indicates which src is currently selected (one-hot)
  static volatile uint32_t const & CLOCKS_CLK_GPOUT2_SELECTED __attribute__((unused)) = * ((const volatile uint32_t *) (0x40008000 + 32)) ;

//------------------------------------------------------------------------------

//---  Register CLK_GPOUT3_CTRL: Clock control, can be changed on-the-fly (except for auxsrc)
  static volatile uint32_t & CLOCKS_CLK_GPOUT3_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 36)) ;

  // Field AUXSRC: Selects the auxiliary clock source, will glitch when switching
    inline uint32_t CLOCKS_CLK_GPOUT3_CTRL_AUXSRC (const uint32_t inValue) {return (inValue & 0xFU) << 5 ; }

  // Field KILL: Asynchronously kills the clock generator
    const uint32_t CLOCKS_CLK_GPOUT3_CTRL_KILL = 1U << 10 ;

  // Field ENABLE: Starts and stops the clock generator cleanly
    const uint32_t CLOCKS_CLK_GPOUT3_CTRL_ENABLE = 1U << 11 ;

  // Field DC50: Enables duty cycle correction for odd divisors
    const uint32_t CLOCKS_CLK_GPOUT3_CTRL_DC50 = 1U << 12 ;

  // Field PHASE: This delays the enable signal by up to 3 cycles of the input clock\n This must be set before the clock is enabled to have any effect
    inline uint32_t CLOCKS_CLK_GPOUT3_CTRL_PHASE (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field NUDGE: An edge on this signal shifts the phase of the output by 1 cycle of the input clock\n This can be done at any time
    const uint32_t CLOCKS_CLK_GPOUT3_CTRL_NUDGE = 1U << 20 ;

//------------------------------------------------------------------------------

//---  Register CLK_GPOUT3_DIV: Clock divisor, can be changed on-the-fly
  static volatile uint32_t & CLOCKS_CLK_GPOUT3_DIV __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 40)) ;

  // Field FRAC: Fractional component of the divisor
    inline uint32_t CLOCKS_CLK_GPOUT3_DIV_FRAC (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field INT: Integer component of the divisor, 0 -> divide by 2^16
    inline uint32_t CLOCKS_CLK_GPOUT3_DIV_INT (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register CLK_GPOUT3_SELECTED: Indicates which src is currently selected (one-hot)
  static volatile uint32_t const & CLOCKS_CLK_GPOUT3_SELECTED __attribute__((unused)) = * ((const volatile uint32_t *) (0x40008000 + 44)) ;

//------------------------------------------------------------------------------

//---  Register CLK_REF_CTRL: Clock control, can be changed on-the-fly (except for auxsrc)
  static volatile uint32_t & CLOCKS_CLK_REF_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 48)) ;

  // Field SRC: Selects the clock source glitchlessly, can be changed on-the-fly
    inline uint32_t CLOCKS_CLK_REF_CTRL_SRC (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field AUXSRC: Selects the auxiliary clock source, will glitch when switching
    inline uint32_t CLOCKS_CLK_REF_CTRL_AUXSRC (const uint32_t inValue) {return (inValue & 0x3U) << 5 ; }

//------------------------------------------------------------------------------

//---  Register CLK_REF_DIV: Clock divisor, can be changed on-the-fly
  static volatile uint32_t & CLOCKS_CLK_REF_DIV __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 52)) ;

  // Field INT: Integer component of the divisor, 0 -> divide by 2^16
    inline uint32_t CLOCKS_CLK_REF_DIV_INT (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

//------------------------------------------------------------------------------

//---  Register CLK_REF_SELECTED: Indicates which src is currently selected (one-hot)
  static volatile uint32_t const & CLOCKS_CLK_REF_SELECTED __attribute__((unused)) = * ((const volatile uint32_t *) (0x40008000 + 56)) ;

//------------------------------------------------------------------------------

//---  Register CLK_SYS_CTRL: Clock control, can be changed on-the-fly (except for auxsrc)
  static volatile uint32_t & CLOCKS_CLK_SYS_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 60)) ;

  // Field SRC: Selects the clock source glitchlessly, can be changed on-the-fly
    const uint32_t CLOCKS_CLK_SYS_CTRL_SRC = 1U << 0 ;

  // Field AUXSRC: Selects the auxiliary clock source, will glitch when switching
    inline uint32_t CLOCKS_CLK_SYS_CTRL_AUXSRC (const uint32_t inValue) {return (inValue & 0x7U) << 5 ; }

//------------------------------------------------------------------------------

//---  Register CLK_SYS_DIV: Clock divisor, can be changed on-the-fly
  static volatile uint32_t & CLOCKS_CLK_SYS_DIV __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 64)) ;

  // Field FRAC: Fractional component of the divisor
    inline uint32_t CLOCKS_CLK_SYS_DIV_FRAC (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field INT: Integer component of the divisor, 0 -> divide by 2^16
    inline uint32_t CLOCKS_CLK_SYS_DIV_INT (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register CLK_SYS_SELECTED: Indicates which src is currently selected (one-hot)
  static volatile uint32_t const & CLOCKS_CLK_SYS_SELECTED __attribute__((unused)) = * ((const volatile uint32_t *) (0x40008000 + 68)) ;

//------------------------------------------------------------------------------

//---  Register CLK_PERI_CTRL: Clock control, can be changed on-the-fly (except for auxsrc)
  static volatile uint32_t & CLOCKS_CLK_PERI_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 72)) ;

  // Field AUXSRC: Selects the auxiliary clock source, will glitch when switching
    inline uint32_t CLOCKS_CLK_PERI_CTRL_AUXSRC (const uint32_t inValue) {return (inValue & 0x7U) << 5 ; }

  // Field KILL: Asynchronously kills the clock generator
    const uint32_t CLOCKS_CLK_PERI_CTRL_KILL = 1U << 10 ;

  // Field ENABLE: Starts and stops the clock generator cleanly
    const uint32_t CLOCKS_CLK_PERI_CTRL_ENABLE = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register CLK_PERI_SELECTED: Indicates which src is currently selected (one-hot)
  static volatile uint32_t const & CLOCKS_CLK_PERI_SELECTED __attribute__((unused)) = * ((const volatile uint32_t *) (0x40008000 + 80)) ;

//------------------------------------------------------------------------------

//---  Register CLK_USB_CTRL: Clock control, can be changed on-the-fly (except for auxsrc)
  static volatile uint32_t & CLOCKS_CLK_USB_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 84)) ;

  // Field AUXSRC: Selects the auxiliary clock source, will glitch when switching
    inline uint32_t CLOCKS_CLK_USB_CTRL_AUXSRC (const uint32_t inValue) {return (inValue & 0x7U) << 5 ; }

  // Field KILL: Asynchronously kills the clock generator
    const uint32_t CLOCKS_CLK_USB_CTRL_KILL = 1U << 10 ;

  // Field ENABLE: Starts and stops the clock generator cleanly
    const uint32_t CLOCKS_CLK_USB_CTRL_ENABLE = 1U << 11 ;

  // Field PHASE: This delays the enable signal by up to 3 cycles of the input clock\n This must be set before the clock is enabled to have any effect
    inline uint32_t CLOCKS_CLK_USB_CTRL_PHASE (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field NUDGE: An edge on this signal shifts the phase of the output by 1 cycle of the input clock\n This can be done at any time
    const uint32_t CLOCKS_CLK_USB_CTRL_NUDGE = 1U << 20 ;

//------------------------------------------------------------------------------

//---  Register CLK_USB_DIV: Clock divisor, can be changed on-the-fly
  static volatile uint32_t & CLOCKS_CLK_USB_DIV __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 88)) ;

  // Field INT: Integer component of the divisor, 0 -> divide by 2^16
    inline uint32_t CLOCKS_CLK_USB_DIV_INT (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

//------------------------------------------------------------------------------

//---  Register CLK_USB_SELECTED: Indicates which src is currently selected (one-hot)
  static volatile uint32_t const & CLOCKS_CLK_USB_SELECTED __attribute__((unused)) = * ((const volatile uint32_t *) (0x40008000 + 92)) ;

//------------------------------------------------------------------------------

//---  Register CLK_ADC_CTRL: Clock control, can be changed on-the-fly (except for auxsrc)
  static volatile uint32_t & CLOCKS_CLK_ADC_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 96)) ;

  // Field AUXSRC: Selects the auxiliary clock source, will glitch when switching
    inline uint32_t CLOCKS_CLK_ADC_CTRL_AUXSRC (const uint32_t inValue) {return (inValue & 0x7U) << 5 ; }

  // Field KILL: Asynchronously kills the clock generator
    const uint32_t CLOCKS_CLK_ADC_CTRL_KILL = 1U << 10 ;

  // Field ENABLE: Starts and stops the clock generator cleanly
    const uint32_t CLOCKS_CLK_ADC_CTRL_ENABLE = 1U << 11 ;

  // Field PHASE: This delays the enable signal by up to 3 cycles of the input clock\n This must be set before the clock is enabled to have any effect
    inline uint32_t CLOCKS_CLK_ADC_CTRL_PHASE (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field NUDGE: An edge on this signal shifts the phase of the output by 1 cycle of the input clock\n This can be done at any time
    const uint32_t CLOCKS_CLK_ADC_CTRL_NUDGE = 1U << 20 ;

//------------------------------------------------------------------------------

//---  Register CLK_ADC_DIV: Clock divisor, can be changed on-the-fly
  static volatile uint32_t & CLOCKS_CLK_ADC_DIV __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 100)) ;

  // Field INT: Integer component of the divisor, 0 -> divide by 2^16
    inline uint32_t CLOCKS_CLK_ADC_DIV_INT (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

//------------------------------------------------------------------------------

//---  Register CLK_ADC_SELECTED: Indicates which src is currently selected (one-hot)
  static volatile uint32_t const & CLOCKS_CLK_ADC_SELECTED __attribute__((unused)) = * ((const volatile uint32_t *) (0x40008000 + 104)) ;

//------------------------------------------------------------------------------

//---  Register CLK_RTC_CTRL: Clock control, can be changed on-the-fly (except for auxsrc)
  static volatile uint32_t & CLOCKS_CLK_RTC_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 108)) ;

  // Field AUXSRC: Selects the auxiliary clock source, will glitch when switching
    inline uint32_t CLOCKS_CLK_RTC_CTRL_AUXSRC (const uint32_t inValue) {return (inValue & 0x7U) << 5 ; }

  // Field KILL: Asynchronously kills the clock generator
    const uint32_t CLOCKS_CLK_RTC_CTRL_KILL = 1U << 10 ;

  // Field ENABLE: Starts and stops the clock generator cleanly
    const uint32_t CLOCKS_CLK_RTC_CTRL_ENABLE = 1U << 11 ;

  // Field PHASE: This delays the enable signal by up to 3 cycles of the input clock\n This must be set before the clock is enabled to have any effect
    inline uint32_t CLOCKS_CLK_RTC_CTRL_PHASE (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field NUDGE: An edge on this signal shifts the phase of the output by 1 cycle of the input clock\n This can be done at any time
    const uint32_t CLOCKS_CLK_RTC_CTRL_NUDGE = 1U << 20 ;

//------------------------------------------------------------------------------

//---  Register CLK_RTC_DIV: Clock divisor, can be changed on-the-fly
  static volatile uint32_t & CLOCKS_CLK_RTC_DIV __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 112)) ;

  // Field FRAC: Fractional component of the divisor
    inline uint32_t CLOCKS_CLK_RTC_DIV_FRAC (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field INT: Integer component of the divisor, 0 -> divide by 2^16
    inline uint32_t CLOCKS_CLK_RTC_DIV_INT (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register CLK_RTC_SELECTED: Indicates which src is currently selected (one-hot)
  static volatile uint32_t const & CLOCKS_CLK_RTC_SELECTED __attribute__((unused)) = * ((const volatile uint32_t *) (0x40008000 + 116)) ;

//------------------------------------------------------------------------------

//---  Register CLK_SYS_RESUS_CTRL: 
  static volatile uint32_t & CLOCKS_CLK_SYS_RESUS_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 120)) ;

  // Field TIMEOUT: This is expressed as a number of clk_ref cycles\n and must be >= 2x clk_ref_freq/min_clk_tst_freq
    inline uint32_t CLOCKS_CLK_SYS_RESUS_CTRL_TIMEOUT (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field ENABLE: Enable resus
    const uint32_t CLOCKS_CLK_SYS_RESUS_CTRL_ENABLE = 1U << 8 ;

  // Field FRCE: Force a resus, for test purposes only
    const uint32_t CLOCKS_CLK_SYS_RESUS_CTRL_FRCE = 1U << 12 ;

  // Field CLEAR: For clearing the resus after the fault that triggered it has been corrected
    const uint32_t CLOCKS_CLK_SYS_RESUS_CTRL_CLEAR = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register CLK_SYS_RESUS_STATUS: 
  static volatile uint32_t & CLOCKS_CLK_SYS_RESUS_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 124)) ;

  // Field RESUSSED: Clock has been resuscitated, correct the error then send ctrl_clear=1
    const uint32_t CLOCKS_CLK_SYS_RESUS_STATUS_RESUSSED = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register FC0_REF_KHZ: Reference clock frequency in kHz
  static volatile uint32_t & CLOCKS_FC0_REF_KHZ __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 128)) ;

  // Field FC0_REF_KHZ: 
    inline uint32_t CLOCKS_FC0_REF_KHZ_FC0_REF_KHZ (const uint32_t inValue) {return (inValue & 0xFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FC0_MIN_KHZ: Minimum pass frequency in kHz. This is optional. Set to 0 if you are not using the pass/fail flags
  static volatile uint32_t & CLOCKS_FC0_MIN_KHZ __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 132)) ;

  // Field FC0_MIN_KHZ: 
    inline uint32_t CLOCKS_FC0_MIN_KHZ_FC0_MIN_KHZ (const uint32_t inValue) {return (inValue & 0x1FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FC0_MAX_KHZ: Maximum pass frequency in kHz. This is optional. Set to 0x1ffffff if you are not using the pass/fail flags
  static volatile uint32_t & CLOCKS_FC0_MAX_KHZ __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 136)) ;

  // Field FC0_MAX_KHZ: 
    inline uint32_t CLOCKS_FC0_MAX_KHZ_FC0_MAX_KHZ (const uint32_t inValue) {return (inValue & 0x1FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FC0_DELAY: Delays the start of frequency counting to allow the mux to settle\n Delay is measured in multiples of the reference clock period
  static volatile uint32_t & CLOCKS_FC0_DELAY __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 140)) ;

  // Field FC0_DELAY: 
    inline uint32_t CLOCKS_FC0_DELAY_FC0_DELAY (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FC0_INTERVAL: The test interval is 0.98us * 2**interval, but let's call it 1us * 2**interval\n The default gives a test interval of 250us
  static volatile uint32_t & CLOCKS_FC0_INTERVAL __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 144)) ;

  // Field FC0_INTERVAL: 
    inline uint32_t CLOCKS_FC0_INTERVAL_FC0_INTERVAL (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FC0_SRC: Clock sent to frequency counter, set to 0 when not required\n Writing to this register initiates the frequency count
  static volatile uint32_t & CLOCKS_FC0_SRC __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 148)) ;

  // Field FC0_SRC: 
    inline uint32_t CLOCKS_FC0_SRC_FC0_SRC (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FC0_STATUS: Frequency counter status
  static volatile uint32_t & CLOCKS_FC0_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 152)) ;

  // Field PASS: Test passed
    const uint32_t CLOCKS_FC0_STATUS_PASS = 1U << 0 ;

  // Field DONE: Test complete
    const uint32_t CLOCKS_FC0_STATUS_DONE = 1U << 4 ;

  // Field RUNNING: Test running
    const uint32_t CLOCKS_FC0_STATUS_RUNNING = 1U << 8 ;

  // Field WAITING: Waiting for test clock to start
    const uint32_t CLOCKS_FC0_STATUS_WAITING = 1U << 12 ;

  // Field FAIL: Test failed
    const uint32_t CLOCKS_FC0_STATUS_FAIL = 1U << 16 ;

  // Field SLOW: Test clock slower than expected, only valid when status_done=1
    const uint32_t CLOCKS_FC0_STATUS_SLOW = 1U << 20 ;

  // Field FAST: Test clock faster than expected, only valid when status_done=1
    const uint32_t CLOCKS_FC0_STATUS_FAST = 1U << 24 ;

  // Field DIED: Test clock stopped during test
    const uint32_t CLOCKS_FC0_STATUS_DIED = 1U << 28 ;

//------------------------------------------------------------------------------

//---  Register FC0_RESULT: Result of frequency measurement, only valid when status_done=1
  static volatile uint32_t & CLOCKS_FC0_RESULT __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 156)) ;

  // Field FRAC: 
    inline uint32_t CLOCKS_FC0_RESULT_FRAC (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field KHZ: 
    inline uint32_t CLOCKS_FC0_RESULT_KHZ (const uint32_t inValue) {return (inValue & 0x1FFFFFFU) << 5 ; }

//------------------------------------------------------------------------------

//---  Register WAKE_EN0: enable clock in wake mode
  static volatile uint32_t & CLOCKS_WAKE_EN0 __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 160)) ;

  // Field clk_sys_clocks: 
    const uint32_t CLOCKS_WAKE_EN0_clk_sys_clocks = 1U << 0 ;

  // Field clk_adc_adc: 
    const uint32_t CLOCKS_WAKE_EN0_clk_adc_adc = 1U << 1 ;

  // Field clk_sys_adc: 
    const uint32_t CLOCKS_WAKE_EN0_clk_sys_adc = 1U << 2 ;

  // Field clk_sys_busctrl: 
    const uint32_t CLOCKS_WAKE_EN0_clk_sys_busctrl = 1U << 3 ;

  // Field clk_sys_busfabric: 
    const uint32_t CLOCKS_WAKE_EN0_clk_sys_busfabric = 1U << 4 ;

  // Field clk_sys_dma: 
    const uint32_t CLOCKS_WAKE_EN0_clk_sys_dma = 1U << 5 ;

  // Field clk_sys_i2c0: 
    const uint32_t CLOCKS_WAKE_EN0_clk_sys_i2c0 = 1U << 6 ;

  // Field clk_sys_i2c1: 
    const uint32_t CLOCKS_WAKE_EN0_clk_sys_i2c1 = 1U << 7 ;

  // Field clk_sys_io: 
    const uint32_t CLOCKS_WAKE_EN0_clk_sys_io = 1U << 8 ;

  // Field clk_sys_jtag: 
    const uint32_t CLOCKS_WAKE_EN0_clk_sys_jtag = 1U << 9 ;

  // Field clk_sys_vreg_and_chip_reset: 
    const uint32_t CLOCKS_WAKE_EN0_clk_sys_vreg_and_chip_reset = 1U << 10 ;

  // Field clk_sys_pads: 
    const uint32_t CLOCKS_WAKE_EN0_clk_sys_pads = 1U << 11 ;

  // Field clk_sys_pio0: 
    const uint32_t CLOCKS_WAKE_EN0_clk_sys_pio0 = 1U << 12 ;

  // Field clk_sys_pio1: 
    const uint32_t CLOCKS_WAKE_EN0_clk_sys_pio1 = 1U << 13 ;

  // Field clk_sys_pll_sys: 
    const uint32_t CLOCKS_WAKE_EN0_clk_sys_pll_sys = 1U << 14 ;

  // Field clk_sys_pll_usb: 
    const uint32_t CLOCKS_WAKE_EN0_clk_sys_pll_usb = 1U << 15 ;

  // Field clk_sys_psm: 
    const uint32_t CLOCKS_WAKE_EN0_clk_sys_psm = 1U << 16 ;

  // Field clk_sys_pwm: 
    const uint32_t CLOCKS_WAKE_EN0_clk_sys_pwm = 1U << 17 ;

  // Field clk_sys_resets: 
    const uint32_t CLOCKS_WAKE_EN0_clk_sys_resets = 1U << 18 ;

  // Field clk_sys_rom: 
    const uint32_t CLOCKS_WAKE_EN0_clk_sys_rom = 1U << 19 ;

  // Field clk_sys_rosc: 
    const uint32_t CLOCKS_WAKE_EN0_clk_sys_rosc = 1U << 20 ;

  // Field clk_rtc_rtc: 
    const uint32_t CLOCKS_WAKE_EN0_clk_rtc_rtc = 1U << 21 ;

  // Field clk_sys_rtc: 
    const uint32_t CLOCKS_WAKE_EN0_clk_sys_rtc = 1U << 22 ;

  // Field clk_sys_sio: 
    const uint32_t CLOCKS_WAKE_EN0_clk_sys_sio = 1U << 23 ;

  // Field clk_peri_spi0: 
    const uint32_t CLOCKS_WAKE_EN0_clk_peri_spi0 = 1U << 24 ;

  // Field clk_sys_spi0: 
    const uint32_t CLOCKS_WAKE_EN0_clk_sys_spi0 = 1U << 25 ;

  // Field clk_peri_spi1: 
    const uint32_t CLOCKS_WAKE_EN0_clk_peri_spi1 = 1U << 26 ;

  // Field clk_sys_spi1: 
    const uint32_t CLOCKS_WAKE_EN0_clk_sys_spi1 = 1U << 27 ;

  // Field clk_sys_sram0: 
    const uint32_t CLOCKS_WAKE_EN0_clk_sys_sram0 = 1U << 28 ;

  // Field clk_sys_sram1: 
    const uint32_t CLOCKS_WAKE_EN0_clk_sys_sram1 = 1U << 29 ;

  // Field clk_sys_sram2: 
    const uint32_t CLOCKS_WAKE_EN0_clk_sys_sram2 = 1U << 30 ;

  // Field clk_sys_sram3: 
    const uint32_t CLOCKS_WAKE_EN0_clk_sys_sram3 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register WAKE_EN1: enable clock in wake mode
  static volatile uint32_t & CLOCKS_WAKE_EN1 __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 164)) ;

  // Field clk_sys_sram4: 
    const uint32_t CLOCKS_WAKE_EN1_clk_sys_sram4 = 1U << 0 ;

  // Field clk_sys_sram5: 
    const uint32_t CLOCKS_WAKE_EN1_clk_sys_sram5 = 1U << 1 ;

  // Field clk_sys_syscfg: 
    const uint32_t CLOCKS_WAKE_EN1_clk_sys_syscfg = 1U << 2 ;

  // Field clk_sys_sysinfo: 
    const uint32_t CLOCKS_WAKE_EN1_clk_sys_sysinfo = 1U << 3 ;

  // Field clk_sys_tbman: 
    const uint32_t CLOCKS_WAKE_EN1_clk_sys_tbman = 1U << 4 ;

  // Field clk_sys_timer: 
    const uint32_t CLOCKS_WAKE_EN1_clk_sys_timer = 1U << 5 ;

  // Field clk_peri_uart0: 
    const uint32_t CLOCKS_WAKE_EN1_clk_peri_uart0 = 1U << 6 ;

  // Field clk_sys_uart0: 
    const uint32_t CLOCKS_WAKE_EN1_clk_sys_uart0 = 1U << 7 ;

  // Field clk_peri_uart1: 
    const uint32_t CLOCKS_WAKE_EN1_clk_peri_uart1 = 1U << 8 ;

  // Field clk_sys_uart1: 
    const uint32_t CLOCKS_WAKE_EN1_clk_sys_uart1 = 1U << 9 ;

  // Field clk_sys_usbctrl: 
    const uint32_t CLOCKS_WAKE_EN1_clk_sys_usbctrl = 1U << 10 ;

  // Field clk_usb_usbctrl: 
    const uint32_t CLOCKS_WAKE_EN1_clk_usb_usbctrl = 1U << 11 ;

  // Field clk_sys_watchdog: 
    const uint32_t CLOCKS_WAKE_EN1_clk_sys_watchdog = 1U << 12 ;

  // Field clk_sys_xip: 
    const uint32_t CLOCKS_WAKE_EN1_clk_sys_xip = 1U << 13 ;

  // Field clk_sys_xosc: 
    const uint32_t CLOCKS_WAKE_EN1_clk_sys_xosc = 1U << 14 ;

//------------------------------------------------------------------------------

//---  Register SLEEP_EN0: enable clock in sleep mode
  static volatile uint32_t & CLOCKS_SLEEP_EN0 __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 168)) ;

  // Field clk_sys_clocks: 
    const uint32_t CLOCKS_SLEEP_EN0_clk_sys_clocks = 1U << 0 ;

  // Field clk_adc_adc: 
    const uint32_t CLOCKS_SLEEP_EN0_clk_adc_adc = 1U << 1 ;

  // Field clk_sys_adc: 
    const uint32_t CLOCKS_SLEEP_EN0_clk_sys_adc = 1U << 2 ;

  // Field clk_sys_busctrl: 
    const uint32_t CLOCKS_SLEEP_EN0_clk_sys_busctrl = 1U << 3 ;

  // Field clk_sys_busfabric: 
    const uint32_t CLOCKS_SLEEP_EN0_clk_sys_busfabric = 1U << 4 ;

  // Field clk_sys_dma: 
    const uint32_t CLOCKS_SLEEP_EN0_clk_sys_dma = 1U << 5 ;

  // Field clk_sys_i2c0: 
    const uint32_t CLOCKS_SLEEP_EN0_clk_sys_i2c0 = 1U << 6 ;

  // Field clk_sys_i2c1: 
    const uint32_t CLOCKS_SLEEP_EN0_clk_sys_i2c1 = 1U << 7 ;

  // Field clk_sys_io: 
    const uint32_t CLOCKS_SLEEP_EN0_clk_sys_io = 1U << 8 ;

  // Field clk_sys_jtag: 
    const uint32_t CLOCKS_SLEEP_EN0_clk_sys_jtag = 1U << 9 ;

  // Field clk_sys_vreg_and_chip_reset: 
    const uint32_t CLOCKS_SLEEP_EN0_clk_sys_vreg_and_chip_reset = 1U << 10 ;

  // Field clk_sys_pads: 
    const uint32_t CLOCKS_SLEEP_EN0_clk_sys_pads = 1U << 11 ;

  // Field clk_sys_pio0: 
    const uint32_t CLOCKS_SLEEP_EN0_clk_sys_pio0 = 1U << 12 ;

  // Field clk_sys_pio1: 
    const uint32_t CLOCKS_SLEEP_EN0_clk_sys_pio1 = 1U << 13 ;

  // Field clk_sys_pll_sys: 
    const uint32_t CLOCKS_SLEEP_EN0_clk_sys_pll_sys = 1U << 14 ;

  // Field clk_sys_pll_usb: 
    const uint32_t CLOCKS_SLEEP_EN0_clk_sys_pll_usb = 1U << 15 ;

  // Field clk_sys_psm: 
    const uint32_t CLOCKS_SLEEP_EN0_clk_sys_psm = 1U << 16 ;

  // Field clk_sys_pwm: 
    const uint32_t CLOCKS_SLEEP_EN0_clk_sys_pwm = 1U << 17 ;

  // Field clk_sys_resets: 
    const uint32_t CLOCKS_SLEEP_EN0_clk_sys_resets = 1U << 18 ;

  // Field clk_sys_rom: 
    const uint32_t CLOCKS_SLEEP_EN0_clk_sys_rom = 1U << 19 ;

  // Field clk_sys_rosc: 
    const uint32_t CLOCKS_SLEEP_EN0_clk_sys_rosc = 1U << 20 ;

  // Field clk_rtc_rtc: 
    const uint32_t CLOCKS_SLEEP_EN0_clk_rtc_rtc = 1U << 21 ;

  // Field clk_sys_rtc: 
    const uint32_t CLOCKS_SLEEP_EN0_clk_sys_rtc = 1U << 22 ;

  // Field clk_sys_sio: 
    const uint32_t CLOCKS_SLEEP_EN0_clk_sys_sio = 1U << 23 ;

  // Field clk_peri_spi0: 
    const uint32_t CLOCKS_SLEEP_EN0_clk_peri_spi0 = 1U << 24 ;

  // Field clk_sys_spi0: 
    const uint32_t CLOCKS_SLEEP_EN0_clk_sys_spi0 = 1U << 25 ;

  // Field clk_peri_spi1: 
    const uint32_t CLOCKS_SLEEP_EN0_clk_peri_spi1 = 1U << 26 ;

  // Field clk_sys_spi1: 
    const uint32_t CLOCKS_SLEEP_EN0_clk_sys_spi1 = 1U << 27 ;

  // Field clk_sys_sram0: 
    const uint32_t CLOCKS_SLEEP_EN0_clk_sys_sram0 = 1U << 28 ;

  // Field clk_sys_sram1: 
    const uint32_t CLOCKS_SLEEP_EN0_clk_sys_sram1 = 1U << 29 ;

  // Field clk_sys_sram2: 
    const uint32_t CLOCKS_SLEEP_EN0_clk_sys_sram2 = 1U << 30 ;

  // Field clk_sys_sram3: 
    const uint32_t CLOCKS_SLEEP_EN0_clk_sys_sram3 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register SLEEP_EN1: enable clock in sleep mode
  static volatile uint32_t & CLOCKS_SLEEP_EN1 __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 172)) ;

  // Field clk_sys_sram4: 
    const uint32_t CLOCKS_SLEEP_EN1_clk_sys_sram4 = 1U << 0 ;

  // Field clk_sys_sram5: 
    const uint32_t CLOCKS_SLEEP_EN1_clk_sys_sram5 = 1U << 1 ;

  // Field clk_sys_syscfg: 
    const uint32_t CLOCKS_SLEEP_EN1_clk_sys_syscfg = 1U << 2 ;

  // Field clk_sys_sysinfo: 
    const uint32_t CLOCKS_SLEEP_EN1_clk_sys_sysinfo = 1U << 3 ;

  // Field clk_sys_tbman: 
    const uint32_t CLOCKS_SLEEP_EN1_clk_sys_tbman = 1U << 4 ;

  // Field clk_sys_timer: 
    const uint32_t CLOCKS_SLEEP_EN1_clk_sys_timer = 1U << 5 ;

  // Field clk_peri_uart0: 
    const uint32_t CLOCKS_SLEEP_EN1_clk_peri_uart0 = 1U << 6 ;

  // Field clk_sys_uart0: 
    const uint32_t CLOCKS_SLEEP_EN1_clk_sys_uart0 = 1U << 7 ;

  // Field clk_peri_uart1: 
    const uint32_t CLOCKS_SLEEP_EN1_clk_peri_uart1 = 1U << 8 ;

  // Field clk_sys_uart1: 
    const uint32_t CLOCKS_SLEEP_EN1_clk_sys_uart1 = 1U << 9 ;

  // Field clk_sys_usbctrl: 
    const uint32_t CLOCKS_SLEEP_EN1_clk_sys_usbctrl = 1U << 10 ;

  // Field clk_usb_usbctrl: 
    const uint32_t CLOCKS_SLEEP_EN1_clk_usb_usbctrl = 1U << 11 ;

  // Field clk_sys_watchdog: 
    const uint32_t CLOCKS_SLEEP_EN1_clk_sys_watchdog = 1U << 12 ;

  // Field clk_sys_xip: 
    const uint32_t CLOCKS_SLEEP_EN1_clk_sys_xip = 1U << 13 ;

  // Field clk_sys_xosc: 
    const uint32_t CLOCKS_SLEEP_EN1_clk_sys_xosc = 1U << 14 ;

//------------------------------------------------------------------------------

//---  Register ENABLED0: indicates the state of the clock enable
  static volatile uint32_t & CLOCKS_ENABLED0 __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 176)) ;

  // Field clk_sys_clocks: 
    const uint32_t CLOCKS_ENABLED0_clk_sys_clocks = 1U << 0 ;

  // Field clk_adc_adc: 
    const uint32_t CLOCKS_ENABLED0_clk_adc_adc = 1U << 1 ;

  // Field clk_sys_adc: 
    const uint32_t CLOCKS_ENABLED0_clk_sys_adc = 1U << 2 ;

  // Field clk_sys_busctrl: 
    const uint32_t CLOCKS_ENABLED0_clk_sys_busctrl = 1U << 3 ;

  // Field clk_sys_busfabric: 
    const uint32_t CLOCKS_ENABLED0_clk_sys_busfabric = 1U << 4 ;

  // Field clk_sys_dma: 
    const uint32_t CLOCKS_ENABLED0_clk_sys_dma = 1U << 5 ;

  // Field clk_sys_i2c0: 
    const uint32_t CLOCKS_ENABLED0_clk_sys_i2c0 = 1U << 6 ;

  // Field clk_sys_i2c1: 
    const uint32_t CLOCKS_ENABLED0_clk_sys_i2c1 = 1U << 7 ;

  // Field clk_sys_io: 
    const uint32_t CLOCKS_ENABLED0_clk_sys_io = 1U << 8 ;

  // Field clk_sys_jtag: 
    const uint32_t CLOCKS_ENABLED0_clk_sys_jtag = 1U << 9 ;

  // Field clk_sys_vreg_and_chip_reset: 
    const uint32_t CLOCKS_ENABLED0_clk_sys_vreg_and_chip_reset = 1U << 10 ;

  // Field clk_sys_pads: 
    const uint32_t CLOCKS_ENABLED0_clk_sys_pads = 1U << 11 ;

  // Field clk_sys_pio0: 
    const uint32_t CLOCKS_ENABLED0_clk_sys_pio0 = 1U << 12 ;

  // Field clk_sys_pio1: 
    const uint32_t CLOCKS_ENABLED0_clk_sys_pio1 = 1U << 13 ;

  // Field clk_sys_pll_sys: 
    const uint32_t CLOCKS_ENABLED0_clk_sys_pll_sys = 1U << 14 ;

  // Field clk_sys_pll_usb: 
    const uint32_t CLOCKS_ENABLED0_clk_sys_pll_usb = 1U << 15 ;

  // Field clk_sys_psm: 
    const uint32_t CLOCKS_ENABLED0_clk_sys_psm = 1U << 16 ;

  // Field clk_sys_pwm: 
    const uint32_t CLOCKS_ENABLED0_clk_sys_pwm = 1U << 17 ;

  // Field clk_sys_resets: 
    const uint32_t CLOCKS_ENABLED0_clk_sys_resets = 1U << 18 ;

  // Field clk_sys_rom: 
    const uint32_t CLOCKS_ENABLED0_clk_sys_rom = 1U << 19 ;

  // Field clk_sys_rosc: 
    const uint32_t CLOCKS_ENABLED0_clk_sys_rosc = 1U << 20 ;

  // Field clk_rtc_rtc: 
    const uint32_t CLOCKS_ENABLED0_clk_rtc_rtc = 1U << 21 ;

  // Field clk_sys_rtc: 
    const uint32_t CLOCKS_ENABLED0_clk_sys_rtc = 1U << 22 ;

  // Field clk_sys_sio: 
    const uint32_t CLOCKS_ENABLED0_clk_sys_sio = 1U << 23 ;

  // Field clk_peri_spi0: 
    const uint32_t CLOCKS_ENABLED0_clk_peri_spi0 = 1U << 24 ;

  // Field clk_sys_spi0: 
    const uint32_t CLOCKS_ENABLED0_clk_sys_spi0 = 1U << 25 ;

  // Field clk_peri_spi1: 
    const uint32_t CLOCKS_ENABLED0_clk_peri_spi1 = 1U << 26 ;

  // Field clk_sys_spi1: 
    const uint32_t CLOCKS_ENABLED0_clk_sys_spi1 = 1U << 27 ;

  // Field clk_sys_sram0: 
    const uint32_t CLOCKS_ENABLED0_clk_sys_sram0 = 1U << 28 ;

  // Field clk_sys_sram1: 
    const uint32_t CLOCKS_ENABLED0_clk_sys_sram1 = 1U << 29 ;

  // Field clk_sys_sram2: 
    const uint32_t CLOCKS_ENABLED0_clk_sys_sram2 = 1U << 30 ;

  // Field clk_sys_sram3: 
    const uint32_t CLOCKS_ENABLED0_clk_sys_sram3 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register ENABLED1: indicates the state of the clock enable
  static volatile uint32_t & CLOCKS_ENABLED1 __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 180)) ;

  // Field clk_sys_sram4: 
    const uint32_t CLOCKS_ENABLED1_clk_sys_sram4 = 1U << 0 ;

  // Field clk_sys_sram5: 
    const uint32_t CLOCKS_ENABLED1_clk_sys_sram5 = 1U << 1 ;

  // Field clk_sys_syscfg: 
    const uint32_t CLOCKS_ENABLED1_clk_sys_syscfg = 1U << 2 ;

  // Field clk_sys_sysinfo: 
    const uint32_t CLOCKS_ENABLED1_clk_sys_sysinfo = 1U << 3 ;

  // Field clk_sys_tbman: 
    const uint32_t CLOCKS_ENABLED1_clk_sys_tbman = 1U << 4 ;

  // Field clk_sys_timer: 
    const uint32_t CLOCKS_ENABLED1_clk_sys_timer = 1U << 5 ;

  // Field clk_peri_uart0: 
    const uint32_t CLOCKS_ENABLED1_clk_peri_uart0 = 1U << 6 ;

  // Field clk_sys_uart0: 
    const uint32_t CLOCKS_ENABLED1_clk_sys_uart0 = 1U << 7 ;

  // Field clk_peri_uart1: 
    const uint32_t CLOCKS_ENABLED1_clk_peri_uart1 = 1U << 8 ;

  // Field clk_sys_uart1: 
    const uint32_t CLOCKS_ENABLED1_clk_sys_uart1 = 1U << 9 ;

  // Field clk_sys_usbctrl: 
    const uint32_t CLOCKS_ENABLED1_clk_sys_usbctrl = 1U << 10 ;

  // Field clk_usb_usbctrl: 
    const uint32_t CLOCKS_ENABLED1_clk_usb_usbctrl = 1U << 11 ;

  // Field clk_sys_watchdog: 
    const uint32_t CLOCKS_ENABLED1_clk_sys_watchdog = 1U << 12 ;

  // Field clk_sys_xip: 
    const uint32_t CLOCKS_ENABLED1_clk_sys_xip = 1U << 13 ;

  // Field clk_sys_xosc: 
    const uint32_t CLOCKS_ENABLED1_clk_sys_xosc = 1U << 14 ;

//------------------------------------------------------------------------------

//---  Register INTR: Raw Interrupts
  static volatile uint32_t & CLOCKS_INTR __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 184)) ;

  // Field CLK_SYS_RESUS: 
    const uint32_t CLOCKS_INTR_CLK_SYS_RESUS = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register INTE: Interrupt Enable
  static volatile uint32_t & CLOCKS_INTE __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 188)) ;

  // Field CLK_SYS_RESUS: 
    const uint32_t CLOCKS_INTE_CLK_SYS_RESUS = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register INTF: Interrupt Force
  static volatile uint32_t & CLOCKS_INTF __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 192)) ;

  // Field CLK_SYS_RESUS: 
    const uint32_t CLOCKS_INTF_CLK_SYS_RESUS = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register INTS: Interrupt status after masking & forcing
  static volatile uint32_t & CLOCKS_INTS __attribute__((unused)) = * ((volatile uint32_t *) (0x40008000 + 196)) ;

  // Field CLK_SYS_RESUS: 
    const uint32_t CLOCKS_INTS_CLK_SYS_RESUS = 1U << 0 ;

//------------------------------------------------------------------------------
// Peripheral DMA: DMA with separate read and write masters
//------------------------------------------------------------------------------

//---  Register CH0_READ_ADDR: DMA Channel 0 Read Address pointer\n This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
  static volatile uint32_t & DMA_CH0_READ_ADDR __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 0)) ;

//------------------------------------------------------------------------------

//---  Register CH0_WRITE_ADDR: DMA Channel 0 Write Address pointer\n This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
  static volatile uint32_t & DMA_CH0_WRITE_ADDR __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 4)) ;

//------------------------------------------------------------------------------

//---  Register CH0_TRANS_COUNT: DMA Channel 0 Transfer Count\n Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
  static volatile uint32_t & DMA_CH0_TRANS_COUNT __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 8)) ;

//------------------------------------------------------------------------------

//---  Register CH0_CTRL_TRIG: DMA Channel 0 Control and Status
  static volatile uint32_t & DMA_CH0_CTRL_TRIG __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 12)) ;

  // Field EN: DMA Channel Enable.\n When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
    const uint32_t DMA_CH0_CTRL_TRIG_EN = 1U << 0 ;

  // Field HIGH_PRIORITY: HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
    const uint32_t DMA_CH0_CTRL_TRIG_HIGH_PRIORITY = 1U << 1 ;

  // Field DATA_SIZE: Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
    inline uint32_t DMA_CH0_CTRL_TRIG_DATA_SIZE (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field INCR_READ: If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n Generally this should be disabled for peripheral-to-memory transfers.
    const uint32_t DMA_CH0_CTRL_TRIG_INCR_READ = 1U << 4 ;

  // Field INCR_WRITE: If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n Generally this should be disabled for memory-to-peripheral transfers.
    const uint32_t DMA_CH0_CTRL_TRIG_INCR_WRITE = 1U << 5 ;

  // Field RING_SIZE: Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
    inline uint32_t DMA_CH0_CTRL_TRIG_RING_SIZE (const uint32_t inValue) {return (inValue & 0xFU) << 6 ; }

  // Field RING_SEL: Select whether RING_SIZE applies to read or write addresses.\n If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
    const uint32_t DMA_CH0_CTRL_TRIG_RING_SEL = 1U << 10 ;

  // Field CHAIN_TO: When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.\n Reset value is equal to channel number (0).
    inline uint32_t DMA_CH0_CTRL_TRIG_CHAIN_TO (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field TREQ_SEL: Select a Transfer Request signal.\n The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system).\n 0x0 to 0x3a -> select DREQ n as TREQ
    inline uint32_t DMA_CH0_CTRL_TRIG_TREQ_SEL (const uint32_t inValue) {return (inValue & 0x3FU) << 15 ; }

  // Field IRQ_QUIET: In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
    const uint32_t DMA_CH0_CTRL_TRIG_IRQ_QUIET = 1U << 21 ;

  // Field BSWAP: Apply byte-swap transformation to DMA data.\n For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
    const uint32_t DMA_CH0_CTRL_TRIG_BSWAP = 1U << 22 ;

  // Field SNIFF_EN: If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n This allows checksum to be enabled or disabled on a per-control- block basis.
    const uint32_t DMA_CH0_CTRL_TRIG_SNIFF_EN = 1U << 23 ;

  // Field BUSY: This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.\n\n To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
    const uint32_t DMA_CH0_CTRL_TRIG_BUSY = 1U << 24 ;

  // Field WRITE_ERROR: If 1, the channel received a write bus error. Write one to clear.\n WRITE_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 5 transfers later)
    const uint32_t DMA_CH0_CTRL_TRIG_WRITE_ERROR = 1U << 29 ;

  // Field READ_ERROR: If 1, the channel received a read bus error. Write one to clear.\n READ_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 3 transfers later)
    const uint32_t DMA_CH0_CTRL_TRIG_READ_ERROR = 1U << 30 ;

  // Field AHB_ERROR: Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
    const uint32_t DMA_CH0_CTRL_TRIG_AHB_ERROR = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register CH0_AL1_CTRL: Alias for channel 0 CTRL register
  static volatile uint32_t const & DMA_CH0_AL1_CTRL __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 16)) ;

//------------------------------------------------------------------------------

//---  Register CH0_AL1_READ_ADDR: Alias for channel 0 READ_ADDR register
  static volatile uint32_t const & DMA_CH0_AL1_READ_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 20)) ;

//------------------------------------------------------------------------------

//---  Register CH0_AL1_WRITE_ADDR: Alias for channel 0 WRITE_ADDR register
  static volatile uint32_t const & DMA_CH0_AL1_WRITE_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 24)) ;

//------------------------------------------------------------------------------

//---  Register CH0_AL1_TRANS_COUNT_TRIG: Alias for channel 0 TRANS_COUNT register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
  static volatile uint32_t const & DMA_CH0_AL1_TRANS_COUNT_TRIG __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 28)) ;

//------------------------------------------------------------------------------

//---  Register CH0_AL2_CTRL: Alias for channel 0 CTRL register
  static volatile uint32_t const & DMA_CH0_AL2_CTRL __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 32)) ;

//------------------------------------------------------------------------------

//---  Register CH0_AL2_TRANS_COUNT: Alias for channel 0 TRANS_COUNT register
  static volatile uint32_t const & DMA_CH0_AL2_TRANS_COUNT __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 36)) ;

//------------------------------------------------------------------------------

//---  Register CH0_AL2_READ_ADDR: Alias for channel 0 READ_ADDR register
  static volatile uint32_t const & DMA_CH0_AL2_READ_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 40)) ;

//------------------------------------------------------------------------------

//---  Register CH0_AL2_WRITE_ADDR_TRIG: Alias for channel 0 WRITE_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
  static volatile uint32_t const & DMA_CH0_AL2_WRITE_ADDR_TRIG __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 44)) ;

//------------------------------------------------------------------------------

//---  Register CH0_AL3_CTRL: Alias for channel 0 CTRL register
  static volatile uint32_t const & DMA_CH0_AL3_CTRL __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 48)) ;

//------------------------------------------------------------------------------

//---  Register CH0_AL3_WRITE_ADDR: Alias for channel 0 WRITE_ADDR register
  static volatile uint32_t const & DMA_CH0_AL3_WRITE_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 52)) ;

//------------------------------------------------------------------------------

//---  Register CH0_AL3_TRANS_COUNT: Alias for channel 0 TRANS_COUNT register
  static volatile uint32_t const & DMA_CH0_AL3_TRANS_COUNT __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 56)) ;

//------------------------------------------------------------------------------

//---  Register CH0_AL3_READ_ADDR_TRIG: Alias for channel 0 READ_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
  static volatile uint32_t const & DMA_CH0_AL3_READ_ADDR_TRIG __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 60)) ;

//------------------------------------------------------------------------------

//---  Register CH1_READ_ADDR: DMA Channel 1 Read Address pointer\n This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
  static volatile uint32_t & DMA_CH1_READ_ADDR __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 64)) ;

//------------------------------------------------------------------------------

//---  Register CH1_WRITE_ADDR: DMA Channel 1 Write Address pointer\n This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
  static volatile uint32_t & DMA_CH1_WRITE_ADDR __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 68)) ;

//------------------------------------------------------------------------------

//---  Register CH1_TRANS_COUNT: DMA Channel 1 Transfer Count\n Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
  static volatile uint32_t & DMA_CH1_TRANS_COUNT __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 72)) ;

//------------------------------------------------------------------------------

//---  Register CH1_CTRL_TRIG: DMA Channel 1 Control and Status
  static volatile uint32_t & DMA_CH1_CTRL_TRIG __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 76)) ;

  // Field EN: DMA Channel Enable.\n When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
    const uint32_t DMA_CH1_CTRL_TRIG_EN = 1U << 0 ;

  // Field HIGH_PRIORITY: HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
    const uint32_t DMA_CH1_CTRL_TRIG_HIGH_PRIORITY = 1U << 1 ;

  // Field DATA_SIZE: Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
    inline uint32_t DMA_CH1_CTRL_TRIG_DATA_SIZE (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field INCR_READ: If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n Generally this should be disabled for peripheral-to-memory transfers.
    const uint32_t DMA_CH1_CTRL_TRIG_INCR_READ = 1U << 4 ;

  // Field INCR_WRITE: If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n Generally this should be disabled for memory-to-peripheral transfers.
    const uint32_t DMA_CH1_CTRL_TRIG_INCR_WRITE = 1U << 5 ;

  // Field RING_SIZE: Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
    inline uint32_t DMA_CH1_CTRL_TRIG_RING_SIZE (const uint32_t inValue) {return (inValue & 0xFU) << 6 ; }

  // Field RING_SEL: Select whether RING_SIZE applies to read or write addresses.\n If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
    const uint32_t DMA_CH1_CTRL_TRIG_RING_SEL = 1U << 10 ;

  // Field CHAIN_TO: When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.\n Reset value is equal to channel number (1).
    inline uint32_t DMA_CH1_CTRL_TRIG_CHAIN_TO (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field TREQ_SEL: Select a Transfer Request signal.\n The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system).\n 0x0 to 0x3a -> select DREQ n as TREQ
    inline uint32_t DMA_CH1_CTRL_TRIG_TREQ_SEL (const uint32_t inValue) {return (inValue & 0x3FU) << 15 ; }

  // Field IRQ_QUIET: In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
    const uint32_t DMA_CH1_CTRL_TRIG_IRQ_QUIET = 1U << 21 ;

  // Field BSWAP: Apply byte-swap transformation to DMA data.\n For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
    const uint32_t DMA_CH1_CTRL_TRIG_BSWAP = 1U << 22 ;

  // Field SNIFF_EN: If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n This allows checksum to be enabled or disabled on a per-control- block basis.
    const uint32_t DMA_CH1_CTRL_TRIG_SNIFF_EN = 1U << 23 ;

  // Field BUSY: This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.\n\n To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
    const uint32_t DMA_CH1_CTRL_TRIG_BUSY = 1U << 24 ;

  // Field WRITE_ERROR: If 1, the channel received a write bus error. Write one to clear.\n WRITE_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 5 transfers later)
    const uint32_t DMA_CH1_CTRL_TRIG_WRITE_ERROR = 1U << 29 ;

  // Field READ_ERROR: If 1, the channel received a read bus error. Write one to clear.\n READ_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 3 transfers later)
    const uint32_t DMA_CH1_CTRL_TRIG_READ_ERROR = 1U << 30 ;

  // Field AHB_ERROR: Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
    const uint32_t DMA_CH1_CTRL_TRIG_AHB_ERROR = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register CH1_AL1_CTRL: Alias for channel 1 CTRL register
  static volatile uint32_t const & DMA_CH1_AL1_CTRL __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 80)) ;

//------------------------------------------------------------------------------

//---  Register CH1_AL1_READ_ADDR: Alias for channel 1 READ_ADDR register
  static volatile uint32_t const & DMA_CH1_AL1_READ_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 84)) ;

//------------------------------------------------------------------------------

//---  Register CH1_AL1_WRITE_ADDR: Alias for channel 1 WRITE_ADDR register
  static volatile uint32_t const & DMA_CH1_AL1_WRITE_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 88)) ;

//------------------------------------------------------------------------------

//---  Register CH1_AL1_TRANS_COUNT_TRIG: Alias for channel 1 TRANS_COUNT register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
  static volatile uint32_t const & DMA_CH1_AL1_TRANS_COUNT_TRIG __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 92)) ;

//------------------------------------------------------------------------------

//---  Register CH1_AL2_CTRL: Alias for channel 1 CTRL register
  static volatile uint32_t const & DMA_CH1_AL2_CTRL __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 96)) ;

//------------------------------------------------------------------------------

//---  Register CH1_AL2_TRANS_COUNT: Alias for channel 1 TRANS_COUNT register
  static volatile uint32_t const & DMA_CH1_AL2_TRANS_COUNT __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 100)) ;

//------------------------------------------------------------------------------

//---  Register CH1_AL2_READ_ADDR: Alias for channel 1 READ_ADDR register
  static volatile uint32_t const & DMA_CH1_AL2_READ_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 104)) ;

//------------------------------------------------------------------------------

//---  Register CH1_AL2_WRITE_ADDR_TRIG: Alias for channel 1 WRITE_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
  static volatile uint32_t const & DMA_CH1_AL2_WRITE_ADDR_TRIG __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 108)) ;

//------------------------------------------------------------------------------

//---  Register CH1_AL3_CTRL: Alias for channel 1 CTRL register
  static volatile uint32_t const & DMA_CH1_AL3_CTRL __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 112)) ;

//------------------------------------------------------------------------------

//---  Register CH1_AL3_WRITE_ADDR: Alias for channel 1 WRITE_ADDR register
  static volatile uint32_t const & DMA_CH1_AL3_WRITE_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 116)) ;

//------------------------------------------------------------------------------

//---  Register CH1_AL3_TRANS_COUNT: Alias for channel 1 TRANS_COUNT register
  static volatile uint32_t const & DMA_CH1_AL3_TRANS_COUNT __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 120)) ;

//------------------------------------------------------------------------------

//---  Register CH1_AL3_READ_ADDR_TRIG: Alias for channel 1 READ_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
  static volatile uint32_t const & DMA_CH1_AL3_READ_ADDR_TRIG __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 124)) ;

//------------------------------------------------------------------------------

//---  Register CH2_READ_ADDR: DMA Channel 2 Read Address pointer\n This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
  static volatile uint32_t & DMA_CH2_READ_ADDR __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 128)) ;

//------------------------------------------------------------------------------

//---  Register CH2_WRITE_ADDR: DMA Channel 2 Write Address pointer\n This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
  static volatile uint32_t & DMA_CH2_WRITE_ADDR __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 132)) ;

//------------------------------------------------------------------------------

//---  Register CH2_TRANS_COUNT: DMA Channel 2 Transfer Count\n Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
  static volatile uint32_t & DMA_CH2_TRANS_COUNT __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 136)) ;

//------------------------------------------------------------------------------

//---  Register CH2_CTRL_TRIG: DMA Channel 2 Control and Status
  static volatile uint32_t & DMA_CH2_CTRL_TRIG __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 140)) ;

  // Field EN: DMA Channel Enable.\n When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
    const uint32_t DMA_CH2_CTRL_TRIG_EN = 1U << 0 ;

  // Field HIGH_PRIORITY: HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
    const uint32_t DMA_CH2_CTRL_TRIG_HIGH_PRIORITY = 1U << 1 ;

  // Field DATA_SIZE: Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
    inline uint32_t DMA_CH2_CTRL_TRIG_DATA_SIZE (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field INCR_READ: If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n Generally this should be disabled for peripheral-to-memory transfers.
    const uint32_t DMA_CH2_CTRL_TRIG_INCR_READ = 1U << 4 ;

  // Field INCR_WRITE: If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n Generally this should be disabled for memory-to-peripheral transfers.
    const uint32_t DMA_CH2_CTRL_TRIG_INCR_WRITE = 1U << 5 ;

  // Field RING_SIZE: Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
    inline uint32_t DMA_CH2_CTRL_TRIG_RING_SIZE (const uint32_t inValue) {return (inValue & 0xFU) << 6 ; }

  // Field RING_SEL: Select whether RING_SIZE applies to read or write addresses.\n If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
    const uint32_t DMA_CH2_CTRL_TRIG_RING_SEL = 1U << 10 ;

  // Field CHAIN_TO: When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.\n Reset value is equal to channel number (2).
    inline uint32_t DMA_CH2_CTRL_TRIG_CHAIN_TO (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field TREQ_SEL: Select a Transfer Request signal.\n The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system).\n 0x0 to 0x3a -> select DREQ n as TREQ
    inline uint32_t DMA_CH2_CTRL_TRIG_TREQ_SEL (const uint32_t inValue) {return (inValue & 0x3FU) << 15 ; }

  // Field IRQ_QUIET: In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
    const uint32_t DMA_CH2_CTRL_TRIG_IRQ_QUIET = 1U << 21 ;

  // Field BSWAP: Apply byte-swap transformation to DMA data.\n For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
    const uint32_t DMA_CH2_CTRL_TRIG_BSWAP = 1U << 22 ;

  // Field SNIFF_EN: If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n This allows checksum to be enabled or disabled on a per-control- block basis.
    const uint32_t DMA_CH2_CTRL_TRIG_SNIFF_EN = 1U << 23 ;

  // Field BUSY: This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.\n\n To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
    const uint32_t DMA_CH2_CTRL_TRIG_BUSY = 1U << 24 ;

  // Field WRITE_ERROR: If 1, the channel received a write bus error. Write one to clear.\n WRITE_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 5 transfers later)
    const uint32_t DMA_CH2_CTRL_TRIG_WRITE_ERROR = 1U << 29 ;

  // Field READ_ERROR: If 1, the channel received a read bus error. Write one to clear.\n READ_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 3 transfers later)
    const uint32_t DMA_CH2_CTRL_TRIG_READ_ERROR = 1U << 30 ;

  // Field AHB_ERROR: Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
    const uint32_t DMA_CH2_CTRL_TRIG_AHB_ERROR = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register CH2_AL1_CTRL: Alias for channel 2 CTRL register
  static volatile uint32_t const & DMA_CH2_AL1_CTRL __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 144)) ;

//------------------------------------------------------------------------------

//---  Register CH2_AL1_READ_ADDR: Alias for channel 2 READ_ADDR register
  static volatile uint32_t const & DMA_CH2_AL1_READ_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 148)) ;

//------------------------------------------------------------------------------

//---  Register CH2_AL1_WRITE_ADDR: Alias for channel 2 WRITE_ADDR register
  static volatile uint32_t const & DMA_CH2_AL1_WRITE_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 152)) ;

//------------------------------------------------------------------------------

//---  Register CH2_AL1_TRANS_COUNT_TRIG: Alias for channel 2 TRANS_COUNT register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
  static volatile uint32_t const & DMA_CH2_AL1_TRANS_COUNT_TRIG __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 156)) ;

//------------------------------------------------------------------------------

//---  Register CH2_AL2_CTRL: Alias for channel 2 CTRL register
  static volatile uint32_t const & DMA_CH2_AL2_CTRL __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 160)) ;

//------------------------------------------------------------------------------

//---  Register CH2_AL2_TRANS_COUNT: Alias for channel 2 TRANS_COUNT register
  static volatile uint32_t const & DMA_CH2_AL2_TRANS_COUNT __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 164)) ;

//------------------------------------------------------------------------------

//---  Register CH2_AL2_READ_ADDR: Alias for channel 2 READ_ADDR register
  static volatile uint32_t const & DMA_CH2_AL2_READ_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 168)) ;

//------------------------------------------------------------------------------

//---  Register CH2_AL2_WRITE_ADDR_TRIG: Alias for channel 2 WRITE_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
  static volatile uint32_t const & DMA_CH2_AL2_WRITE_ADDR_TRIG __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 172)) ;

//------------------------------------------------------------------------------

//---  Register CH2_AL3_CTRL: Alias for channel 2 CTRL register
  static volatile uint32_t const & DMA_CH2_AL3_CTRL __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 176)) ;

//------------------------------------------------------------------------------

//---  Register CH2_AL3_WRITE_ADDR: Alias for channel 2 WRITE_ADDR register
  static volatile uint32_t const & DMA_CH2_AL3_WRITE_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 180)) ;

//------------------------------------------------------------------------------

//---  Register CH2_AL3_TRANS_COUNT: Alias for channel 2 TRANS_COUNT register
  static volatile uint32_t const & DMA_CH2_AL3_TRANS_COUNT __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 184)) ;

//------------------------------------------------------------------------------

//---  Register CH2_AL3_READ_ADDR_TRIG: Alias for channel 2 READ_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
  static volatile uint32_t const & DMA_CH2_AL3_READ_ADDR_TRIG __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 188)) ;

//------------------------------------------------------------------------------

//---  Register CH3_READ_ADDR: DMA Channel 3 Read Address pointer\n This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
  static volatile uint32_t & DMA_CH3_READ_ADDR __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 192)) ;

//------------------------------------------------------------------------------

//---  Register CH3_WRITE_ADDR: DMA Channel 3 Write Address pointer\n This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
  static volatile uint32_t & DMA_CH3_WRITE_ADDR __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 196)) ;

//------------------------------------------------------------------------------

//---  Register CH3_TRANS_COUNT: DMA Channel 3 Transfer Count\n Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
  static volatile uint32_t & DMA_CH3_TRANS_COUNT __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 200)) ;

//------------------------------------------------------------------------------

//---  Register CH3_CTRL_TRIG: DMA Channel 3 Control and Status
  static volatile uint32_t & DMA_CH3_CTRL_TRIG __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 204)) ;

  // Field EN: DMA Channel Enable.\n When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
    const uint32_t DMA_CH3_CTRL_TRIG_EN = 1U << 0 ;

  // Field HIGH_PRIORITY: HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
    const uint32_t DMA_CH3_CTRL_TRIG_HIGH_PRIORITY = 1U << 1 ;

  // Field DATA_SIZE: Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
    inline uint32_t DMA_CH3_CTRL_TRIG_DATA_SIZE (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field INCR_READ: If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n Generally this should be disabled for peripheral-to-memory transfers.
    const uint32_t DMA_CH3_CTRL_TRIG_INCR_READ = 1U << 4 ;

  // Field INCR_WRITE: If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n Generally this should be disabled for memory-to-peripheral transfers.
    const uint32_t DMA_CH3_CTRL_TRIG_INCR_WRITE = 1U << 5 ;

  // Field RING_SIZE: Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
    inline uint32_t DMA_CH3_CTRL_TRIG_RING_SIZE (const uint32_t inValue) {return (inValue & 0xFU) << 6 ; }

  // Field RING_SEL: Select whether RING_SIZE applies to read or write addresses.\n If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
    const uint32_t DMA_CH3_CTRL_TRIG_RING_SEL = 1U << 10 ;

  // Field CHAIN_TO: When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.\n Reset value is equal to channel number (3).
    inline uint32_t DMA_CH3_CTRL_TRIG_CHAIN_TO (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field TREQ_SEL: Select a Transfer Request signal.\n The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system).\n 0x0 to 0x3a -> select DREQ n as TREQ
    inline uint32_t DMA_CH3_CTRL_TRIG_TREQ_SEL (const uint32_t inValue) {return (inValue & 0x3FU) << 15 ; }

  // Field IRQ_QUIET: In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
    const uint32_t DMA_CH3_CTRL_TRIG_IRQ_QUIET = 1U << 21 ;

  // Field BSWAP: Apply byte-swap transformation to DMA data.\n For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
    const uint32_t DMA_CH3_CTRL_TRIG_BSWAP = 1U << 22 ;

  // Field SNIFF_EN: If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n This allows checksum to be enabled or disabled on a per-control- block basis.
    const uint32_t DMA_CH3_CTRL_TRIG_SNIFF_EN = 1U << 23 ;

  // Field BUSY: This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.\n\n To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
    const uint32_t DMA_CH3_CTRL_TRIG_BUSY = 1U << 24 ;

  // Field WRITE_ERROR: If 1, the channel received a write bus error. Write one to clear.\n WRITE_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 5 transfers later)
    const uint32_t DMA_CH3_CTRL_TRIG_WRITE_ERROR = 1U << 29 ;

  // Field READ_ERROR: If 1, the channel received a read bus error. Write one to clear.\n READ_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 3 transfers later)
    const uint32_t DMA_CH3_CTRL_TRIG_READ_ERROR = 1U << 30 ;

  // Field AHB_ERROR: Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
    const uint32_t DMA_CH3_CTRL_TRIG_AHB_ERROR = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register CH3_AL1_CTRL: Alias for channel 3 CTRL register
  static volatile uint32_t const & DMA_CH3_AL1_CTRL __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 208)) ;

//------------------------------------------------------------------------------

//---  Register CH3_AL1_READ_ADDR: Alias for channel 3 READ_ADDR register
  static volatile uint32_t const & DMA_CH3_AL1_READ_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 212)) ;

//------------------------------------------------------------------------------

//---  Register CH3_AL1_WRITE_ADDR: Alias for channel 3 WRITE_ADDR register
  static volatile uint32_t const & DMA_CH3_AL1_WRITE_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 216)) ;

//------------------------------------------------------------------------------

//---  Register CH3_AL1_TRANS_COUNT_TRIG: Alias for channel 3 TRANS_COUNT register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
  static volatile uint32_t const & DMA_CH3_AL1_TRANS_COUNT_TRIG __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 220)) ;

//------------------------------------------------------------------------------

//---  Register CH3_AL2_CTRL: Alias for channel 3 CTRL register
  static volatile uint32_t const & DMA_CH3_AL2_CTRL __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 224)) ;

//------------------------------------------------------------------------------

//---  Register CH3_AL2_TRANS_COUNT: Alias for channel 3 TRANS_COUNT register
  static volatile uint32_t const & DMA_CH3_AL2_TRANS_COUNT __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 228)) ;

//------------------------------------------------------------------------------

//---  Register CH3_AL2_READ_ADDR: Alias for channel 3 READ_ADDR register
  static volatile uint32_t const & DMA_CH3_AL2_READ_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 232)) ;

//------------------------------------------------------------------------------

//---  Register CH3_AL2_WRITE_ADDR_TRIG: Alias for channel 3 WRITE_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
  static volatile uint32_t const & DMA_CH3_AL2_WRITE_ADDR_TRIG __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 236)) ;

//------------------------------------------------------------------------------

//---  Register CH3_AL3_CTRL: Alias for channel 3 CTRL register
  static volatile uint32_t const & DMA_CH3_AL3_CTRL __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 240)) ;

//------------------------------------------------------------------------------

//---  Register CH3_AL3_WRITE_ADDR: Alias for channel 3 WRITE_ADDR register
  static volatile uint32_t const & DMA_CH3_AL3_WRITE_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 244)) ;

//------------------------------------------------------------------------------

//---  Register CH3_AL3_TRANS_COUNT: Alias for channel 3 TRANS_COUNT register
  static volatile uint32_t const & DMA_CH3_AL3_TRANS_COUNT __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 248)) ;

//------------------------------------------------------------------------------

//---  Register CH3_AL3_READ_ADDR_TRIG: Alias for channel 3 READ_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
  static volatile uint32_t const & DMA_CH3_AL3_READ_ADDR_TRIG __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 252)) ;

//------------------------------------------------------------------------------

//---  Register CH4_READ_ADDR: DMA Channel 4 Read Address pointer\n This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
  static volatile uint32_t & DMA_CH4_READ_ADDR __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 256)) ;

//------------------------------------------------------------------------------

//---  Register CH4_WRITE_ADDR: DMA Channel 4 Write Address pointer\n This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
  static volatile uint32_t & DMA_CH4_WRITE_ADDR __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 260)) ;

//------------------------------------------------------------------------------

//---  Register CH4_TRANS_COUNT: DMA Channel 4 Transfer Count\n Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
  static volatile uint32_t & DMA_CH4_TRANS_COUNT __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 264)) ;

//------------------------------------------------------------------------------

//---  Register CH4_CTRL_TRIG: DMA Channel 4 Control and Status
  static volatile uint32_t & DMA_CH4_CTRL_TRIG __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 268)) ;

  // Field EN: DMA Channel Enable.\n When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
    const uint32_t DMA_CH4_CTRL_TRIG_EN = 1U << 0 ;

  // Field HIGH_PRIORITY: HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
    const uint32_t DMA_CH4_CTRL_TRIG_HIGH_PRIORITY = 1U << 1 ;

  // Field DATA_SIZE: Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
    inline uint32_t DMA_CH4_CTRL_TRIG_DATA_SIZE (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field INCR_READ: If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n Generally this should be disabled for peripheral-to-memory transfers.
    const uint32_t DMA_CH4_CTRL_TRIG_INCR_READ = 1U << 4 ;

  // Field INCR_WRITE: If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n Generally this should be disabled for memory-to-peripheral transfers.
    const uint32_t DMA_CH4_CTRL_TRIG_INCR_WRITE = 1U << 5 ;

  // Field RING_SIZE: Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
    inline uint32_t DMA_CH4_CTRL_TRIG_RING_SIZE (const uint32_t inValue) {return (inValue & 0xFU) << 6 ; }

  // Field RING_SEL: Select whether RING_SIZE applies to read or write addresses.\n If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
    const uint32_t DMA_CH4_CTRL_TRIG_RING_SEL = 1U << 10 ;

  // Field CHAIN_TO: When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.\n Reset value is equal to channel number (4).
    inline uint32_t DMA_CH4_CTRL_TRIG_CHAIN_TO (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field TREQ_SEL: Select a Transfer Request signal.\n The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system).\n 0x0 to 0x3a -> select DREQ n as TREQ
    inline uint32_t DMA_CH4_CTRL_TRIG_TREQ_SEL (const uint32_t inValue) {return (inValue & 0x3FU) << 15 ; }

  // Field IRQ_QUIET: In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
    const uint32_t DMA_CH4_CTRL_TRIG_IRQ_QUIET = 1U << 21 ;

  // Field BSWAP: Apply byte-swap transformation to DMA data.\n For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
    const uint32_t DMA_CH4_CTRL_TRIG_BSWAP = 1U << 22 ;

  // Field SNIFF_EN: If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n This allows checksum to be enabled or disabled on a per-control- block basis.
    const uint32_t DMA_CH4_CTRL_TRIG_SNIFF_EN = 1U << 23 ;

  // Field BUSY: This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.\n\n To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
    const uint32_t DMA_CH4_CTRL_TRIG_BUSY = 1U << 24 ;

  // Field WRITE_ERROR: If 1, the channel received a write bus error. Write one to clear.\n WRITE_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 5 transfers later)
    const uint32_t DMA_CH4_CTRL_TRIG_WRITE_ERROR = 1U << 29 ;

  // Field READ_ERROR: If 1, the channel received a read bus error. Write one to clear.\n READ_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 3 transfers later)
    const uint32_t DMA_CH4_CTRL_TRIG_READ_ERROR = 1U << 30 ;

  // Field AHB_ERROR: Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
    const uint32_t DMA_CH4_CTRL_TRIG_AHB_ERROR = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register CH4_AL1_CTRL: Alias for channel 4 CTRL register
  static volatile uint32_t const & DMA_CH4_AL1_CTRL __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 272)) ;

//------------------------------------------------------------------------------

//---  Register CH4_AL1_READ_ADDR: Alias for channel 4 READ_ADDR register
  static volatile uint32_t const & DMA_CH4_AL1_READ_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 276)) ;

//------------------------------------------------------------------------------

//---  Register CH4_AL1_WRITE_ADDR: Alias for channel 4 WRITE_ADDR register
  static volatile uint32_t const & DMA_CH4_AL1_WRITE_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 280)) ;

//------------------------------------------------------------------------------

//---  Register CH4_AL1_TRANS_COUNT_TRIG: Alias for channel 4 TRANS_COUNT register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
  static volatile uint32_t const & DMA_CH4_AL1_TRANS_COUNT_TRIG __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 284)) ;

//------------------------------------------------------------------------------

//---  Register CH4_AL2_CTRL: Alias for channel 4 CTRL register
  static volatile uint32_t const & DMA_CH4_AL2_CTRL __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 288)) ;

//------------------------------------------------------------------------------

//---  Register CH4_AL2_TRANS_COUNT: Alias for channel 4 TRANS_COUNT register
  static volatile uint32_t const & DMA_CH4_AL2_TRANS_COUNT __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 292)) ;

//------------------------------------------------------------------------------

//---  Register CH4_AL2_READ_ADDR: Alias for channel 4 READ_ADDR register
  static volatile uint32_t const & DMA_CH4_AL2_READ_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 296)) ;

//------------------------------------------------------------------------------

//---  Register CH4_AL2_WRITE_ADDR_TRIG: Alias for channel 4 WRITE_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
  static volatile uint32_t const & DMA_CH4_AL2_WRITE_ADDR_TRIG __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 300)) ;

//------------------------------------------------------------------------------

//---  Register CH4_AL3_CTRL: Alias for channel 4 CTRL register
  static volatile uint32_t const & DMA_CH4_AL3_CTRL __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 304)) ;

//------------------------------------------------------------------------------

//---  Register CH4_AL3_WRITE_ADDR: Alias for channel 4 WRITE_ADDR register
  static volatile uint32_t const & DMA_CH4_AL3_WRITE_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 308)) ;

//------------------------------------------------------------------------------

//---  Register CH4_AL3_TRANS_COUNT: Alias for channel 4 TRANS_COUNT register
  static volatile uint32_t const & DMA_CH4_AL3_TRANS_COUNT __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 312)) ;

//------------------------------------------------------------------------------

//---  Register CH4_AL3_READ_ADDR_TRIG: Alias for channel 4 READ_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
  static volatile uint32_t const & DMA_CH4_AL3_READ_ADDR_TRIG __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 316)) ;

//------------------------------------------------------------------------------

//---  Register CH5_READ_ADDR: DMA Channel 5 Read Address pointer\n This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
  static volatile uint32_t & DMA_CH5_READ_ADDR __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 320)) ;

//------------------------------------------------------------------------------

//---  Register CH5_WRITE_ADDR: DMA Channel 5 Write Address pointer\n This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
  static volatile uint32_t & DMA_CH5_WRITE_ADDR __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 324)) ;

//------------------------------------------------------------------------------

//---  Register CH5_TRANS_COUNT: DMA Channel 5 Transfer Count\n Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
  static volatile uint32_t & DMA_CH5_TRANS_COUNT __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 328)) ;

//------------------------------------------------------------------------------

//---  Register CH5_CTRL_TRIG: DMA Channel 5 Control and Status
  static volatile uint32_t & DMA_CH5_CTRL_TRIG __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 332)) ;

  // Field EN: DMA Channel Enable.\n When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
    const uint32_t DMA_CH5_CTRL_TRIG_EN = 1U << 0 ;

  // Field HIGH_PRIORITY: HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
    const uint32_t DMA_CH5_CTRL_TRIG_HIGH_PRIORITY = 1U << 1 ;

  // Field DATA_SIZE: Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
    inline uint32_t DMA_CH5_CTRL_TRIG_DATA_SIZE (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field INCR_READ: If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n Generally this should be disabled for peripheral-to-memory transfers.
    const uint32_t DMA_CH5_CTRL_TRIG_INCR_READ = 1U << 4 ;

  // Field INCR_WRITE: If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n Generally this should be disabled for memory-to-peripheral transfers.
    const uint32_t DMA_CH5_CTRL_TRIG_INCR_WRITE = 1U << 5 ;

  // Field RING_SIZE: Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
    inline uint32_t DMA_CH5_CTRL_TRIG_RING_SIZE (const uint32_t inValue) {return (inValue & 0xFU) << 6 ; }

  // Field RING_SEL: Select whether RING_SIZE applies to read or write addresses.\n If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
    const uint32_t DMA_CH5_CTRL_TRIG_RING_SEL = 1U << 10 ;

  // Field CHAIN_TO: When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.\n Reset value is equal to channel number (5).
    inline uint32_t DMA_CH5_CTRL_TRIG_CHAIN_TO (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field TREQ_SEL: Select a Transfer Request signal.\n The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system).\n 0x0 to 0x3a -> select DREQ n as TREQ
    inline uint32_t DMA_CH5_CTRL_TRIG_TREQ_SEL (const uint32_t inValue) {return (inValue & 0x3FU) << 15 ; }

  // Field IRQ_QUIET: In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
    const uint32_t DMA_CH5_CTRL_TRIG_IRQ_QUIET = 1U << 21 ;

  // Field BSWAP: Apply byte-swap transformation to DMA data.\n For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
    const uint32_t DMA_CH5_CTRL_TRIG_BSWAP = 1U << 22 ;

  // Field SNIFF_EN: If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n This allows checksum to be enabled or disabled on a per-control- block basis.
    const uint32_t DMA_CH5_CTRL_TRIG_SNIFF_EN = 1U << 23 ;

  // Field BUSY: This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.\n\n To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
    const uint32_t DMA_CH5_CTRL_TRIG_BUSY = 1U << 24 ;

  // Field WRITE_ERROR: If 1, the channel received a write bus error. Write one to clear.\n WRITE_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 5 transfers later)
    const uint32_t DMA_CH5_CTRL_TRIG_WRITE_ERROR = 1U << 29 ;

  // Field READ_ERROR: If 1, the channel received a read bus error. Write one to clear.\n READ_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 3 transfers later)
    const uint32_t DMA_CH5_CTRL_TRIG_READ_ERROR = 1U << 30 ;

  // Field AHB_ERROR: Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
    const uint32_t DMA_CH5_CTRL_TRIG_AHB_ERROR = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register CH5_AL1_CTRL: Alias for channel 5 CTRL register
  static volatile uint32_t const & DMA_CH5_AL1_CTRL __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 336)) ;

//------------------------------------------------------------------------------

//---  Register CH5_AL1_READ_ADDR: Alias for channel 5 READ_ADDR register
  static volatile uint32_t const & DMA_CH5_AL1_READ_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 340)) ;

//------------------------------------------------------------------------------

//---  Register CH5_AL1_WRITE_ADDR: Alias for channel 5 WRITE_ADDR register
  static volatile uint32_t const & DMA_CH5_AL1_WRITE_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 344)) ;

//------------------------------------------------------------------------------

//---  Register CH5_AL1_TRANS_COUNT_TRIG: Alias for channel 5 TRANS_COUNT register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
  static volatile uint32_t const & DMA_CH5_AL1_TRANS_COUNT_TRIG __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 348)) ;

//------------------------------------------------------------------------------

//---  Register CH5_AL2_CTRL: Alias for channel 5 CTRL register
  static volatile uint32_t const & DMA_CH5_AL2_CTRL __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 352)) ;

//------------------------------------------------------------------------------

//---  Register CH5_AL2_TRANS_COUNT: Alias for channel 5 TRANS_COUNT register
  static volatile uint32_t const & DMA_CH5_AL2_TRANS_COUNT __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 356)) ;

//------------------------------------------------------------------------------

//---  Register CH5_AL2_READ_ADDR: Alias for channel 5 READ_ADDR register
  static volatile uint32_t const & DMA_CH5_AL2_READ_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 360)) ;

//------------------------------------------------------------------------------

//---  Register CH5_AL2_WRITE_ADDR_TRIG: Alias for channel 5 WRITE_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
  static volatile uint32_t const & DMA_CH5_AL2_WRITE_ADDR_TRIG __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 364)) ;

//------------------------------------------------------------------------------

//---  Register CH5_AL3_CTRL: Alias for channel 5 CTRL register
  static volatile uint32_t const & DMA_CH5_AL3_CTRL __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 368)) ;

//------------------------------------------------------------------------------

//---  Register CH5_AL3_WRITE_ADDR: Alias for channel 5 WRITE_ADDR register
  static volatile uint32_t const & DMA_CH5_AL3_WRITE_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 372)) ;

//------------------------------------------------------------------------------

//---  Register CH5_AL3_TRANS_COUNT: Alias for channel 5 TRANS_COUNT register
  static volatile uint32_t const & DMA_CH5_AL3_TRANS_COUNT __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 376)) ;

//------------------------------------------------------------------------------

//---  Register CH5_AL3_READ_ADDR_TRIG: Alias for channel 5 READ_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
  static volatile uint32_t const & DMA_CH5_AL3_READ_ADDR_TRIG __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 380)) ;

//------------------------------------------------------------------------------

//---  Register CH6_READ_ADDR: DMA Channel 6 Read Address pointer\n This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
  static volatile uint32_t & DMA_CH6_READ_ADDR __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 384)) ;

//------------------------------------------------------------------------------

//---  Register CH6_WRITE_ADDR: DMA Channel 6 Write Address pointer\n This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
  static volatile uint32_t & DMA_CH6_WRITE_ADDR __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 388)) ;

//------------------------------------------------------------------------------

//---  Register CH6_TRANS_COUNT: DMA Channel 6 Transfer Count\n Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
  static volatile uint32_t & DMA_CH6_TRANS_COUNT __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 392)) ;

//------------------------------------------------------------------------------

//---  Register CH6_CTRL_TRIG: DMA Channel 6 Control and Status
  static volatile uint32_t & DMA_CH6_CTRL_TRIG __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 396)) ;

  // Field EN: DMA Channel Enable.\n When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
    const uint32_t DMA_CH6_CTRL_TRIG_EN = 1U << 0 ;

  // Field HIGH_PRIORITY: HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
    const uint32_t DMA_CH6_CTRL_TRIG_HIGH_PRIORITY = 1U << 1 ;

  // Field DATA_SIZE: Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
    inline uint32_t DMA_CH6_CTRL_TRIG_DATA_SIZE (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field INCR_READ: If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n Generally this should be disabled for peripheral-to-memory transfers.
    const uint32_t DMA_CH6_CTRL_TRIG_INCR_READ = 1U << 4 ;

  // Field INCR_WRITE: If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n Generally this should be disabled for memory-to-peripheral transfers.
    const uint32_t DMA_CH6_CTRL_TRIG_INCR_WRITE = 1U << 5 ;

  // Field RING_SIZE: Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
    inline uint32_t DMA_CH6_CTRL_TRIG_RING_SIZE (const uint32_t inValue) {return (inValue & 0xFU) << 6 ; }

  // Field RING_SEL: Select whether RING_SIZE applies to read or write addresses.\n If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
    const uint32_t DMA_CH6_CTRL_TRIG_RING_SEL = 1U << 10 ;

  // Field CHAIN_TO: When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.\n Reset value is equal to channel number (6).
    inline uint32_t DMA_CH6_CTRL_TRIG_CHAIN_TO (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field TREQ_SEL: Select a Transfer Request signal.\n The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system).\n 0x0 to 0x3a -> select DREQ n as TREQ
    inline uint32_t DMA_CH6_CTRL_TRIG_TREQ_SEL (const uint32_t inValue) {return (inValue & 0x3FU) << 15 ; }

  // Field IRQ_QUIET: In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
    const uint32_t DMA_CH6_CTRL_TRIG_IRQ_QUIET = 1U << 21 ;

  // Field BSWAP: Apply byte-swap transformation to DMA data.\n For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
    const uint32_t DMA_CH6_CTRL_TRIG_BSWAP = 1U << 22 ;

  // Field SNIFF_EN: If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n This allows checksum to be enabled or disabled on a per-control- block basis.
    const uint32_t DMA_CH6_CTRL_TRIG_SNIFF_EN = 1U << 23 ;

  // Field BUSY: This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.\n\n To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
    const uint32_t DMA_CH6_CTRL_TRIG_BUSY = 1U << 24 ;

  // Field WRITE_ERROR: If 1, the channel received a write bus error. Write one to clear.\n WRITE_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 5 transfers later)
    const uint32_t DMA_CH6_CTRL_TRIG_WRITE_ERROR = 1U << 29 ;

  // Field READ_ERROR: If 1, the channel received a read bus error. Write one to clear.\n READ_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 3 transfers later)
    const uint32_t DMA_CH6_CTRL_TRIG_READ_ERROR = 1U << 30 ;

  // Field AHB_ERROR: Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
    const uint32_t DMA_CH6_CTRL_TRIG_AHB_ERROR = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register CH6_AL1_CTRL: Alias for channel 6 CTRL register
  static volatile uint32_t const & DMA_CH6_AL1_CTRL __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 400)) ;

//------------------------------------------------------------------------------

//---  Register CH6_AL1_READ_ADDR: Alias for channel 6 READ_ADDR register
  static volatile uint32_t const & DMA_CH6_AL1_READ_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 404)) ;

//------------------------------------------------------------------------------

//---  Register CH6_AL1_WRITE_ADDR: Alias for channel 6 WRITE_ADDR register
  static volatile uint32_t const & DMA_CH6_AL1_WRITE_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 408)) ;

//------------------------------------------------------------------------------

//---  Register CH6_AL1_TRANS_COUNT_TRIG: Alias for channel 6 TRANS_COUNT register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
  static volatile uint32_t const & DMA_CH6_AL1_TRANS_COUNT_TRIG __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 412)) ;

//------------------------------------------------------------------------------

//---  Register CH6_AL2_CTRL: Alias for channel 6 CTRL register
  static volatile uint32_t const & DMA_CH6_AL2_CTRL __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 416)) ;

//------------------------------------------------------------------------------

//---  Register CH6_AL2_TRANS_COUNT: Alias for channel 6 TRANS_COUNT register
  static volatile uint32_t const & DMA_CH6_AL2_TRANS_COUNT __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 420)) ;

//------------------------------------------------------------------------------

//---  Register CH6_AL2_READ_ADDR: Alias for channel 6 READ_ADDR register
  static volatile uint32_t const & DMA_CH6_AL2_READ_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 424)) ;

//------------------------------------------------------------------------------

//---  Register CH6_AL2_WRITE_ADDR_TRIG: Alias for channel 6 WRITE_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
  static volatile uint32_t const & DMA_CH6_AL2_WRITE_ADDR_TRIG __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 428)) ;

//------------------------------------------------------------------------------

//---  Register CH6_AL3_CTRL: Alias for channel 6 CTRL register
  static volatile uint32_t const & DMA_CH6_AL3_CTRL __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 432)) ;

//------------------------------------------------------------------------------

//---  Register CH6_AL3_WRITE_ADDR: Alias for channel 6 WRITE_ADDR register
  static volatile uint32_t const & DMA_CH6_AL3_WRITE_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 436)) ;

//------------------------------------------------------------------------------

//---  Register CH6_AL3_TRANS_COUNT: Alias for channel 6 TRANS_COUNT register
  static volatile uint32_t const & DMA_CH6_AL3_TRANS_COUNT __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 440)) ;

//------------------------------------------------------------------------------

//---  Register CH6_AL3_READ_ADDR_TRIG: Alias for channel 6 READ_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
  static volatile uint32_t const & DMA_CH6_AL3_READ_ADDR_TRIG __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 444)) ;

//------------------------------------------------------------------------------

//---  Register CH7_READ_ADDR: DMA Channel 7 Read Address pointer\n This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
  static volatile uint32_t & DMA_CH7_READ_ADDR __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 448)) ;

//------------------------------------------------------------------------------

//---  Register CH7_WRITE_ADDR: DMA Channel 7 Write Address pointer\n This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
  static volatile uint32_t & DMA_CH7_WRITE_ADDR __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 452)) ;

//------------------------------------------------------------------------------

//---  Register CH7_TRANS_COUNT: DMA Channel 7 Transfer Count\n Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
  static volatile uint32_t & DMA_CH7_TRANS_COUNT __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 456)) ;

//------------------------------------------------------------------------------

//---  Register CH7_CTRL_TRIG: DMA Channel 7 Control and Status
  static volatile uint32_t & DMA_CH7_CTRL_TRIG __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 460)) ;

  // Field EN: DMA Channel Enable.\n When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
    const uint32_t DMA_CH7_CTRL_TRIG_EN = 1U << 0 ;

  // Field HIGH_PRIORITY: HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
    const uint32_t DMA_CH7_CTRL_TRIG_HIGH_PRIORITY = 1U << 1 ;

  // Field DATA_SIZE: Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
    inline uint32_t DMA_CH7_CTRL_TRIG_DATA_SIZE (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field INCR_READ: If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n Generally this should be disabled for peripheral-to-memory transfers.
    const uint32_t DMA_CH7_CTRL_TRIG_INCR_READ = 1U << 4 ;

  // Field INCR_WRITE: If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n Generally this should be disabled for memory-to-peripheral transfers.
    const uint32_t DMA_CH7_CTRL_TRIG_INCR_WRITE = 1U << 5 ;

  // Field RING_SIZE: Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
    inline uint32_t DMA_CH7_CTRL_TRIG_RING_SIZE (const uint32_t inValue) {return (inValue & 0xFU) << 6 ; }

  // Field RING_SEL: Select whether RING_SIZE applies to read or write addresses.\n If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
    const uint32_t DMA_CH7_CTRL_TRIG_RING_SEL = 1U << 10 ;

  // Field CHAIN_TO: When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.\n Reset value is equal to channel number (7).
    inline uint32_t DMA_CH7_CTRL_TRIG_CHAIN_TO (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field TREQ_SEL: Select a Transfer Request signal.\n The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system).\n 0x0 to 0x3a -> select DREQ n as TREQ
    inline uint32_t DMA_CH7_CTRL_TRIG_TREQ_SEL (const uint32_t inValue) {return (inValue & 0x3FU) << 15 ; }

  // Field IRQ_QUIET: In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
    const uint32_t DMA_CH7_CTRL_TRIG_IRQ_QUIET = 1U << 21 ;

  // Field BSWAP: Apply byte-swap transformation to DMA data.\n For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
    const uint32_t DMA_CH7_CTRL_TRIG_BSWAP = 1U << 22 ;

  // Field SNIFF_EN: If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n This allows checksum to be enabled or disabled on a per-control- block basis.
    const uint32_t DMA_CH7_CTRL_TRIG_SNIFF_EN = 1U << 23 ;

  // Field BUSY: This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.\n\n To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
    const uint32_t DMA_CH7_CTRL_TRIG_BUSY = 1U << 24 ;

  // Field WRITE_ERROR: If 1, the channel received a write bus error. Write one to clear.\n WRITE_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 5 transfers later)
    const uint32_t DMA_CH7_CTRL_TRIG_WRITE_ERROR = 1U << 29 ;

  // Field READ_ERROR: If 1, the channel received a read bus error. Write one to clear.\n READ_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 3 transfers later)
    const uint32_t DMA_CH7_CTRL_TRIG_READ_ERROR = 1U << 30 ;

  // Field AHB_ERROR: Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
    const uint32_t DMA_CH7_CTRL_TRIG_AHB_ERROR = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register CH7_AL1_CTRL: Alias for channel 7 CTRL register
  static volatile uint32_t const & DMA_CH7_AL1_CTRL __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 464)) ;

//------------------------------------------------------------------------------

//---  Register CH7_AL1_READ_ADDR: Alias for channel 7 READ_ADDR register
  static volatile uint32_t const & DMA_CH7_AL1_READ_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 468)) ;

//------------------------------------------------------------------------------

//---  Register CH7_AL1_WRITE_ADDR: Alias for channel 7 WRITE_ADDR register
  static volatile uint32_t const & DMA_CH7_AL1_WRITE_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 472)) ;

//------------------------------------------------------------------------------

//---  Register CH7_AL1_TRANS_COUNT_TRIG: Alias for channel 7 TRANS_COUNT register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
  static volatile uint32_t const & DMA_CH7_AL1_TRANS_COUNT_TRIG __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 476)) ;

//------------------------------------------------------------------------------

//---  Register CH7_AL2_CTRL: Alias for channel 7 CTRL register
  static volatile uint32_t const & DMA_CH7_AL2_CTRL __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 480)) ;

//------------------------------------------------------------------------------

//---  Register CH7_AL2_TRANS_COUNT: Alias for channel 7 TRANS_COUNT register
  static volatile uint32_t const & DMA_CH7_AL2_TRANS_COUNT __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 484)) ;

//------------------------------------------------------------------------------

//---  Register CH7_AL2_READ_ADDR: Alias for channel 7 READ_ADDR register
  static volatile uint32_t const & DMA_CH7_AL2_READ_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 488)) ;

//------------------------------------------------------------------------------

//---  Register CH7_AL2_WRITE_ADDR_TRIG: Alias for channel 7 WRITE_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
  static volatile uint32_t const & DMA_CH7_AL2_WRITE_ADDR_TRIG __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 492)) ;

//------------------------------------------------------------------------------

//---  Register CH7_AL3_CTRL: Alias for channel 7 CTRL register
  static volatile uint32_t const & DMA_CH7_AL3_CTRL __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 496)) ;

//------------------------------------------------------------------------------

//---  Register CH7_AL3_WRITE_ADDR: Alias for channel 7 WRITE_ADDR register
  static volatile uint32_t const & DMA_CH7_AL3_WRITE_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 500)) ;

//------------------------------------------------------------------------------

//---  Register CH7_AL3_TRANS_COUNT: Alias for channel 7 TRANS_COUNT register
  static volatile uint32_t const & DMA_CH7_AL3_TRANS_COUNT __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 504)) ;

//------------------------------------------------------------------------------

//---  Register CH7_AL3_READ_ADDR_TRIG: Alias for channel 7 READ_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
  static volatile uint32_t const & DMA_CH7_AL3_READ_ADDR_TRIG __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 508)) ;

//------------------------------------------------------------------------------

//---  Register CH8_READ_ADDR: DMA Channel 8 Read Address pointer\n This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
  static volatile uint32_t & DMA_CH8_READ_ADDR __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 512)) ;

//------------------------------------------------------------------------------

//---  Register CH8_WRITE_ADDR: DMA Channel 8 Write Address pointer\n This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
  static volatile uint32_t & DMA_CH8_WRITE_ADDR __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 516)) ;

//------------------------------------------------------------------------------

//---  Register CH8_TRANS_COUNT: DMA Channel 8 Transfer Count\n Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
  static volatile uint32_t & DMA_CH8_TRANS_COUNT __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 520)) ;

//------------------------------------------------------------------------------

//---  Register CH8_CTRL_TRIG: DMA Channel 8 Control and Status
  static volatile uint32_t & DMA_CH8_CTRL_TRIG __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 524)) ;

  // Field EN: DMA Channel Enable.\n When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
    const uint32_t DMA_CH8_CTRL_TRIG_EN = 1U << 0 ;

  // Field HIGH_PRIORITY: HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
    const uint32_t DMA_CH8_CTRL_TRIG_HIGH_PRIORITY = 1U << 1 ;

  // Field DATA_SIZE: Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
    inline uint32_t DMA_CH8_CTRL_TRIG_DATA_SIZE (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field INCR_READ: If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n Generally this should be disabled for peripheral-to-memory transfers.
    const uint32_t DMA_CH8_CTRL_TRIG_INCR_READ = 1U << 4 ;

  // Field INCR_WRITE: If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n Generally this should be disabled for memory-to-peripheral transfers.
    const uint32_t DMA_CH8_CTRL_TRIG_INCR_WRITE = 1U << 5 ;

  // Field RING_SIZE: Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
    inline uint32_t DMA_CH8_CTRL_TRIG_RING_SIZE (const uint32_t inValue) {return (inValue & 0xFU) << 6 ; }

  // Field RING_SEL: Select whether RING_SIZE applies to read or write addresses.\n If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
    const uint32_t DMA_CH8_CTRL_TRIG_RING_SEL = 1U << 10 ;

  // Field CHAIN_TO: When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.\n Reset value is equal to channel number (8).
    inline uint32_t DMA_CH8_CTRL_TRIG_CHAIN_TO (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field TREQ_SEL: Select a Transfer Request signal.\n The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system).\n 0x0 to 0x3a -> select DREQ n as TREQ
    inline uint32_t DMA_CH8_CTRL_TRIG_TREQ_SEL (const uint32_t inValue) {return (inValue & 0x3FU) << 15 ; }

  // Field IRQ_QUIET: In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
    const uint32_t DMA_CH8_CTRL_TRIG_IRQ_QUIET = 1U << 21 ;

  // Field BSWAP: Apply byte-swap transformation to DMA data.\n For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
    const uint32_t DMA_CH8_CTRL_TRIG_BSWAP = 1U << 22 ;

  // Field SNIFF_EN: If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n This allows checksum to be enabled or disabled on a per-control- block basis.
    const uint32_t DMA_CH8_CTRL_TRIG_SNIFF_EN = 1U << 23 ;

  // Field BUSY: This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.\n\n To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
    const uint32_t DMA_CH8_CTRL_TRIG_BUSY = 1U << 24 ;

  // Field WRITE_ERROR: If 1, the channel received a write bus error. Write one to clear.\n WRITE_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 5 transfers later)
    const uint32_t DMA_CH8_CTRL_TRIG_WRITE_ERROR = 1U << 29 ;

  // Field READ_ERROR: If 1, the channel received a read bus error. Write one to clear.\n READ_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 3 transfers later)
    const uint32_t DMA_CH8_CTRL_TRIG_READ_ERROR = 1U << 30 ;

  // Field AHB_ERROR: Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
    const uint32_t DMA_CH8_CTRL_TRIG_AHB_ERROR = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register CH8_AL1_CTRL: Alias for channel 8 CTRL register
  static volatile uint32_t const & DMA_CH8_AL1_CTRL __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 528)) ;

//------------------------------------------------------------------------------

//---  Register CH8_AL1_READ_ADDR: Alias for channel 8 READ_ADDR register
  static volatile uint32_t const & DMA_CH8_AL1_READ_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 532)) ;

//------------------------------------------------------------------------------

//---  Register CH8_AL1_WRITE_ADDR: Alias for channel 8 WRITE_ADDR register
  static volatile uint32_t const & DMA_CH8_AL1_WRITE_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 536)) ;

//------------------------------------------------------------------------------

//---  Register CH8_AL1_TRANS_COUNT_TRIG: Alias for channel 8 TRANS_COUNT register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
  static volatile uint32_t const & DMA_CH8_AL1_TRANS_COUNT_TRIG __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 540)) ;

//------------------------------------------------------------------------------

//---  Register CH8_AL2_CTRL: Alias for channel 8 CTRL register
  static volatile uint32_t const & DMA_CH8_AL2_CTRL __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 544)) ;

//------------------------------------------------------------------------------

//---  Register CH8_AL2_TRANS_COUNT: Alias for channel 8 TRANS_COUNT register
  static volatile uint32_t const & DMA_CH8_AL2_TRANS_COUNT __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 548)) ;

//------------------------------------------------------------------------------

//---  Register CH8_AL2_READ_ADDR: Alias for channel 8 READ_ADDR register
  static volatile uint32_t const & DMA_CH8_AL2_READ_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 552)) ;

//------------------------------------------------------------------------------

//---  Register CH8_AL2_WRITE_ADDR_TRIG: Alias for channel 8 WRITE_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
  static volatile uint32_t const & DMA_CH8_AL2_WRITE_ADDR_TRIG __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 556)) ;

//------------------------------------------------------------------------------

//---  Register CH8_AL3_CTRL: Alias for channel 8 CTRL register
  static volatile uint32_t const & DMA_CH8_AL3_CTRL __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 560)) ;

//------------------------------------------------------------------------------

//---  Register CH8_AL3_WRITE_ADDR: Alias for channel 8 WRITE_ADDR register
  static volatile uint32_t const & DMA_CH8_AL3_WRITE_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 564)) ;

//------------------------------------------------------------------------------

//---  Register CH8_AL3_TRANS_COUNT: Alias for channel 8 TRANS_COUNT register
  static volatile uint32_t const & DMA_CH8_AL3_TRANS_COUNT __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 568)) ;

//------------------------------------------------------------------------------

//---  Register CH8_AL3_READ_ADDR_TRIG: Alias for channel 8 READ_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
  static volatile uint32_t const & DMA_CH8_AL3_READ_ADDR_TRIG __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 572)) ;

//------------------------------------------------------------------------------

//---  Register CH9_READ_ADDR: DMA Channel 9 Read Address pointer\n This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
  static volatile uint32_t & DMA_CH9_READ_ADDR __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 576)) ;

//------------------------------------------------------------------------------

//---  Register CH9_WRITE_ADDR: DMA Channel 9 Write Address pointer\n This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
  static volatile uint32_t & DMA_CH9_WRITE_ADDR __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 580)) ;

//------------------------------------------------------------------------------

//---  Register CH9_TRANS_COUNT: DMA Channel 9 Transfer Count\n Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
  static volatile uint32_t & DMA_CH9_TRANS_COUNT __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 584)) ;

//------------------------------------------------------------------------------

//---  Register CH9_CTRL_TRIG: DMA Channel 9 Control and Status
  static volatile uint32_t & DMA_CH9_CTRL_TRIG __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 588)) ;

  // Field EN: DMA Channel Enable.\n When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
    const uint32_t DMA_CH9_CTRL_TRIG_EN = 1U << 0 ;

  // Field HIGH_PRIORITY: HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
    const uint32_t DMA_CH9_CTRL_TRIG_HIGH_PRIORITY = 1U << 1 ;

  // Field DATA_SIZE: Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
    inline uint32_t DMA_CH9_CTRL_TRIG_DATA_SIZE (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field INCR_READ: If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n Generally this should be disabled for peripheral-to-memory transfers.
    const uint32_t DMA_CH9_CTRL_TRIG_INCR_READ = 1U << 4 ;

  // Field INCR_WRITE: If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n Generally this should be disabled for memory-to-peripheral transfers.
    const uint32_t DMA_CH9_CTRL_TRIG_INCR_WRITE = 1U << 5 ;

  // Field RING_SIZE: Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
    inline uint32_t DMA_CH9_CTRL_TRIG_RING_SIZE (const uint32_t inValue) {return (inValue & 0xFU) << 6 ; }

  // Field RING_SEL: Select whether RING_SIZE applies to read or write addresses.\n If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
    const uint32_t DMA_CH9_CTRL_TRIG_RING_SEL = 1U << 10 ;

  // Field CHAIN_TO: When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.\n Reset value is equal to channel number (9).
    inline uint32_t DMA_CH9_CTRL_TRIG_CHAIN_TO (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field TREQ_SEL: Select a Transfer Request signal.\n The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system).\n 0x0 to 0x3a -> select DREQ n as TREQ
    inline uint32_t DMA_CH9_CTRL_TRIG_TREQ_SEL (const uint32_t inValue) {return (inValue & 0x3FU) << 15 ; }

  // Field IRQ_QUIET: In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
    const uint32_t DMA_CH9_CTRL_TRIG_IRQ_QUIET = 1U << 21 ;

  // Field BSWAP: Apply byte-swap transformation to DMA data.\n For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
    const uint32_t DMA_CH9_CTRL_TRIG_BSWAP = 1U << 22 ;

  // Field SNIFF_EN: If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n This allows checksum to be enabled or disabled on a per-control- block basis.
    const uint32_t DMA_CH9_CTRL_TRIG_SNIFF_EN = 1U << 23 ;

  // Field BUSY: This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.\n\n To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
    const uint32_t DMA_CH9_CTRL_TRIG_BUSY = 1U << 24 ;

  // Field WRITE_ERROR: If 1, the channel received a write bus error. Write one to clear.\n WRITE_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 5 transfers later)
    const uint32_t DMA_CH9_CTRL_TRIG_WRITE_ERROR = 1U << 29 ;

  // Field READ_ERROR: If 1, the channel received a read bus error. Write one to clear.\n READ_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 3 transfers later)
    const uint32_t DMA_CH9_CTRL_TRIG_READ_ERROR = 1U << 30 ;

  // Field AHB_ERROR: Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
    const uint32_t DMA_CH9_CTRL_TRIG_AHB_ERROR = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register CH9_AL1_CTRL: Alias for channel 9 CTRL register
  static volatile uint32_t const & DMA_CH9_AL1_CTRL __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 592)) ;

//------------------------------------------------------------------------------

//---  Register CH9_AL1_READ_ADDR: Alias for channel 9 READ_ADDR register
  static volatile uint32_t const & DMA_CH9_AL1_READ_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 596)) ;

//------------------------------------------------------------------------------

//---  Register CH9_AL1_WRITE_ADDR: Alias for channel 9 WRITE_ADDR register
  static volatile uint32_t const & DMA_CH9_AL1_WRITE_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 600)) ;

//------------------------------------------------------------------------------

//---  Register CH9_AL1_TRANS_COUNT_TRIG: Alias for channel 9 TRANS_COUNT register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
  static volatile uint32_t const & DMA_CH9_AL1_TRANS_COUNT_TRIG __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 604)) ;

//------------------------------------------------------------------------------

//---  Register CH9_AL2_CTRL: Alias for channel 9 CTRL register
  static volatile uint32_t const & DMA_CH9_AL2_CTRL __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 608)) ;

//------------------------------------------------------------------------------

//---  Register CH9_AL2_TRANS_COUNT: Alias for channel 9 TRANS_COUNT register
  static volatile uint32_t const & DMA_CH9_AL2_TRANS_COUNT __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 612)) ;

//------------------------------------------------------------------------------

//---  Register CH9_AL2_READ_ADDR: Alias for channel 9 READ_ADDR register
  static volatile uint32_t const & DMA_CH9_AL2_READ_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 616)) ;

//------------------------------------------------------------------------------

//---  Register CH9_AL2_WRITE_ADDR_TRIG: Alias for channel 9 WRITE_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
  static volatile uint32_t const & DMA_CH9_AL2_WRITE_ADDR_TRIG __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 620)) ;

//------------------------------------------------------------------------------

//---  Register CH9_AL3_CTRL: Alias for channel 9 CTRL register
  static volatile uint32_t const & DMA_CH9_AL3_CTRL __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 624)) ;

//------------------------------------------------------------------------------

//---  Register CH9_AL3_WRITE_ADDR: Alias for channel 9 WRITE_ADDR register
  static volatile uint32_t const & DMA_CH9_AL3_WRITE_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 628)) ;

//------------------------------------------------------------------------------

//---  Register CH9_AL3_TRANS_COUNT: Alias for channel 9 TRANS_COUNT register
  static volatile uint32_t const & DMA_CH9_AL3_TRANS_COUNT __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 632)) ;

//------------------------------------------------------------------------------

//---  Register CH9_AL3_READ_ADDR_TRIG: Alias for channel 9 READ_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
  static volatile uint32_t const & DMA_CH9_AL3_READ_ADDR_TRIG __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 636)) ;

//------------------------------------------------------------------------------

//---  Register CH10_READ_ADDR: DMA Channel 10 Read Address pointer\n This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
  static volatile uint32_t & DMA_CH10_READ_ADDR __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 640)) ;

//------------------------------------------------------------------------------

//---  Register CH10_WRITE_ADDR: DMA Channel 10 Write Address pointer\n This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
  static volatile uint32_t & DMA_CH10_WRITE_ADDR __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 644)) ;

//------------------------------------------------------------------------------

//---  Register CH10_TRANS_COUNT: DMA Channel 10 Transfer Count\n Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
  static volatile uint32_t & DMA_CH10_TRANS_COUNT __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 648)) ;

//------------------------------------------------------------------------------

//---  Register CH10_CTRL_TRIG: DMA Channel 10 Control and Status
  static volatile uint32_t & DMA_CH10_CTRL_TRIG __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 652)) ;

  // Field EN: DMA Channel Enable.\n When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
    const uint32_t DMA_CH10_CTRL_TRIG_EN = 1U << 0 ;

  // Field HIGH_PRIORITY: HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
    const uint32_t DMA_CH10_CTRL_TRIG_HIGH_PRIORITY = 1U << 1 ;

  // Field DATA_SIZE: Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
    inline uint32_t DMA_CH10_CTRL_TRIG_DATA_SIZE (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field INCR_READ: If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n Generally this should be disabled for peripheral-to-memory transfers.
    const uint32_t DMA_CH10_CTRL_TRIG_INCR_READ = 1U << 4 ;

  // Field INCR_WRITE: If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n Generally this should be disabled for memory-to-peripheral transfers.
    const uint32_t DMA_CH10_CTRL_TRIG_INCR_WRITE = 1U << 5 ;

  // Field RING_SIZE: Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
    inline uint32_t DMA_CH10_CTRL_TRIG_RING_SIZE (const uint32_t inValue) {return (inValue & 0xFU) << 6 ; }

  // Field RING_SEL: Select whether RING_SIZE applies to read or write addresses.\n If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
    const uint32_t DMA_CH10_CTRL_TRIG_RING_SEL = 1U << 10 ;

  // Field CHAIN_TO: When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.\n Reset value is equal to channel number (10).
    inline uint32_t DMA_CH10_CTRL_TRIG_CHAIN_TO (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field TREQ_SEL: Select a Transfer Request signal.\n The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system).\n 0x0 to 0x3a -> select DREQ n as TREQ
    inline uint32_t DMA_CH10_CTRL_TRIG_TREQ_SEL (const uint32_t inValue) {return (inValue & 0x3FU) << 15 ; }

  // Field IRQ_QUIET: In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
    const uint32_t DMA_CH10_CTRL_TRIG_IRQ_QUIET = 1U << 21 ;

  // Field BSWAP: Apply byte-swap transformation to DMA data.\n For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
    const uint32_t DMA_CH10_CTRL_TRIG_BSWAP = 1U << 22 ;

  // Field SNIFF_EN: If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n This allows checksum to be enabled or disabled on a per-control- block basis.
    const uint32_t DMA_CH10_CTRL_TRIG_SNIFF_EN = 1U << 23 ;

  // Field BUSY: This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.\n\n To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
    const uint32_t DMA_CH10_CTRL_TRIG_BUSY = 1U << 24 ;

  // Field WRITE_ERROR: If 1, the channel received a write bus error. Write one to clear.\n WRITE_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 5 transfers later)
    const uint32_t DMA_CH10_CTRL_TRIG_WRITE_ERROR = 1U << 29 ;

  // Field READ_ERROR: If 1, the channel received a read bus error. Write one to clear.\n READ_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 3 transfers later)
    const uint32_t DMA_CH10_CTRL_TRIG_READ_ERROR = 1U << 30 ;

  // Field AHB_ERROR: Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
    const uint32_t DMA_CH10_CTRL_TRIG_AHB_ERROR = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register CH10_AL1_CTRL: Alias for channel 10 CTRL register
  static volatile uint32_t const & DMA_CH10_AL1_CTRL __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 656)) ;

//------------------------------------------------------------------------------

//---  Register CH10_AL1_READ_ADDR: Alias for channel 10 READ_ADDR register
  static volatile uint32_t const & DMA_CH10_AL1_READ_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 660)) ;

//------------------------------------------------------------------------------

//---  Register CH10_AL1_WRITE_ADDR: Alias for channel 10 WRITE_ADDR register
  static volatile uint32_t const & DMA_CH10_AL1_WRITE_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 664)) ;

//------------------------------------------------------------------------------

//---  Register CH10_AL1_TRANS_COUNT_TRIG: Alias for channel 10 TRANS_COUNT register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
  static volatile uint32_t const & DMA_CH10_AL1_TRANS_COUNT_TRIG __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 668)) ;

//------------------------------------------------------------------------------

//---  Register CH10_AL2_CTRL: Alias for channel 10 CTRL register
  static volatile uint32_t const & DMA_CH10_AL2_CTRL __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 672)) ;

//------------------------------------------------------------------------------

//---  Register CH10_AL2_TRANS_COUNT: Alias for channel 10 TRANS_COUNT register
  static volatile uint32_t const & DMA_CH10_AL2_TRANS_COUNT __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 676)) ;

//------------------------------------------------------------------------------

//---  Register CH10_AL2_READ_ADDR: Alias for channel 10 READ_ADDR register
  static volatile uint32_t const & DMA_CH10_AL2_READ_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 680)) ;

//------------------------------------------------------------------------------

//---  Register CH10_AL2_WRITE_ADDR_TRIG: Alias for channel 10 WRITE_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
  static volatile uint32_t const & DMA_CH10_AL2_WRITE_ADDR_TRIG __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 684)) ;

//------------------------------------------------------------------------------

//---  Register CH10_AL3_CTRL: Alias for channel 10 CTRL register
  static volatile uint32_t const & DMA_CH10_AL3_CTRL __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 688)) ;

//------------------------------------------------------------------------------

//---  Register CH10_AL3_WRITE_ADDR: Alias for channel 10 WRITE_ADDR register
  static volatile uint32_t const & DMA_CH10_AL3_WRITE_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 692)) ;

//------------------------------------------------------------------------------

//---  Register CH10_AL3_TRANS_COUNT: Alias for channel 10 TRANS_COUNT register
  static volatile uint32_t const & DMA_CH10_AL3_TRANS_COUNT __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 696)) ;

//------------------------------------------------------------------------------

//---  Register CH10_AL3_READ_ADDR_TRIG: Alias for channel 10 READ_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
  static volatile uint32_t const & DMA_CH10_AL3_READ_ADDR_TRIG __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 700)) ;

//------------------------------------------------------------------------------

//---  Register CH11_READ_ADDR: DMA Channel 11 Read Address pointer\n This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
  static volatile uint32_t & DMA_CH11_READ_ADDR __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 704)) ;

//------------------------------------------------------------------------------

//---  Register CH11_WRITE_ADDR: DMA Channel 11 Write Address pointer\n This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
  static volatile uint32_t & DMA_CH11_WRITE_ADDR __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 708)) ;

//------------------------------------------------------------------------------

//---  Register CH11_TRANS_COUNT: DMA Channel 11 Transfer Count\n Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
  static volatile uint32_t & DMA_CH11_TRANS_COUNT __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 712)) ;

//------------------------------------------------------------------------------

//---  Register CH11_CTRL_TRIG: DMA Channel 11 Control and Status
  static volatile uint32_t & DMA_CH11_CTRL_TRIG __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 716)) ;

  // Field EN: DMA Channel Enable.\n When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
    const uint32_t DMA_CH11_CTRL_TRIG_EN = 1U << 0 ;

  // Field HIGH_PRIORITY: HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
    const uint32_t DMA_CH11_CTRL_TRIG_HIGH_PRIORITY = 1U << 1 ;

  // Field DATA_SIZE: Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
    inline uint32_t DMA_CH11_CTRL_TRIG_DATA_SIZE (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field INCR_READ: If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n Generally this should be disabled for peripheral-to-memory transfers.
    const uint32_t DMA_CH11_CTRL_TRIG_INCR_READ = 1U << 4 ;

  // Field INCR_WRITE: If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n Generally this should be disabled for memory-to-peripheral transfers.
    const uint32_t DMA_CH11_CTRL_TRIG_INCR_WRITE = 1U << 5 ;

  // Field RING_SIZE: Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
    inline uint32_t DMA_CH11_CTRL_TRIG_RING_SIZE (const uint32_t inValue) {return (inValue & 0xFU) << 6 ; }

  // Field RING_SEL: Select whether RING_SIZE applies to read or write addresses.\n If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
    const uint32_t DMA_CH11_CTRL_TRIG_RING_SEL = 1U << 10 ;

  // Field CHAIN_TO: When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.\n Reset value is equal to channel number (11).
    inline uint32_t DMA_CH11_CTRL_TRIG_CHAIN_TO (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field TREQ_SEL: Select a Transfer Request signal.\n The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system).\n 0x0 to 0x3a -> select DREQ n as TREQ
    inline uint32_t DMA_CH11_CTRL_TRIG_TREQ_SEL (const uint32_t inValue) {return (inValue & 0x3FU) << 15 ; }

  // Field IRQ_QUIET: In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
    const uint32_t DMA_CH11_CTRL_TRIG_IRQ_QUIET = 1U << 21 ;

  // Field BSWAP: Apply byte-swap transformation to DMA data.\n For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
    const uint32_t DMA_CH11_CTRL_TRIG_BSWAP = 1U << 22 ;

  // Field SNIFF_EN: If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n This allows checksum to be enabled or disabled on a per-control- block basis.
    const uint32_t DMA_CH11_CTRL_TRIG_SNIFF_EN = 1U << 23 ;

  // Field BUSY: This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.\n\n To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
    const uint32_t DMA_CH11_CTRL_TRIG_BUSY = 1U << 24 ;

  // Field WRITE_ERROR: If 1, the channel received a write bus error. Write one to clear.\n WRITE_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 5 transfers later)
    const uint32_t DMA_CH11_CTRL_TRIG_WRITE_ERROR = 1U << 29 ;

  // Field READ_ERROR: If 1, the channel received a read bus error. Write one to clear.\n READ_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 3 transfers later)
    const uint32_t DMA_CH11_CTRL_TRIG_READ_ERROR = 1U << 30 ;

  // Field AHB_ERROR: Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
    const uint32_t DMA_CH11_CTRL_TRIG_AHB_ERROR = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register CH11_AL1_CTRL: Alias for channel 11 CTRL register
  static volatile uint32_t const & DMA_CH11_AL1_CTRL __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 720)) ;

//------------------------------------------------------------------------------

//---  Register CH11_AL1_READ_ADDR: Alias for channel 11 READ_ADDR register
  static volatile uint32_t const & DMA_CH11_AL1_READ_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 724)) ;

//------------------------------------------------------------------------------

//---  Register CH11_AL1_WRITE_ADDR: Alias for channel 11 WRITE_ADDR register
  static volatile uint32_t const & DMA_CH11_AL1_WRITE_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 728)) ;

//------------------------------------------------------------------------------

//---  Register CH11_AL1_TRANS_COUNT_TRIG: Alias for channel 11 TRANS_COUNT register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
  static volatile uint32_t const & DMA_CH11_AL1_TRANS_COUNT_TRIG __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 732)) ;

//------------------------------------------------------------------------------

//---  Register CH11_AL2_CTRL: Alias for channel 11 CTRL register
  static volatile uint32_t const & DMA_CH11_AL2_CTRL __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 736)) ;

//------------------------------------------------------------------------------

//---  Register CH11_AL2_TRANS_COUNT: Alias for channel 11 TRANS_COUNT register
  static volatile uint32_t const & DMA_CH11_AL2_TRANS_COUNT __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 740)) ;

//------------------------------------------------------------------------------

//---  Register CH11_AL2_READ_ADDR: Alias for channel 11 READ_ADDR register
  static volatile uint32_t const & DMA_CH11_AL2_READ_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 744)) ;

//------------------------------------------------------------------------------

//---  Register CH11_AL2_WRITE_ADDR_TRIG: Alias for channel 11 WRITE_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
  static volatile uint32_t const & DMA_CH11_AL2_WRITE_ADDR_TRIG __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 748)) ;

//------------------------------------------------------------------------------

//---  Register CH11_AL3_CTRL: Alias for channel 11 CTRL register
  static volatile uint32_t const & DMA_CH11_AL3_CTRL __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 752)) ;

//------------------------------------------------------------------------------

//---  Register CH11_AL3_WRITE_ADDR: Alias for channel 11 WRITE_ADDR register
  static volatile uint32_t const & DMA_CH11_AL3_WRITE_ADDR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 756)) ;

//------------------------------------------------------------------------------

//---  Register CH11_AL3_TRANS_COUNT: Alias for channel 11 TRANS_COUNT register
  static volatile uint32_t const & DMA_CH11_AL3_TRANS_COUNT __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 760)) ;

//------------------------------------------------------------------------------

//---  Register CH11_AL3_READ_ADDR_TRIG: Alias for channel 11 READ_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
  static volatile uint32_t const & DMA_CH11_AL3_READ_ADDR_TRIG __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 764)) ;

//------------------------------------------------------------------------------

//---  Register INTR: Interrupt Status (raw)
  static volatile uint32_t & DMA_INTR __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 1024)) ;

  // Field INTR: Raw interrupt status for DMA Channels 0..15. Bit n corresponds to channel n. Ignores any masking or forcing. Channel interrupts can be cleared by writing a bit mask to INTR, INTS0 or INTS1.\n\n Channel interrupts can be routed to either of two system-level IRQs based on INTE0 and INTE1.\n\n This can be used vector different channel interrupts to different ISRs: this might be done to allow NVIC IRQ preemption for more time-critical channels, or to spread IRQ load across different cores.\n\n It is also valid to ignore this behaviour and just use INTE0/INTS0/IRQ 0.
    inline uint32_t DMA_INTR_INTR (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INTE0: Interrupt Enables for IRQ 0
  static volatile uint32_t & DMA_INTE0 __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 1028)) ;

  // Field INTE0: Set bit n to pass interrupts from channel n to DMA IRQ 0.
    inline uint32_t DMA_INTE0_INTE0 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INTF0: Force Interrupts
  static volatile uint32_t & DMA_INTF0 __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 1032)) ;

  // Field INTF0: Write 1s to force the corresponding bits in INTE0. The interrupt remains asserted until INTF0 is cleared.
    inline uint32_t DMA_INTF0_INTF0 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INTS0: Interrupt Status for IRQ 0
  static volatile uint32_t & DMA_INTS0 __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 1036)) ;

  // Field INTS0: Indicates active channel interrupt requests which are currently causing IRQ 0 to be asserted.\n Channel interrupts can be cleared by writing a bit mask here.
    inline uint32_t DMA_INTS0_INTS0 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INTE1: Interrupt Enables for IRQ 1
  static volatile uint32_t & DMA_INTE1 __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 1044)) ;

  // Field INTE1: Set bit n to pass interrupts from channel n to DMA IRQ 1.
    inline uint32_t DMA_INTE1_INTE1 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INTF1: Force Interrupts for IRQ 1
  static volatile uint32_t & DMA_INTF1 __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 1048)) ;

  // Field INTF1: Write 1s to force the corresponding bits in INTE0. The interrupt remains asserted until INTF0 is cleared.
    inline uint32_t DMA_INTF1_INTF1 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INTS1: Interrupt Status (masked) for IRQ 1
  static volatile uint32_t & DMA_INTS1 __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 1052)) ;

  // Field INTS1: Indicates active channel interrupt requests which are currently causing IRQ 1 to be asserted.\n Channel interrupts can be cleared by writing a bit mask here.
    inline uint32_t DMA_INTS1_INTS1 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register TIMER0: Pacing (X/Y) Fractional Timer\n The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less.
  static volatile uint32_t & DMA_TIMER0 __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 1056)) ;

  // Field Y: Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer.
    inline uint32_t DMA_TIMER0_Y (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field X: Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer.
    inline uint32_t DMA_TIMER0_X (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register TIMER1: Pacing (X/Y) Fractional Timer\n The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less.
  static volatile uint32_t & DMA_TIMER1 __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 1060)) ;

  // Field Y: Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer.
    inline uint32_t DMA_TIMER1_Y (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field X: Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer.
    inline uint32_t DMA_TIMER1_X (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register MULTI_CHAN_TRIGGER: Trigger one or more channels simultaneously
  static volatile uint32_t & DMA_MULTI_CHAN_TRIGGER __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 1072)) ;

  // Field MULTI_CHAN_TRIGGER: Each bit in this register corresponds to a DMA channel. Writing a 1 to the relevant bit is the same as writing to that channel's trigger register; the channel will start if it is currently enabled and not already busy.
    inline uint32_t DMA_MULTI_CHAN_TRIGGER_MULTI_CHAN_TRIGGER (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SNIFF_CTRL: Sniffer Control
  static volatile uint32_t & DMA_SNIFF_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 1076)) ;

  // Field EN: Enable sniffer
    const uint32_t DMA_SNIFF_CTRL_EN = 1U << 0 ;

  // Field DMACH: DMA channel for Sniffer to observe
    inline uint32_t DMA_SNIFF_CTRL_DMACH (const uint32_t inValue) {return (inValue & 0xFU) << 1 ; }

  // Field CALC: 
    inline uint32_t DMA_SNIFF_CTRL_CALC (const uint32_t inValue) {return (inValue & 0xFU) << 5 ; }

  // Field BSWAP: Locally perform a byte reverse on the sniffed data, before feeding into checksum.\n\n Note that the sniff hardware is downstream of the DMA channel byteswap performed in the read master: if channel CTRL_BSWAP and SNIFF_CTRL_BSWAP are both enabled, their effects cancel from the sniffer's point of view.
    const uint32_t DMA_SNIFF_CTRL_BSWAP = 1U << 9 ;

  // Field OUT_REV: If set, the result appears bit-reversed when read. This does not affect the way the checksum is calculated; the result is transformed on-the-fly between the result register and the bus.
    const uint32_t DMA_SNIFF_CTRL_OUT_REV = 1U << 10 ;

  // Field OUT_INV: If set, the result appears inverted (bitwise complement) when read. This does not affect the way the checksum is calculated; the result is transformed on-the-fly between the result register and the bus.
    const uint32_t DMA_SNIFF_CTRL_OUT_INV = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register SNIFF_DATA: Data accumulator for sniff hardware\n Write an initial seed value here before starting a DMA transfer on the channel indicated by SNIFF_CTRL_DMACH. The hardware will update this register each time it observes a read from the indicated channel. Once the channel completes, the final result can be read from this register.
  static volatile uint32_t & DMA_SNIFF_DATA __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 1080)) ;

//------------------------------------------------------------------------------

//---  Register FIFO_LEVELS: Debug RAF, WAF, TDF levels
  static volatile uint32_t & DMA_FIFO_LEVELS __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 1088)) ;

  // Field TDF_LVL: Current Transfer-Data-FIFO fill level
    inline uint32_t DMA_FIFO_LEVELS_TDF_LVL (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field WAF_LVL: Current Write-Address-FIFO fill level
    inline uint32_t DMA_FIFO_LEVELS_WAF_LVL (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field RAF_LVL: Current Read-Address-FIFO fill level
    inline uint32_t DMA_FIFO_LEVELS_RAF_LVL (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register CHAN_ABORT: Abort an in-progress transfer sequence on one or more channels
  static volatile uint32_t & DMA_CHAN_ABORT __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 1092)) ;

  // Field CHAN_ABORT: Each bit corresponds to a channel. Writing a 1 aborts whatever transfer sequence is in progress on that channel. The bit will remain high until any in-flight transfers have been flushed through the address and data FIFOs.\n\n After writing, this register must be polled until it returns all-zero. Until this point, it is unsafe to restart the channel.
    inline uint32_t DMA_CHAN_ABORT_CHAN_ABORT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register N_CHANNELS: The number of channels this DMA instance is equipped with. This DMA supports up to 16 hardware channels, but can be configured with as few as one, to minimise silicon area.
  static volatile uint32_t & DMA_N_CHANNELS __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 1096)) ;

  // Field N_CHANNELS: 
    inline uint32_t DMA_N_CHANNELS_N_CHANNELS (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CH0_DBG_CTDREQ: Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
  static volatile uint32_t & DMA_CH0_DBG_CTDREQ __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 2048)) ;

  // Field CH0_DBG_CTDREQ: 
    inline uint32_t DMA_CH0_DBG_CTDREQ_CH0_DBG_CTDREQ (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CH0_DBG_TCR: Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
  static volatile uint32_t const & DMA_CH0_DBG_TCR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 2052)) ;

//------------------------------------------------------------------------------

//---  Register CH1_DBG_CTDREQ: Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
  static volatile uint32_t & DMA_CH1_DBG_CTDREQ __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 2112)) ;

  // Field CH1_DBG_CTDREQ: 
    inline uint32_t DMA_CH1_DBG_CTDREQ_CH1_DBG_CTDREQ (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CH1_DBG_TCR: Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
  static volatile uint32_t const & DMA_CH1_DBG_TCR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 2116)) ;

//------------------------------------------------------------------------------

//---  Register CH2_DBG_CTDREQ: Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
  static volatile uint32_t & DMA_CH2_DBG_CTDREQ __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 2176)) ;

  // Field CH2_DBG_CTDREQ: 
    inline uint32_t DMA_CH2_DBG_CTDREQ_CH2_DBG_CTDREQ (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CH2_DBG_TCR: Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
  static volatile uint32_t const & DMA_CH2_DBG_TCR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 2180)) ;

//------------------------------------------------------------------------------

//---  Register CH3_DBG_CTDREQ: Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
  static volatile uint32_t & DMA_CH3_DBG_CTDREQ __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 2240)) ;

  // Field CH3_DBG_CTDREQ: 
    inline uint32_t DMA_CH3_DBG_CTDREQ_CH3_DBG_CTDREQ (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CH3_DBG_TCR: Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
  static volatile uint32_t const & DMA_CH3_DBG_TCR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 2244)) ;

//------------------------------------------------------------------------------

//---  Register CH4_DBG_CTDREQ: Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
  static volatile uint32_t & DMA_CH4_DBG_CTDREQ __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 2304)) ;

  // Field CH4_DBG_CTDREQ: 
    inline uint32_t DMA_CH4_DBG_CTDREQ_CH4_DBG_CTDREQ (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CH4_DBG_TCR: Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
  static volatile uint32_t const & DMA_CH4_DBG_TCR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 2308)) ;

//------------------------------------------------------------------------------

//---  Register CH5_DBG_CTDREQ: Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
  static volatile uint32_t & DMA_CH5_DBG_CTDREQ __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 2368)) ;

  // Field CH5_DBG_CTDREQ: 
    inline uint32_t DMA_CH5_DBG_CTDREQ_CH5_DBG_CTDREQ (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CH5_DBG_TCR: Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
  static volatile uint32_t const & DMA_CH5_DBG_TCR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 2372)) ;

//------------------------------------------------------------------------------

//---  Register CH6_DBG_CTDREQ: Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
  static volatile uint32_t & DMA_CH6_DBG_CTDREQ __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 2432)) ;

  // Field CH6_DBG_CTDREQ: 
    inline uint32_t DMA_CH6_DBG_CTDREQ_CH6_DBG_CTDREQ (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CH6_DBG_TCR: Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
  static volatile uint32_t const & DMA_CH6_DBG_TCR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 2436)) ;

//------------------------------------------------------------------------------

//---  Register CH7_DBG_CTDREQ: Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
  static volatile uint32_t & DMA_CH7_DBG_CTDREQ __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 2496)) ;

  // Field CH7_DBG_CTDREQ: 
    inline uint32_t DMA_CH7_DBG_CTDREQ_CH7_DBG_CTDREQ (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CH7_DBG_TCR: Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
  static volatile uint32_t const & DMA_CH7_DBG_TCR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 2500)) ;

//------------------------------------------------------------------------------

//---  Register CH8_DBG_CTDREQ: Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
  static volatile uint32_t & DMA_CH8_DBG_CTDREQ __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 2560)) ;

  // Field CH8_DBG_CTDREQ: 
    inline uint32_t DMA_CH8_DBG_CTDREQ_CH8_DBG_CTDREQ (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CH8_DBG_TCR: Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
  static volatile uint32_t const & DMA_CH8_DBG_TCR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 2564)) ;

//------------------------------------------------------------------------------

//---  Register CH9_DBG_CTDREQ: Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
  static volatile uint32_t & DMA_CH9_DBG_CTDREQ __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 2624)) ;

  // Field CH9_DBG_CTDREQ: 
    inline uint32_t DMA_CH9_DBG_CTDREQ_CH9_DBG_CTDREQ (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CH9_DBG_TCR: Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
  static volatile uint32_t const & DMA_CH9_DBG_TCR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 2628)) ;

//------------------------------------------------------------------------------

//---  Register CH10_DBG_CTDREQ: Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
  static volatile uint32_t & DMA_CH10_DBG_CTDREQ __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 2688)) ;

  // Field CH10_DBG_CTDREQ: 
    inline uint32_t DMA_CH10_DBG_CTDREQ_CH10_DBG_CTDREQ (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CH10_DBG_TCR: Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
  static volatile uint32_t const & DMA_CH10_DBG_TCR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 2692)) ;

//------------------------------------------------------------------------------

//---  Register CH11_DBG_CTDREQ: Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
  static volatile uint32_t & DMA_CH11_DBG_CTDREQ __attribute__((unused)) = * ((volatile uint32_t *) (0x50000000 + 2752)) ;

  // Field CH11_DBG_CTDREQ: 
    inline uint32_t DMA_CH11_DBG_CTDREQ_CH11_DBG_CTDREQ (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CH11_DBG_TCR: Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
  static volatile uint32_t const & DMA_CH11_DBG_TCR __attribute__((unused)) = * ((const volatile uint32_t *) (0x50000000 + 2756)) ;

//------------------------------------------------------------------------------
// Peripheral I2C0: DW_apb_i2c address block
//------------------------------------------------------------------------------

//---  Register IC_CON: I2C Control Register. This register can be written only when the DW_apb_i2c is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n Read/Write Access: - bit 10 is read only. - bit 11 is read only - bit 16 is read only - bit 17 is read only - bits 18 and 19 are read only.
  static volatile uint32_t & I2C0_IC_CON __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 0)) ;

  // Field MASTER_MODE: This bit controls whether the DW_apb_i2c master is enabled.\n\n NOTE: Software should ensure that if this bit is written with '1' then bit 6 should also be written with a '1'.
    const uint32_t I2C0_IC_CON_MASTER_MODE = 1U << 0 ;

  // Field SPEED: These bits control at which speed the DW_apb_i2c operates; its setting is relevant only if one is operating the DW_apb_i2c in master mode. Hardware protects against illegal values being programmed by software. These bits must be programmed appropriately for slave mode also, as it is used to capture correct value of spike filter as per the speed mode.\n\n This register should be programmed only with a value in the range of 1 to IC_MAX_SPEED_MODE; otherwise, hardware updates this register with the value of IC_MAX_SPEED_MODE.\n\n 1: standard mode (100 kbit/s)\n\n 2: fast mode (<=400 kbit/s) or fast mode plus (<=1000Kbit/s)\n\n 3: high speed mode (3.4 Mbit/s)\n\n Note: This field is not applicable when IC_ULTRA_FAST_MODE=1
    inline uint32_t I2C0_IC_CON_SPEED (const uint32_t inValue) {return (inValue & 0x3U) << 1 ; }

  // Field IC_10BITADDR_SLAVE: When acting as a slave, this bit controls whether the DW_apb_i2c responds to 7- or 10-bit addresses. - 0: 7-bit addressing. The DW_apb_i2c ignores transactions that involve 10-bit addressing; for 7-bit addressing, only the lower 7 bits of the IC_SAR register are compared. - 1: 10-bit addressing. The DW_apb_i2c responds to only 10-bit addressing transfers that match the full 10 bits of the IC_SAR register.
    const uint32_t I2C0_IC_CON_IC_10BITADDR_SLAVE = 1U << 3 ;

  // Field IC_10BITADDR_MASTER: Controls whether the DW_apb_i2c starts its transfers in 7- or 10-bit addressing mode when acting as a master. - 0: 7-bit addressing - 1: 10-bit addressing
    const uint32_t I2C0_IC_CON_IC_10BITADDR_MASTER = 1U << 4 ;

  // Field IC_RESTART_EN: Determines whether RESTART conditions may be sent when acting as a master. Some older slaves do not support handling RESTART conditions; however, RESTART conditions are used in several DW_apb_i2c operations. When RESTART is disabled, the master is prohibited from performing the following functions: - Sending a START BYTE - Performing any high-speed mode operation - High-speed mode operation - Performing direction changes in combined format mode - Performing a read operation with a 10-bit address By replacing RESTART condition followed by a STOP and a subsequent START condition, split operations are broken down into multiple DW_apb_i2c transfers. If the above operations are performed, it will result in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register.\n\n Reset value: ENABLED
    const uint32_t I2C0_IC_CON_IC_RESTART_EN = 1U << 5 ;

  // Field IC_SLAVE_DISABLE: This bit controls whether I2C has its slave disabled, which means once the presetn signal is applied, then this bit is set and the slave is disabled.\n\n If this bit is set (slave is disabled), DW_apb_i2c functions only as a master and does not perform any action that requires a slave.\n\n NOTE: Software should ensure that if this bit is written with 0, then bit 0 should also be written with a 0.
    const uint32_t I2C0_IC_CON_IC_SLAVE_DISABLE = 1U << 6 ;

  // Field STOP_DET_IFADDRESSED: In slave mode: - 1'b1: issues the STOP_DET interrupt only when it is addressed. - 1'b0: issues the STOP_DET irrespective of whether it's addressed or not. Reset value: 0x0\n\n NOTE: During a general call address, this slave does not issue the STOP_DET interrupt if STOP_DET_IF_ADDRESSED = 1'b1, even if the slave responds to the general call address by generating ACK. The STOP_DET interrupt is generated only when the transmitted address matches the slave address (SAR).
    const uint32_t I2C0_IC_CON_STOP_DET_IFADDRESSED = 1U << 7 ;

  // Field TX_EMPTY_CTRL: This bit controls the generation of the TX_EMPTY interrupt, as described in the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0.
    const uint32_t I2C0_IC_CON_TX_EMPTY_CTRL = 1U << 8 ;

  // Field RX_FIFO_FULL_HLD_CTRL: This bit controls whether DW_apb_i2c should hold the bus when the Rx FIFO is physically full to its RX_BUFFER_DEPTH, as described in the IC_RX_FULL_HLD_BUS_EN parameter.\n\n Reset value: 0x0.
    const uint32_t I2C0_IC_CON_RX_FIFO_FULL_HLD_CTRL = 1U << 9 ;

  // Field STOP_DET_IF_MASTER_ACTIVE: Master issues the STOP_DET interrupt irrespective of whether master is active or not
    const uint32_t I2C0_IC_CON_STOP_DET_IF_MASTER_ACTIVE = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register IC_TAR: I2C Target Address Register\n\n This register is 12 bits wide, and bits 31:12 are reserved. This register can be written to only when IC_ENABLE[0] is set to 0.\n\n Note: If the software or application is aware that the DW_apb_i2c is not using the TAR address for the pending commands in the Tx FIFO, then it is possible to update the TAR address even while the Tx FIFO has entries (IC_STATUS[2]= 0). - It is not necessary to perform any write to this register if DW_apb_i2c is enabled as an I2C slave only.
  static volatile uint32_t & I2C0_IC_TAR __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 4)) ;

  // Field IC_TAR: This is the target address for any master transaction. When transmitting a General Call, these bits are ignored. To generate a START BYTE, the CPU needs to write only once into these bits.\n\n If the IC_TAR and IC_SAR are the same, loopback exists but the FIFOs are shared between master and slave, so full loopback is not feasible. Only one direction loopback mode is supported (simplex), not duplex. A master cannot transmit to itself; it can transmit to only a slave.
    inline uint32_t I2C0_IC_TAR_IC_TAR (const uint32_t inValue) {return (inValue & 0x3FFU) << 0 ; }

  // Field GC_OR_START: If bit 11 (SPECIAL) is set to 1 and bit 13(Device-ID) is set to 0, then this bit indicates whether a General Call or START byte command is to be performed by the DW_apb_i2c. - 0: General Call Address - after issuing a General Call, only writes may be performed. Attempting to issue a read command results in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register. The DW_apb_i2c remains in General Call mode until the SPECIAL bit value (bit 11) is cleared. - 1: START BYTE Reset value: 0x0
    const uint32_t I2C0_IC_TAR_GC_OR_START = 1U << 10 ;

  // Field SPECIAL: This bit indicates whether software performs a Device-ID or General Call or START BYTE command. - 0: ignore bit 10 GC_OR_START and use IC_TAR normally - 1: perform special I2C command as specified in Device_ID or GC_OR_START bit Reset value: 0x0
    const uint32_t I2C0_IC_TAR_SPECIAL = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register IC_SAR: I2C Slave Address Register
  static volatile uint32_t & I2C0_IC_SAR __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 8)) ;

  // Field IC_SAR: The IC_SAR holds the slave address when the I2C is operating as a slave. For 7-bit addressing, only IC_SAR[6:0] is used.\n\n This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n Note: The default values cannot be any of the reserved address locations: that is, 0x00 to 0x07, or 0x78 to 0x7f. The correct operation of the device is not guaranteed if you program the IC_SAR or IC_TAR to a reserved value. Refer to <<table_I2C_firstbyte_bit_defs>> for a complete list of these reserved values.
    inline uint32_t I2C0_IC_SAR_IC_SAR (const uint32_t inValue) {return (inValue & 0x3FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IC_DATA_CMD: I2C Rx/Tx Data Buffer and Command Register; this is the register the CPU writes to when filling the TX FIFO and the CPU reads from when retrieving bytes from RX FIFO.\n\n The size of the register changes as follows:\n\n Write: - 11 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=1 - 9 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=0 Read: - 12 bits when IC_FIRST_DATA_BYTE_STATUS = 1 - 8 bits when IC_FIRST_DATA_BYTE_STATUS = 0 Note: In order for the DW_apb_i2c to continue acknowledging reads, a read command should be written for every byte that is to be received; otherwise the DW_apb_i2c will stop acknowledging.
  static volatile uint32_t & I2C0_IC_DATA_CMD __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 16)) ;

  // Field DAT: This register contains the data to be transmitted or received on the I2C bus. If you are writing to this register and want to perform a read, bits 7:0 (DAT) are ignored by the DW_apb_i2c. However, when you read this register, these bits return the value of data received on the DW_apb_i2c interface.\n\n Reset value: 0x0
    inline uint32_t I2C0_IC_DATA_CMD_DAT (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field CMD: This bit controls whether a read or a write is performed. This bit does not control the direction when the DW_apb_i2con acts as a slave. It controls only the direction when it acts as a master.\n\n When a command is entered in the TX FIFO, this bit distinguishes the write and read commands. In slave-receiver mode, this bit is a 'don't care' because writes to this register are not required. In slave-transmitter mode, a '0' indicates that the data in IC_DATA_CMD is to be transmitted.\n\n When programming this bit, you should remember the following: attempting to perform a read operation after a General Call command has been sent results in a TX_ABRT interrupt (bit 6 of the IC_RAW_INTR_STAT register), unless bit 11 (SPECIAL) in the IC_TAR register has been cleared. If a '1' is written to this bit after receiving a RD_REQ interrupt, then a TX_ABRT interrupt occurs.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_DATA_CMD_CMD = 1U << 8 ;

  // Field STOP: This bit controls whether a STOP is issued after the byte is sent or received.\n\n - 1 - STOP is issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master immediately tries to start a new transfer by issuing a START and arbitrating for the bus. - 0 - STOP is not issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master continues the current transfer by sending/receiving data bytes according to the value of the CMD bit. If the Tx FIFO is empty, the master holds the SCL line low and stalls the bus until a new command is available in the Tx FIFO. Reset value: 0x0
    const uint32_t I2C0_IC_DATA_CMD_STOP = 1U << 9 ;

  // Field RESTART: This bit controls whether a RESTART is issued before the byte is sent or received.\n\n 1 - If IC_RESTART_EN is 1, a RESTART is issued before the data is sent/received (according to the value of CMD), regardless of whether or not the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.\n\n 0 - If IC_RESTART_EN is 1, a RESTART is issued only if the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_DATA_CMD_RESTART = 1U << 10 ;

  // Field FIRST_DATA_BYTE: Indicates the first data byte received after the address phase for receive transfer in Master receiver or Slave receiver mode.\n\n Reset value : 0x0\n\n NOTE: In case of APB_DATA_WIDTH=8,\n\n 1. The user has to perform two APB Reads to IC_DATA_CMD in order to get status on 11 bit.\n\n 2. In order to read the 11 bit, the user has to perform the first data byte read [7:0] (offset 0x10) and then perform the second read [15:8] (offset 0x11) in order to know the status of 11 bit (whether the data received in previous read is a first data byte or not).\n\n 3. The 11th bit is an optional read field, user can ignore 2nd byte read [15:8] (offset 0x11) if not interested in FIRST_DATA_BYTE status.
    const uint32_t I2C0_IC_DATA_CMD_FIRST_DATA_BYTE = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register IC_SS_SCL_HCNT: Standard Speed I2C Clock SCL High Count Register
  static volatile uint32_t & I2C0_IC_SS_SCL_HCNT __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 20)) ;

  // Field IC_SS_SCL_HCNT: This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for standard speed. For more information, refer to 'IC_CLK Frequency Configuration'.\n\n This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. For designs with APB_DATA_WIDTH = 8, the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed.\n\n NOTE: This register must not be programmed to a value higher than 65525, because DW_apb_i2c uses a 16-bit counter to flag an I2C bus idle condition when this counter reaches a value of IC_SS_SCL_HCNT + 10.
    inline uint32_t I2C0_IC_SS_SCL_HCNT_IC_SS_SCL_HCNT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IC_SS_SCL_LCNT: Standard Speed I2C Clock SCL Low Count Register
  static volatile uint32_t & I2C0_IC_SS_SCL_LCNT __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 24)) ;

  // Field IC_SS_SCL_LCNT: This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for standard speed. For more information, refer to 'IC_CLK Frequency Configuration'\n\n This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n The minimum valid value is 8; hardware prevents values less than this being written, and if attempted, results in 8 being set. For designs with APB_DATA_WIDTH = 8, the order of programming is important to ensure the correct operation of DW_apb_i2c. The lower byte must be programmed first, and then the upper byte is programmed.
    inline uint32_t I2C0_IC_SS_SCL_LCNT_IC_SS_SCL_LCNT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IC_FS_SCL_HCNT: Fast Mode or Fast Mode Plus I2C Clock SCL High Count Register
  static volatile uint32_t & I2C0_IC_FS_SCL_HCNT __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 28)) ;

  // Field IC_FS_SCL_HCNT: This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for fast mode or fast mode plus. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. For more information, refer to 'IC_CLK Frequency Configuration'.\n\n This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE = standard. This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. For designs with APB_DATA_WIDTH == 8 the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed.
    inline uint32_t I2C0_IC_FS_SCL_HCNT_IC_FS_SCL_HCNT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IC_FS_SCL_LCNT: Fast Mode or Fast Mode Plus I2C Clock SCL Low Count Register
  static volatile uint32_t & I2C0_IC_FS_SCL_LCNT __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 32)) ;

  // Field IC_FS_SCL_LCNT: This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. For more information, refer to 'IC_CLK Frequency Configuration'.\n\n This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE = standard.\n\n This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n The minimum valid value is 8; hardware prevents values less than this being written, and if attempted results in 8 being set. For designs with APB_DATA_WIDTH = 8 the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed. If the value is less than 8 then the count value gets changed to 8.
    inline uint32_t I2C0_IC_FS_SCL_LCNT_IC_FS_SCL_LCNT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IC_INTR_STAT: I2C Interrupt Status Register\n\n Each bit in this register has a corresponding mask bit in the IC_INTR_MASK register. These bits are cleared by reading the matching interrupt clear register. The unmasked raw versions of these bits are available in the IC_RAW_INTR_STAT register.
  static volatile uint32_t & I2C0_IC_INTR_STAT __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 44)) ;

  // Field R_RX_UNDER: See IC_RAW_INTR_STAT for a detailed description of R_RX_UNDER bit.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_INTR_STAT_R_RX_UNDER = 1U << 0 ;

  // Field R_RX_OVER: See IC_RAW_INTR_STAT for a detailed description of R_RX_OVER bit.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_INTR_STAT_R_RX_OVER = 1U << 1 ;

  // Field R_RX_FULL: See IC_RAW_INTR_STAT for a detailed description of R_RX_FULL bit.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_INTR_STAT_R_RX_FULL = 1U << 2 ;

  // Field R_TX_OVER: See IC_RAW_INTR_STAT for a detailed description of R_TX_OVER bit.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_INTR_STAT_R_TX_OVER = 1U << 3 ;

  // Field R_TX_EMPTY: See IC_RAW_INTR_STAT for a detailed description of R_TX_EMPTY bit.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_INTR_STAT_R_TX_EMPTY = 1U << 4 ;

  // Field R_RD_REQ: See IC_RAW_INTR_STAT for a detailed description of R_RD_REQ bit.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_INTR_STAT_R_RD_REQ = 1U << 5 ;

  // Field R_TX_ABRT: See IC_RAW_INTR_STAT for a detailed description of R_TX_ABRT bit.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_INTR_STAT_R_TX_ABRT = 1U << 6 ;

  // Field R_RX_DONE: See IC_RAW_INTR_STAT for a detailed description of R_RX_DONE bit.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_INTR_STAT_R_RX_DONE = 1U << 7 ;

  // Field R_ACTIVITY: See IC_RAW_INTR_STAT for a detailed description of R_ACTIVITY bit.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_INTR_STAT_R_ACTIVITY = 1U << 8 ;

  // Field R_STOP_DET: See IC_RAW_INTR_STAT for a detailed description of R_STOP_DET bit.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_INTR_STAT_R_STOP_DET = 1U << 9 ;

  // Field R_START_DET: See IC_RAW_INTR_STAT for a detailed description of R_START_DET bit.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_INTR_STAT_R_START_DET = 1U << 10 ;

  // Field R_GEN_CALL: See IC_RAW_INTR_STAT for a detailed description of R_GEN_CALL bit.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_INTR_STAT_R_GEN_CALL = 1U << 11 ;

  // Field R_RESTART_DET: See IC_RAW_INTR_STAT for a detailed description of R_RESTART_DET bit.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_INTR_STAT_R_RESTART_DET = 1U << 12 ;

  // Field R_MASTER_ON_HOLD: See IC_RAW_INTR_STAT for a detailed description of R_MASTER_ON_HOLD bit.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_INTR_STAT_R_MASTER_ON_HOLD = 1U << 13 ;

//------------------------------------------------------------------------------

//---  Register IC_INTR_MASK: I2C Interrupt Mask Register.\n\n These bits mask their corresponding interrupt status bits. This register is active low; a value of 0 masks the interrupt, whereas a value of 1 unmasks the interrupt.
  static volatile uint32_t & I2C0_IC_INTR_MASK __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 48)) ;

  // Field M_RX_UNDER: This bit masks the R_RX_UNDER interrupt in IC_INTR_STAT register.\n\n Reset value: 0x1
    const uint32_t I2C0_IC_INTR_MASK_M_RX_UNDER = 1U << 0 ;

  // Field M_RX_OVER: This bit masks the R_RX_OVER interrupt in IC_INTR_STAT register.\n\n Reset value: 0x1
    const uint32_t I2C0_IC_INTR_MASK_M_RX_OVER = 1U << 1 ;

  // Field M_RX_FULL: This bit masks the R_RX_FULL interrupt in IC_INTR_STAT register.\n\n Reset value: 0x1
    const uint32_t I2C0_IC_INTR_MASK_M_RX_FULL = 1U << 2 ;

  // Field M_TX_OVER: This bit masks the R_TX_OVER interrupt in IC_INTR_STAT register.\n\n Reset value: 0x1
    const uint32_t I2C0_IC_INTR_MASK_M_TX_OVER = 1U << 3 ;

  // Field M_TX_EMPTY: This bit masks the R_TX_EMPTY interrupt in IC_INTR_STAT register.\n\n Reset value: 0x1
    const uint32_t I2C0_IC_INTR_MASK_M_TX_EMPTY = 1U << 4 ;

  // Field M_RD_REQ: This bit masks the R_RD_REQ interrupt in IC_INTR_STAT register.\n\n Reset value: 0x1
    const uint32_t I2C0_IC_INTR_MASK_M_RD_REQ = 1U << 5 ;

  // Field M_TX_ABRT: This bit masks the R_TX_ABRT interrupt in IC_INTR_STAT register.\n\n Reset value: 0x1
    const uint32_t I2C0_IC_INTR_MASK_M_TX_ABRT = 1U << 6 ;

  // Field M_RX_DONE: This bit masks the R_RX_DONE interrupt in IC_INTR_STAT register.\n\n Reset value: 0x1
    const uint32_t I2C0_IC_INTR_MASK_M_RX_DONE = 1U << 7 ;

  // Field M_ACTIVITY: This bit masks the R_ACTIVITY interrupt in IC_INTR_STAT register.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_INTR_MASK_M_ACTIVITY = 1U << 8 ;

  // Field M_STOP_DET: This bit masks the R_STOP_DET interrupt in IC_INTR_STAT register.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_INTR_MASK_M_STOP_DET = 1U << 9 ;

  // Field M_START_DET: This bit masks the R_START_DET interrupt in IC_INTR_STAT register.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_INTR_MASK_M_START_DET = 1U << 10 ;

  // Field M_GEN_CALL: This bit masks the R_GEN_CALL interrupt in IC_INTR_STAT register.\n\n Reset value: 0x1
    const uint32_t I2C0_IC_INTR_MASK_M_GEN_CALL = 1U << 11 ;

  // Field M_RESTART_DET: This bit masks the R_RESTART_DET interrupt in IC_INTR_STAT register.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_INTR_MASK_M_RESTART_DET = 1U << 12 ;

  // Field M_MASTER_ON_HOLD_READ_ONLY: This M_MASTER_ON_HOLD_read_only bit masks the R_MASTER_ON_HOLD interrupt in IC_INTR_STAT register.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_INTR_MASK_M_MASTER_ON_HOLD_READ_ONLY = 1U << 13 ;

//------------------------------------------------------------------------------

//---  Register IC_RAW_INTR_STAT: I2C Raw Interrupt Status Register\n\n Unlike the IC_INTR_STAT register, these bits are not masked so they always show the true status of the DW_apb_i2c.
  static volatile uint32_t & I2C0_IC_RAW_INTR_STAT __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 52)) ;

  // Field RX_UNDER: Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD register. If the module is disabled (IC_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_RAW_INTR_STAT_RX_UNDER = 1U << 0 ;

  // Field RX_OVER: Set if the receive buffer is completely filled to IC_RX_BUFFER_DEPTH and an additional byte is received from an external I2C device. The DW_apb_i2c acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (IC_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.\n\n Note: If bit 9 of the IC_CON register (RX_FIFO_FULL_HLD_CTRL) is programmed to HIGH, then the RX_OVER interrupt never occurs, because the Rx FIFO never overflows.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_RAW_INTR_STAT_RX_OVER = 1U << 1 ;

  // Field RX_FULL: Set when the receive buffer reaches or goes above the RX_TL threshold in the IC_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (IC_ENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the IC_ENABLE bit 0 is programmed with a 0, regardless of the activity that continues.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_RAW_INTR_STAT_RX_FULL = 1U << 2 ;

  // Field TX_OVER: Set during transmit if the transmit buffer is filled to IC_TX_BUFFER_DEPTH and the processor attempts to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_RAW_INTR_STAT_TX_OVER = 1U << 3 ;

  // Field TX_EMPTY: The behavior of the TX_EMPTY interrupt status differs based on the TX_EMPTY_CTRL selection in the IC_CON register. - When TX_EMPTY_CTRL = 0: This bit is set to 1 when the transmit buffer is at or below the threshold value set in the IC_TX_TL register. - When TX_EMPTY_CTRL = 1: This bit is set to 1 when the transmit buffer is at or below the threshold value set in the IC_TX_TL register and the transmission of the address/data from the internal shift register for the most recently popped command is completed. It is automatically cleared by hardware when the buffer level goes above the threshold. When IC_ENABLE[0] is set to 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer any activity, then with ic_en=0, this bit is set to 0.\n\n Reset value: 0x0.
    const uint32_t I2C0_IC_RAW_INTR_STAT_TX_EMPTY = 1U << 4 ;

  // Field RD_REQ: This bit is set to 1 when DW_apb_i2c is acting as a slave and another I2C master is attempting to read data from DW_apb_i2c. The DW_apb_i2c holds the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the IC_DATA_CMD register. This bit is set to 0 just after the processor reads the IC_CLR_RD_REQ register.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_RAW_INTR_STAT_RD_REQ = 1U << 5 ;

  // Field TX_ABRT: This bit indicates if DW_apb_i2c, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a 'transmit abort'. When this bit is set to 1, the IC_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places.\n\n Note: The DW_apb_i2c flushes/resets/empties the TX_FIFO and RX_FIFO whenever there is a transmit abort caused by any of the events tracked by the IC_TX_ABRT_SOURCE register. The FIFOs remains in this flushed state until the register IC_CLR_TX_ABRT is read. Once this read is performed, the Tx FIFO is then ready to accept more data bytes from the APB interface.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_RAW_INTR_STAT_TX_ABRT = 1U << 6 ;

  // Field RX_DONE: When the DW_apb_i2c is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_RAW_INTR_STAT_RX_DONE = 1U << 7 ;

  // Field ACTIVITY: This bit captures DW_apb_i2c activity and stays set until it is cleared. There are four ways to clear it: - Disabling the DW_apb_i2c - Reading the IC_CLR_ACTIVITY register - Reading the IC_CLR_INTR register - System reset Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the DW_apb_i2c module is idle, this bit remains set until cleared, indicating that there was activity on the bus.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_RAW_INTR_STAT_ACTIVITY = 1U << 8 ;

  // Field STOP_DET: Indicates whether a STOP condition has occurred on the I2C interface regardless of whether DW_apb_i2c is operating in slave or master mode.\n\n In Slave Mode: - If IC_CON[7]=1'b1 (STOP_DET_IFADDRESSED), the STOP_DET interrupt will be issued only if slave is addressed. Note: During a general call address, this slave does not issue a STOP_DET interrupt if STOP_DET_IF_ADDRESSED=1'b1, even if the slave responds to the general call address by generating ACK. The STOP_DET interrupt is generated only when the transmitted address matches the slave address (SAR). - If IC_CON[7]=1'b0 (STOP_DET_IFADDRESSED), the STOP_DET interrupt is issued irrespective of whether it is being addressed. In Master Mode: - If IC_CON[10]=1'b1 (STOP_DET_IF_MASTER_ACTIVE),the STOP_DET interrupt will be issued only if Master is active. - If IC_CON[10]=1'b0 (STOP_DET_IFADDRESSED),the STOP_DET interrupt will be issued irrespective of whether master is active or not. Reset value: 0x0
    const uint32_t I2C0_IC_RAW_INTR_STAT_STOP_DET = 1U << 9 ;

  // Field START_DET: Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether DW_apb_i2c is operating in slave or master mode.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_RAW_INTR_STAT_START_DET = 1U << 10 ;

  // Field GEN_CALL: Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling DW_apb_i2c or when the CPU reads bit 0 of the IC_CLR_GEN_CALL register. DW_apb_i2c stores the received data in the Rx buffer.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_RAW_INTR_STAT_GEN_CALL = 1U << 11 ;

  // Field RESTART_DET: Indicates whether a RESTART condition has occurred on the I2C interface when DW_apb_i2c is operating in Slave mode and the slave is being addressed. Enabled only when IC_SLV_RESTART_DET_EN=1.\n\n Note: However, in high-speed mode or during a START BYTE transfer, the RESTART comes before the address field as per the I2C protocol. In this case, the slave is not the addressed slave when the RESTART is issued, therefore DW_apb_i2c does not generate the RESTART_DET interrupt.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_RAW_INTR_STAT_RESTART_DET = 1U << 12 ;

  // Field MASTER_ON_HOLD: Indicates whether master is holding the bus and TX FIFO is empty. Enabled only when I2C_DYNAMIC_TAR_UPDATE=1 and IC_EMPTYFIFO_HOLD_MASTER_EN=1.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_RAW_INTR_STAT_MASTER_ON_HOLD = 1U << 13 ;

//------------------------------------------------------------------------------

//---  Register IC_RX_TL: I2C Receive FIFO Threshold Register
  static volatile uint32_t & I2C0_IC_RX_TL __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 56)) ;

  // Field RX_TL: Receive FIFO Threshold Level.\n\n Controls the level of entries (or above) that triggers the RX_FULL interrupt (bit 2 in IC_RAW_INTR_STAT register). The valid range is 0-255, with the additional restriction that hardware does not allow this value to be set to a value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 1 entry, and a value of 255 sets the threshold for 256 entries.
    inline uint32_t I2C0_IC_RX_TL_RX_TL (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IC_TX_TL: I2C Transmit FIFO Threshold Register
  static volatile uint32_t & I2C0_IC_TX_TL __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 60)) ;

  // Field TX_TL: Transmit FIFO Threshold Level.\n\n Controls the level of entries (or below) that trigger the TX_EMPTY interrupt (bit 4 in IC_RAW_INTR_STAT register). The valid range is 0-255, with the additional restriction that it may not be set to value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 0 entries, and a value of 255 sets the threshold for 255 entries.
    inline uint32_t I2C0_IC_TX_TL_TX_TL (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IC_CLR_INTR: Clear Combined and Individual Interrupt Register
  static volatile uint32_t & I2C0_IC_CLR_INTR __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 64)) ;

  // Field CLR_INTR: Read this register to clear the combined interrupt, all individual interrupts, and the IC_TX_ABRT_SOURCE register. This bit does not clear hardware clearable interrupts but software clearable interrupts. Refer to Bit 9 of the IC_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_CLR_INTR_CLR_INTR = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IC_CLR_RX_UNDER: Clear RX_UNDER Interrupt Register
  static volatile uint32_t & I2C0_IC_CLR_RX_UNDER __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 68)) ;

  // Field CLR_RX_UNDER: Read this register to clear the RX_UNDER interrupt (bit 0) of the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_CLR_RX_UNDER_CLR_RX_UNDER = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IC_CLR_RX_OVER: Clear RX_OVER Interrupt Register
  static volatile uint32_t & I2C0_IC_CLR_RX_OVER __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 72)) ;

  // Field CLR_RX_OVER: Read this register to clear the RX_OVER interrupt (bit 1) of the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_CLR_RX_OVER_CLR_RX_OVER = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IC_CLR_TX_OVER: Clear TX_OVER Interrupt Register
  static volatile uint32_t & I2C0_IC_CLR_TX_OVER __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 76)) ;

  // Field CLR_TX_OVER: Read this register to clear the TX_OVER interrupt (bit 3) of the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_CLR_TX_OVER_CLR_TX_OVER = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IC_CLR_RD_REQ: Clear RD_REQ Interrupt Register
  static volatile uint32_t & I2C0_IC_CLR_RD_REQ __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 80)) ;

  // Field CLR_RD_REQ: Read this register to clear the RD_REQ interrupt (bit 5) of the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_CLR_RD_REQ_CLR_RD_REQ = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IC_CLR_TX_ABRT: Clear TX_ABRT Interrupt Register
  static volatile uint32_t & I2C0_IC_CLR_TX_ABRT __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 84)) ;

  // Field CLR_TX_ABRT: Read this register to clear the TX_ABRT interrupt (bit 6) of the IC_RAW_INTR_STAT register, and the IC_TX_ABRT_SOURCE register. This also releases the TX FIFO from the flushed/reset state, allowing more writes to the TX FIFO. Refer to Bit 9 of the IC_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_CLR_TX_ABRT_CLR_TX_ABRT = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IC_CLR_RX_DONE: Clear RX_DONE Interrupt Register
  static volatile uint32_t & I2C0_IC_CLR_RX_DONE __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 88)) ;

  // Field CLR_RX_DONE: Read this register to clear the RX_DONE interrupt (bit 7) of the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_CLR_RX_DONE_CLR_RX_DONE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IC_CLR_ACTIVITY: Clear ACTIVITY Interrupt Register
  static volatile uint32_t & I2C0_IC_CLR_ACTIVITY __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 92)) ;

  // Field CLR_ACTIVITY: Reading this register clears the ACTIVITY interrupt if the I2C is not active anymore. If the I2C module is still active on the bus, the ACTIVITY interrupt bit continues to be set. It is automatically cleared by hardware if the module is disabled and if there is no further activity on the bus. The value read from this register to get status of the ACTIVITY interrupt (bit 8) of the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_CLR_ACTIVITY_CLR_ACTIVITY = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IC_CLR_STOP_DET: Clear STOP_DET Interrupt Register
  static volatile uint32_t & I2C0_IC_CLR_STOP_DET __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 96)) ;

  // Field CLR_STOP_DET: Read this register to clear the STOP_DET interrupt (bit 9) of the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_CLR_STOP_DET_CLR_STOP_DET = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IC_CLR_START_DET: Clear START_DET Interrupt Register
  static volatile uint32_t & I2C0_IC_CLR_START_DET __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 100)) ;

  // Field CLR_START_DET: Read this register to clear the START_DET interrupt (bit 10) of the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_CLR_START_DET_CLR_START_DET = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IC_CLR_GEN_CALL: Clear GEN_CALL Interrupt Register
  static volatile uint32_t & I2C0_IC_CLR_GEN_CALL __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 104)) ;

  // Field CLR_GEN_CALL: Read this register to clear the GEN_CALL interrupt (bit 11) of IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_CLR_GEN_CALL_CLR_GEN_CALL = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IC_ENABLE: I2C Enable Register
  static volatile uint32_t & I2C0_IC_ENABLE __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 108)) ;

  // Field ENABLE: Controls whether the DW_apb_i2c is enabled. - 0: Disables DW_apb_i2c (TX and RX FIFOs are held in an erased state) - 1: Enables DW_apb_i2c Software can disable DW_apb_i2c while it is active. However, it is important that care be taken to ensure that DW_apb_i2c is disabled properly. A recommended procedure is described in 'Disabling DW_apb_i2c'.\n\n When DW_apb_i2c is disabled, the following occurs: - The TX FIFO and RX FIFO get flushed. - Status bits in the IC_INTR_STAT register are still active until DW_apb_i2c goes into IDLE state. If the module is transmitting, it stops as well as deletes the contents of the transmit buffer after the current transfer is complete. If the module is receiving, the DW_apb_i2c stops the current transfer at the end of the current byte and does not acknowledge the transfer.\n\n In systems with asynchronous pclk and ic_clk when IC_CLK_TYPE parameter set to asynchronous (1), there is a two ic_clk delay when enabling or disabling the DW_apb_i2c. For a detailed description on how to disable DW_apb_i2c, refer to 'Disabling DW_apb_i2c'\n\n Reset value: 0x0
    const uint32_t I2C0_IC_ENABLE_ENABLE = 1U << 0 ;

  // Field ABORT: When set, the controller initiates the transfer abort. - 0: ABORT not initiated or ABORT done - 1: ABORT operation in progress The software can abort the I2C transfer in master mode by setting this bit. The software can set this bit only when ENABLE is already set; otherwise, the controller ignores any write to ABORT bit. The software cannot clear the ABORT bit once set. In response to an ABORT, the controller issues a STOP and flushes the Tx FIFO after completing the current transfer, then sets the TX_ABORT interrupt after the abort operation. The ABORT bit is cleared automatically after the abort operation.\n\n For a detailed description on how to abort I2C transfers, refer to 'Aborting I2C Transfers'.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_ENABLE_ABORT = 1U << 1 ;

  // Field TX_CMD_BLOCK: In Master mode: - 1'b1: Blocks the transmission of data on I2C bus even if Tx FIFO has data to transmit. - 1'b0: The transmission of data starts on I2C bus automatically, as soon as the first data is available in the Tx FIFO. Note: To block the execution of Master commands, set the TX_CMD_BLOCK bit only when Tx FIFO is empty (IC_STATUS[2]==1) and Master is in Idle state (IC_STATUS[5] == 0). Any further commands put in the Tx FIFO are not executed until TX_CMD_BLOCK bit is unset. Reset value: IC_TX_CMD_BLOCK_DEFAULT
    const uint32_t I2C0_IC_ENABLE_TX_CMD_BLOCK = 1U << 2 ;

//------------------------------------------------------------------------------

//---  Register IC_STATUS: I2C Status Register\n\n This is a read-only register used to indicate the current transfer status and FIFO status. The status register may be read at any time. None of the bits in this register request an interrupt.\n\n When the I2C is disabled by writing 0 in bit 0 of the IC_ENABLE register: - Bits 1 and 2 are set to 1 - Bits 3 and 10 are set to 0 When the master or slave state machines goes to idle and ic_en=0: - Bits 5 and 6 are set to 0
  static volatile uint32_t & I2C0_IC_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 112)) ;

  // Field ACTIVITY: I2C Activity Status. Reset value: 0x0
    const uint32_t I2C0_IC_STATUS_ACTIVITY = 1U << 0 ;

  // Field TFNF: Transmit FIFO Not Full. Set when the transmit FIFO contains one or more empty locations, and is cleared when the FIFO is full. - 0: Transmit FIFO is full - 1: Transmit FIFO is not full Reset value: 0x1
    const uint32_t I2C0_IC_STATUS_TFNF = 1U << 1 ;

  // Field TFE: Transmit FIFO Completely Empty. When the transmit FIFO is completely empty, this bit is set. When it contains one or more valid entries, this bit is cleared. This bit field does not request an interrupt. - 0: Transmit FIFO is not empty - 1: Transmit FIFO is empty Reset value: 0x1
    const uint32_t I2C0_IC_STATUS_TFE = 1U << 2 ;

  // Field RFNE: Receive FIFO Not Empty. This bit is set when the receive FIFO contains one or more entries; it is cleared when the receive FIFO is empty. - 0: Receive FIFO is empty - 1: Receive FIFO is not empty Reset value: 0x0
    const uint32_t I2C0_IC_STATUS_RFNE = 1U << 3 ;

  // Field RFF: Receive FIFO Completely Full. When the receive FIFO is completely full, this bit is set. When the receive FIFO contains one or more empty location, this bit is cleared. - 0: Receive FIFO is not full - 1: Receive FIFO is full Reset value: 0x0
    const uint32_t I2C0_IC_STATUS_RFF = 1U << 4 ;

  // Field MST_ACTIVITY: Master FSM Activity Status. When the Master Finite State Machine (FSM) is not in the IDLE state, this bit is set. - 0: Master FSM is in IDLE state so the Master part of DW_apb_i2c is not Active - 1: Master FSM is not in IDLE state so the Master part of DW_apb_i2c is Active Note: IC_STATUS[0]-that is, ACTIVITY bit-is the OR of SLV_ACTIVITY and MST_ACTIVITY bits.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_STATUS_MST_ACTIVITY = 1U << 5 ;

  // Field SLV_ACTIVITY: Slave FSM Activity Status. When the Slave Finite State Machine (FSM) is not in the IDLE state, this bit is set. - 0: Slave FSM is in IDLE state so the Slave part of DW_apb_i2c is not Active - 1: Slave FSM is not in IDLE state so the Slave part of DW_apb_i2c is Active Reset value: 0x0
    const uint32_t I2C0_IC_STATUS_SLV_ACTIVITY = 1U << 6 ;

//------------------------------------------------------------------------------

//---  Register IC_TXFLR: I2C Transmit FIFO Level Register This register contains the number of valid data entries in the transmit FIFO buffer. It is cleared whenever: - The I2C is disabled - There is a transmit abort - that is, TX_ABRT bit is set in the IC_RAW_INTR_STAT register - The slave bulk transmit mode is aborted The register increments whenever data is placed into the transmit FIFO and decrements when data is taken from the transmit FIFO.
  static volatile uint32_t & I2C0_IC_TXFLR __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 116)) ;

  // Field TXFLR: Transmit FIFO Level. Contains the number of valid data entries in the transmit FIFO.\n\n Reset value: 0x0
    inline uint32_t I2C0_IC_TXFLR_TXFLR (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IC_RXFLR: I2C Receive FIFO Level Register This register contains the number of valid data entries in the receive FIFO buffer. It is cleared whenever: - The I2C is disabled - Whenever there is a transmit abort caused by any of the events tracked in IC_TX_ABRT_SOURCE The register increments whenever data is placed into the receive FIFO and decrements when data is taken from the receive FIFO.
  static volatile uint32_t & I2C0_IC_RXFLR __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 120)) ;

  // Field RXFLR: Receive FIFO Level. Contains the number of valid data entries in the receive FIFO.\n\n Reset value: 0x0
    inline uint32_t I2C0_IC_RXFLR_RXFLR (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IC_SDA_HOLD: I2C SDA Hold Time Length Register\n\n The bits [15:0] of this register are used to control the hold time of SDA during transmit in both slave and master mode (after SCL goes from HIGH to LOW).\n\n The bits [23:16] of this register are used to extend the SDA transition (if any) whenever SCL is HIGH in the receiver in either master or slave mode.\n\n Writes to this register succeed only when IC_ENABLE[0]=0.\n\n The values in this register are in units of ic_clk period. The value programmed in IC_SDA_TX_HOLD must be greater than the minimum hold time in each mode one cycle in master mode, seven cycles in slave mode for the value to be implemented.\n\n The programmed SDA hold time during transmit (IC_SDA_TX_HOLD) cannot exceed at any time the duration of the low part of scl. Therefore the programmed value cannot be larger than N_SCL_LOW-2, where N_SCL_LOW is the duration of the low part of the scl period measured in ic_clk cycles.
  static volatile uint32_t & I2C0_IC_SDA_HOLD __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 124)) ;

  // Field IC_SDA_TX_HOLD: Sets the required SDA hold time in units of ic_clk period, when DW_apb_i2c acts as a transmitter.\n\n Reset value: IC_DEFAULT_SDA_HOLD[15:0].
    inline uint32_t I2C0_IC_SDA_HOLD_IC_SDA_TX_HOLD (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field IC_SDA_RX_HOLD: Sets the required SDA hold time in units of ic_clk period, when DW_apb_i2c acts as a receiver.\n\n Reset value: IC_DEFAULT_SDA_HOLD[23:16].
    inline uint32_t I2C0_IC_SDA_HOLD_IC_SDA_RX_HOLD (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register IC_TX_ABRT_SOURCE: I2C Transmit Abort Source Register\n\n This register has 32 bits that indicate the source of the TX_ABRT bit. Except for Bit 9, this register is cleared whenever the IC_CLR_TX_ABRT register or the IC_CLR_INTR register is read. To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; RESTART must be enabled (IC_CON[5]=1), the SPECIAL bit must be cleared (IC_TAR[11]), or the GC_OR_START bit must be cleared (IC_TAR[10]).\n\n Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, Bit 9 clears for one cycle and is then re-asserted.
  static volatile uint32_t & I2C0_IC_TX_ABRT_SOURCE __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 128)) ;

  // Field ABRT_7B_ADDR_NOACK: This field indicates that the Master is in 7-bit addressing mode and the address sent was not acknowledged by any slave.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter or Master-Receiver
    const uint32_t I2C0_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK = 1U << 0 ;

  // Field ABRT_10ADDR1_NOACK: This field indicates that the Master is in 10-bit address mode and the first 10-bit address byte was not acknowledged by any slave.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter or Master-Receiver
    const uint32_t I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK = 1U << 1 ;

  // Field ABRT_10ADDR2_NOACK: This field indicates that the Master is in 10-bit address mode and that the second address byte of the 10-bit address was not acknowledged by any slave.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter or Master-Receiver
    const uint32_t I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK = 1U << 2 ;

  // Field ABRT_TXDATA_NOACK: This field indicates the master-mode only bit. When the master receives an acknowledgement for the address, but when it sends data byte(s) following the address, it did not receive an acknowledge from the remote slave(s).\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter
    const uint32_t I2C0_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK = 1U << 3 ;

  // Field ABRT_GCALL_NOACK: This field indicates that DW_apb_i2c in master mode has sent a General Call and no slave on the bus acknowledged the General Call.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter
    const uint32_t I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK = 1U << 4 ;

  // Field ABRT_GCALL_READ: This field indicates that DW_apb_i2c in the master mode has sent a General Call but the user programmed the byte following the General Call to be a read from the bus (IC_DATA_CMD[9] is set to 1).\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter
    const uint32_t I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ = 1U << 5 ;

  // Field ABRT_HS_ACKDET: This field indicates that the Master is in High Speed mode and the High Speed Master code was acknowledged (wrong behavior).\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master
    const uint32_t I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET = 1U << 6 ;

  // Field ABRT_SBYTE_ACKDET: This field indicates that the Master has sent a START Byte and the START Byte was acknowledged (wrong behavior).\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master
    const uint32_t I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET = 1U << 7 ;

  // Field ABRT_HS_NORSTRT: This field indicates that the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the user is trying to use the master to transfer data in High Speed mode.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter or Master-Receiver
    const uint32_t I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT = 1U << 8 ;

  // Field ABRT_SBYTE_NORSTRT: To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; restart must be enabled (IC_CON[5]=1), the SPECIAL bit must be cleared (IC_TAR[11]), or the GC_OR_START bit must be cleared (IC_TAR[10]). Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, bit 9 clears for one cycle and then gets reasserted. When this field is set to 1, the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the user is trying to send a START Byte.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master
    const uint32_t I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT = 1U << 9 ;

  // Field ABRT_10B_RD_NORSTRT: This field indicates that the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the master sends a read command in 10-bit addressing mode.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Receiver
    const uint32_t I2C0_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT = 1U << 10 ;

  // Field ABRT_MASTER_DIS: This field indicates that the User tries to initiate a Master operation with the Master mode disabled.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter or Master-Receiver
    const uint32_t I2C0_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS = 1U << 11 ;

  // Field ARB_LOST: This field specifies that the Master has lost arbitration, or if IC_TX_ABRT_SOURCE[14] is also set, then the slave transmitter has lost arbitration.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter or Slave-Transmitter
    const uint32_t I2C0_IC_TX_ABRT_SOURCE_ARB_LOST = 1U << 12 ;

  // Field ABRT_SLVFLUSH_TXFIFO: This field specifies that the Slave has received a read command and some data exists in the TX FIFO, so the slave issues a TX_ABRT interrupt to flush old data in TX FIFO.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Slave-Transmitter
    const uint32_t I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO = 1U << 13 ;

  // Field ABRT_SLV_ARBLOST: This field indicates that a Slave has lost the bus while transmitting data to a remote master. IC_TX_ABRT_SOURCE[12] is set at the same time. Note: Even though the slave never 'owns' the bus, something could go wrong on the bus. This is a fail safe check. For instance, during a data transmission at the low-to-high transition of SCL, if what is on the data bus is not what is supposed to be transmitted, then DW_apb_i2c no longer own the bus.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Slave-Transmitter
    const uint32_t I2C0_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST = 1U << 14 ;

  // Field ABRT_SLVRD_INTX: 1: When the processor side responds to a slave mode request for data to be transmitted to a remote master and user writes a 1 in CMD (bit 8) of IC_DATA_CMD register.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Slave-Transmitter
    const uint32_t I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX = 1U << 15 ;

  // Field ABRT_USER_ABRT: This is a master-mode-only bit. Master has detected the transfer abort (IC_ENABLE[1])\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter
    const uint32_t I2C0_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT = 1U << 16 ;

  // Field TX_FLUSH_CNT: This field indicates the number of Tx FIFO Data Commands which are flushed due to TX_ABRT interrupt. It is cleared whenever I2C is disabled.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter or Slave-Transmitter
    inline uint32_t I2C0_IC_TX_ABRT_SOURCE_TX_FLUSH_CNT (const uint32_t inValue) {return (inValue & 0x1FFU) << 23 ; }

//------------------------------------------------------------------------------

//---  Register IC_SLV_DATA_NACK_ONLY: Generate Slave Data NACK Register\n\n The register is used to generate a NACK for the data part of a transfer when DW_apb_i2c is acting as a slave-receiver. This register only exists when the IC_SLV_DATA_NACK_ONLY parameter is set to 1. When this parameter disabled, this register does not exist and writing to the register's address has no effect.\n\n A write can occur on this register if both of the following conditions are met: - DW_apb_i2c is disabled (IC_ENABLE[0] = 0) - Slave part is inactive (IC_STATUS[6] = 0) Note: The IC_STATUS[6] is a register read-back location for the internal slv_activity signal; the user should poll this before writing the ic_slv_data_nack_only bit.
  static volatile uint32_t & I2C0_IC_SLV_DATA_NACK_ONLY __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 132)) ;

  // Field NACK: Generate NACK. This NACK generation only occurs when DW_apb_i2c is a slave-receiver. If this register is set to a value of 1, it can only generate a NACK after a data byte is received; hence, the data transfer is aborted and the data received is not pushed to the receive buffer.\n\n When the register is set to a value of 0, it generates NACK/ACK, depending on normal criteria. - 1: generate NACK after data byte received - 0: generate NACK/ACK normally Reset value: 0x0
    const uint32_t I2C0_IC_SLV_DATA_NACK_ONLY_NACK = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IC_DMA_CR: DMA Control Register\n\n The register is used to enable the DMA Controller interface operation. There is a separate bit for transmit and receive. This can be programmed regardless of the state of IC_ENABLE.
  static volatile uint32_t & I2C0_IC_DMA_CR __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 136)) ;

  // Field RDMAE: Receive DMA Enable. This bit enables/disables the receive FIFO DMA channel. Reset value: 0x0
    const uint32_t I2C0_IC_DMA_CR_RDMAE = 1U << 0 ;

  // Field TDMAE: Transmit DMA Enable. This bit enables/disables the transmit FIFO DMA channel. Reset value: 0x0
    const uint32_t I2C0_IC_DMA_CR_TDMAE = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register IC_DMA_TDLR: DMA Transmit Data Level Register
  static volatile uint32_t & I2C0_IC_DMA_TDLR __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 140)) ;

  // Field DMATDL: Transmit Data Level. This bit field controls the level at which a DMA request is made by the transmit logic. It is equal to the watermark level; that is, the dma_tx_req signal is generated when the number of valid data entries in the transmit FIFO is equal to or below this field value, and TDMAE = 1.\n\n Reset value: 0x0
    inline uint32_t I2C0_IC_DMA_TDLR_DMATDL (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IC_DMA_RDLR: I2C Receive Data Level Register
  static volatile uint32_t & I2C0_IC_DMA_RDLR __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 144)) ;

  // Field DMARDL: Receive Data Level. This bit field controls the level at which a DMA request is made by the receive logic. The watermark level = DMARDL+1; that is, dma_rx_req is generated when the number of valid data entries in the receive FIFO is equal to or more than this field value + 1, and RDMAE =1. For instance, when DMARDL is 0, then dma_rx_req is asserted when 1 or more data entries are present in the receive FIFO.\n\n Reset value: 0x0
    inline uint32_t I2C0_IC_DMA_RDLR_DMARDL (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IC_SDA_SETUP: I2C SDA Setup Register\n\n This register controls the amount of time delay (in terms of number of ic_clk clock periods) introduced in the rising edge of SCL - relative to SDA changing - when DW_apb_i2c services a read request in a slave-transmitter operation. The relevant I2C requirement is tSU:DAT (note 4) as detailed in the I2C Bus Specification. This register must be programmed with a value equal to or greater than 2.\n\n Writes to this register succeed only when IC_ENABLE[0] = 0.\n\n Note: The length of setup time is calculated using [(IC_SDA_SETUP - 1) * (ic_clk_period)], so if the user requires 10 ic_clk periods of setup time, they should program a value of 11. The IC_SDA_SETUP register is only used by the DW_apb_i2c when operating as a slave transmitter.
  static volatile uint32_t & I2C0_IC_SDA_SETUP __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 148)) ;

  // Field SDA_SETUP: SDA Setup. It is recommended that if the required delay is 1000ns, then for an ic_clk frequency of 10 MHz, IC_SDA_SETUP should be programmed to a value of 11. IC_SDA_SETUP must be programmed with a minimum value of 2.
    inline uint32_t I2C0_IC_SDA_SETUP_SDA_SETUP (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IC_ACK_GENERAL_CALL: I2C ACK General Call Register\n\n The register controls whether DW_apb_i2c responds with a ACK or NACK when it receives an I2C General Call address.\n\n This register is applicable only when the DW_apb_i2c is in slave mode.
  static volatile uint32_t & I2C0_IC_ACK_GENERAL_CALL __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 152)) ;

  // Field ACK_GEN_CALL: ACK General Call. When set to 1, DW_apb_i2c responds with a ACK (by asserting ic_data_oe) when it receives a General Call. Otherwise, DW_apb_i2c responds with a NACK (by negating ic_data_oe).
    const uint32_t I2C0_IC_ACK_GENERAL_CALL_ACK_GEN_CALL = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IC_ENABLE_STATUS: I2C Enable Status Register\n\n The register is used to report the DW_apb_i2c hardware status when the IC_ENABLE[0] register is set from 1 to 0; that is, when DW_apb_i2c is disabled.\n\n If IC_ENABLE[0] has been set to 1, bits 2:1 are forced to 0, and bit 0 is forced to 1.\n\n If IC_ENABLE[0] has been set to 0, bits 2:1 is only be valid as soon as bit 0 is read as '0'.\n\n Note: When IC_ENABLE[0] has been set to 0, a delay occurs for bit 0 to be read as 0 because disabling the DW_apb_i2c depends on I2C bus activities.
  static volatile uint32_t & I2C0_IC_ENABLE_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 156)) ;

  // Field IC_EN: ic_en Status. This bit always reflects the value driven on the output port ic_en. - When read as 1, DW_apb_i2c is deemed to be in an enabled state. - When read as 0, DW_apb_i2c is deemed completely inactive. Note: The CPU can safely read this bit anytime. When this bit is read as 0, the CPU can safely read SLV_RX_DATA_LOST (bit 2) and SLV_DISABLED_WHILE_BUSY (bit 1).\n\n Reset value: 0x0
    const uint32_t I2C0_IC_ENABLE_STATUS_IC_EN = 1U << 0 ;

  // Field SLV_DISABLED_WHILE_BUSY: Slave Disabled While Busy (Transmit, Receive). This bit indicates if a potential or active Slave operation has been aborted due to the setting bit 0 of the IC_ENABLE register from 1 to 0. This bit is set when the CPU writes a 0 to the IC_ENABLE register while:\n\n (a) DW_apb_i2c is receiving the address byte of the Slave-Transmitter operation from a remote master;\n\n OR,\n\n (b) address and data bytes of the Slave-Receiver operation from a remote master.\n\n When read as 1, DW_apb_i2c is deemed to have forced a NACK during any part of an I2C transfer, irrespective of whether the I2C address matches the slave address set in DW_apb_i2c (IC_SAR register) OR if the transfer is completed before IC_ENABLE is set to 0 but has not taken effect.\n\n Note: If the remote I2C master terminates the transfer with a STOP condition before the DW_apb_i2c has a chance to NACK a transfer, and IC_ENABLE[0] has been set to 0, then this bit will also be set to 1.\n\n When read as 0, DW_apb_i2c is deemed to have been disabled when there is master activity, or when the I2C bus is idle.\n\n Note: The CPU can safely read this bit when IC_EN (bit 0) is read as 0.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY = 1U << 1 ;

  // Field SLV_RX_DATA_LOST: Slave Received Data Lost. This bit indicates if a Slave-Receiver operation has been aborted with at least one data byte received from an I2C transfer due to the setting bit 0 of IC_ENABLE from 1 to 0. When read as 1, DW_apb_i2c is deemed to have been actively engaged in an aborted I2C transfer (with matching address) and the data phase of the I2C transfer has been entered, even though a data byte has been responded with a NACK.\n\n Note: If the remote I2C master terminates the transfer with a STOP condition before the DW_apb_i2c has a chance to NACK a transfer, and IC_ENABLE[0] has been set to 0, then this bit is also set to 1.\n\n When read as 0, DW_apb_i2c is deemed to have been disabled without being actively involved in the data phase of a Slave-Receiver transfer.\n\n Note: The CPU can safely read this bit when IC_EN (bit 0) is read as 0.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_ENABLE_STATUS_SLV_RX_DATA_LOST = 1U << 2 ;

//------------------------------------------------------------------------------

//---  Register IC_FS_SPKLEN: I2C SS, FS or FM+ spike suppression limit\n\n This register is used to store the duration, measured in ic_clk cycles, of the longest spike that is filtered out by the spike suppression logic when the component is operating in SS, FS or FM+ modes. The relevant I2C requirement is tSP (table 4) as detailed in the I2C Bus Specification. This register must be programmed with a minimum value of 1.
  static volatile uint32_t & I2C0_IC_FS_SPKLEN __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 160)) ;

  // Field IC_FS_SPKLEN: This register must be set before any I2C bus transaction can take place to ensure stable operation. This register sets the duration, measured in ic_clk cycles, of the longest spike in the SCL or SDA lines that will be filtered out by the spike suppression logic. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect. The minimum valid value is 1; hardware prevents values less than this being written, and if attempted results in 1 being set. or more information, refer to 'Spike Suppression'.
    inline uint32_t I2C0_IC_FS_SPKLEN_IC_FS_SPKLEN (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IC_CLR_RESTART_DET: Clear RESTART_DET Interrupt Register
  static volatile uint32_t & I2C0_IC_CLR_RESTART_DET __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 168)) ;

  // Field CLR_RESTART_DET: Read this register to clear the RESTART_DET interrupt (bit 12) of IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
    const uint32_t I2C0_IC_CLR_RESTART_DET_CLR_RESTART_DET = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IC_COMP_PARAM_1: Component Parameter Register 1\n\n Note This register is not implemented and therefore reads as 0. If it was implemented it would be a constant read-only register that contains encoded information about the component's parameter settings. Fields shown below are the settings for those parameters
  static volatile uint32_t & I2C0_IC_COMP_PARAM_1 __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 244)) ;

  // Field APB_DATA_WIDTH: APB data bus width is 32 bits
    inline uint32_t I2C0_IC_COMP_PARAM_1_APB_DATA_WIDTH (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field MAX_SPEED_MODE: MAX SPEED MODE = FAST MODE
    inline uint32_t I2C0_IC_COMP_PARAM_1_MAX_SPEED_MODE (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field HC_COUNT_VALUES: Programmable count values for each mode.
    const uint32_t I2C0_IC_COMP_PARAM_1_HC_COUNT_VALUES = 1U << 4 ;

  // Field INTR_IO: COMBINED Interrupt outputs
    const uint32_t I2C0_IC_COMP_PARAM_1_INTR_IO = 1U << 5 ;

  // Field HAS_DMA: DMA handshaking signals are enabled
    const uint32_t I2C0_IC_COMP_PARAM_1_HAS_DMA = 1U << 6 ;

  // Field ADD_ENCODED_PARAMS: Encoded parameters not visible
    const uint32_t I2C0_IC_COMP_PARAM_1_ADD_ENCODED_PARAMS = 1U << 7 ;

  // Field RX_BUFFER_DEPTH: RX Buffer Depth = 16
    inline uint32_t I2C0_IC_COMP_PARAM_1_RX_BUFFER_DEPTH (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field TX_BUFFER_DEPTH: TX Buffer Depth = 16
    inline uint32_t I2C0_IC_COMP_PARAM_1_TX_BUFFER_DEPTH (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register IC_COMP_VERSION: I2C Component Version Register
  static volatile uint32_t & I2C0_IC_COMP_VERSION __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 248)) ;

  // Field IC_COMP_VERSION: 
    inline uint32_t I2C0_IC_COMP_VERSION_IC_COMP_VERSION (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IC_COMP_TYPE: I2C Component Type Register
  static volatile uint32_t & I2C0_IC_COMP_TYPE __attribute__((unused)) = * ((volatile uint32_t *) (0x40044000 + 252)) ;

  // Field IC_COMP_TYPE: Designware Component Type number = 0x44_57_01_40. This assigned unique hex value is constant and is derived from the two ASCII letters 'DW' followed by a 16-bit unsigned number.
    inline uint32_t I2C0_IC_COMP_TYPE_IC_COMP_TYPE (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral I2C1: 
//------------------------------------------------------------------------------

//---  Register IC_CON: I2C Control Register. This register can be written only when the DW_apb_i2c is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n Read/Write Access: - bit 10 is read only. - bit 11 is read only - bit 16 is read only - bit 17 is read only - bits 18 and 19 are read only.
  static volatile uint32_t & I2C1_IC_CON __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 0)) ;

  // Field MASTER_MODE: This bit controls whether the DW_apb_i2c master is enabled.\n\n NOTE: Software should ensure that if this bit is written with '1' then bit 6 should also be written with a '1'.
    const uint32_t I2C1_IC_CON_MASTER_MODE = 1U << 0 ;

  // Field SPEED: These bits control at which speed the DW_apb_i2c operates; its setting is relevant only if one is operating the DW_apb_i2c in master mode. Hardware protects against illegal values being programmed by software. These bits must be programmed appropriately for slave mode also, as it is used to capture correct value of spike filter as per the speed mode.\n\n This register should be programmed only with a value in the range of 1 to IC_MAX_SPEED_MODE; otherwise, hardware updates this register with the value of IC_MAX_SPEED_MODE.\n\n 1: standard mode (100 kbit/s)\n\n 2: fast mode (<=400 kbit/s) or fast mode plus (<=1000Kbit/s)\n\n 3: high speed mode (3.4 Mbit/s)\n\n Note: This field is not applicable when IC_ULTRA_FAST_MODE=1
    inline uint32_t I2C1_IC_CON_SPEED (const uint32_t inValue) {return (inValue & 0x3U) << 1 ; }

  // Field IC_10BITADDR_SLAVE: When acting as a slave, this bit controls whether the DW_apb_i2c responds to 7- or 10-bit addresses. - 0: 7-bit addressing. The DW_apb_i2c ignores transactions that involve 10-bit addressing; for 7-bit addressing, only the lower 7 bits of the IC_SAR register are compared. - 1: 10-bit addressing. The DW_apb_i2c responds to only 10-bit addressing transfers that match the full 10 bits of the IC_SAR register.
    const uint32_t I2C1_IC_CON_IC_10BITADDR_SLAVE = 1U << 3 ;

  // Field IC_10BITADDR_MASTER: Controls whether the DW_apb_i2c starts its transfers in 7- or 10-bit addressing mode when acting as a master. - 0: 7-bit addressing - 1: 10-bit addressing
    const uint32_t I2C1_IC_CON_IC_10BITADDR_MASTER = 1U << 4 ;

  // Field IC_RESTART_EN: Determines whether RESTART conditions may be sent when acting as a master. Some older slaves do not support handling RESTART conditions; however, RESTART conditions are used in several DW_apb_i2c operations. When RESTART is disabled, the master is prohibited from performing the following functions: - Sending a START BYTE - Performing any high-speed mode operation - High-speed mode operation - Performing direction changes in combined format mode - Performing a read operation with a 10-bit address By replacing RESTART condition followed by a STOP and a subsequent START condition, split operations are broken down into multiple DW_apb_i2c transfers. If the above operations are performed, it will result in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register.\n\n Reset value: ENABLED
    const uint32_t I2C1_IC_CON_IC_RESTART_EN = 1U << 5 ;

  // Field IC_SLAVE_DISABLE: This bit controls whether I2C has its slave disabled, which means once the presetn signal is applied, then this bit is set and the slave is disabled.\n\n If this bit is set (slave is disabled), DW_apb_i2c functions only as a master and does not perform any action that requires a slave.\n\n NOTE: Software should ensure that if this bit is written with 0, then bit 0 should also be written with a 0.
    const uint32_t I2C1_IC_CON_IC_SLAVE_DISABLE = 1U << 6 ;

  // Field STOP_DET_IFADDRESSED: In slave mode: - 1'b1: issues the STOP_DET interrupt only when it is addressed. - 1'b0: issues the STOP_DET irrespective of whether it's addressed or not. Reset value: 0x0\n\n NOTE: During a general call address, this slave does not issue the STOP_DET interrupt if STOP_DET_IF_ADDRESSED = 1'b1, even if the slave responds to the general call address by generating ACK. The STOP_DET interrupt is generated only when the transmitted address matches the slave address (SAR).
    const uint32_t I2C1_IC_CON_STOP_DET_IFADDRESSED = 1U << 7 ;

  // Field TX_EMPTY_CTRL: This bit controls the generation of the TX_EMPTY interrupt, as described in the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0.
    const uint32_t I2C1_IC_CON_TX_EMPTY_CTRL = 1U << 8 ;

  // Field RX_FIFO_FULL_HLD_CTRL: This bit controls whether DW_apb_i2c should hold the bus when the Rx FIFO is physically full to its RX_BUFFER_DEPTH, as described in the IC_RX_FULL_HLD_BUS_EN parameter.\n\n Reset value: 0x0.
    const uint32_t I2C1_IC_CON_RX_FIFO_FULL_HLD_CTRL = 1U << 9 ;

  // Field STOP_DET_IF_MASTER_ACTIVE: Master issues the STOP_DET interrupt irrespective of whether master is active or not
    const uint32_t I2C1_IC_CON_STOP_DET_IF_MASTER_ACTIVE = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register IC_TAR: I2C Target Address Register\n\n This register is 12 bits wide, and bits 31:12 are reserved. This register can be written to only when IC_ENABLE[0] is set to 0.\n\n Note: If the software or application is aware that the DW_apb_i2c is not using the TAR address for the pending commands in the Tx FIFO, then it is possible to update the TAR address even while the Tx FIFO has entries (IC_STATUS[2]= 0). - It is not necessary to perform any write to this register if DW_apb_i2c is enabled as an I2C slave only.
  static volatile uint32_t & I2C1_IC_TAR __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 4)) ;

  // Field IC_TAR: This is the target address for any master transaction. When transmitting a General Call, these bits are ignored. To generate a START BYTE, the CPU needs to write only once into these bits.\n\n If the IC_TAR and IC_SAR are the same, loopback exists but the FIFOs are shared between master and slave, so full loopback is not feasible. Only one direction loopback mode is supported (simplex), not duplex. A master cannot transmit to itself; it can transmit to only a slave.
    inline uint32_t I2C1_IC_TAR_IC_TAR (const uint32_t inValue) {return (inValue & 0x3FFU) << 0 ; }

  // Field GC_OR_START: If bit 11 (SPECIAL) is set to 1 and bit 13(Device-ID) is set to 0, then this bit indicates whether a General Call or START byte command is to be performed by the DW_apb_i2c. - 0: General Call Address - after issuing a General Call, only writes may be performed. Attempting to issue a read command results in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register. The DW_apb_i2c remains in General Call mode until the SPECIAL bit value (bit 11) is cleared. - 1: START BYTE Reset value: 0x0
    const uint32_t I2C1_IC_TAR_GC_OR_START = 1U << 10 ;

  // Field SPECIAL: This bit indicates whether software performs a Device-ID or General Call or START BYTE command. - 0: ignore bit 10 GC_OR_START and use IC_TAR normally - 1: perform special I2C command as specified in Device_ID or GC_OR_START bit Reset value: 0x0
    const uint32_t I2C1_IC_TAR_SPECIAL = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register IC_SAR: I2C Slave Address Register
  static volatile uint32_t & I2C1_IC_SAR __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 8)) ;

  // Field IC_SAR: The IC_SAR holds the slave address when the I2C is operating as a slave. For 7-bit addressing, only IC_SAR[6:0] is used.\n\n This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n Note: The default values cannot be any of the reserved address locations: that is, 0x00 to 0x07, or 0x78 to 0x7f. The correct operation of the device is not guaranteed if you program the IC_SAR or IC_TAR to a reserved value. Refer to <<table_I2C_firstbyte_bit_defs>> for a complete list of these reserved values.
    inline uint32_t I2C1_IC_SAR_IC_SAR (const uint32_t inValue) {return (inValue & 0x3FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IC_DATA_CMD: I2C Rx/Tx Data Buffer and Command Register; this is the register the CPU writes to when filling the TX FIFO and the CPU reads from when retrieving bytes from RX FIFO.\n\n The size of the register changes as follows:\n\n Write: - 11 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=1 - 9 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=0 Read: - 12 bits when IC_FIRST_DATA_BYTE_STATUS = 1 - 8 bits when IC_FIRST_DATA_BYTE_STATUS = 0 Note: In order for the DW_apb_i2c to continue acknowledging reads, a read command should be written for every byte that is to be received; otherwise the DW_apb_i2c will stop acknowledging.
  static volatile uint32_t & I2C1_IC_DATA_CMD __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 16)) ;

  // Field DAT: This register contains the data to be transmitted or received on the I2C bus. If you are writing to this register and want to perform a read, bits 7:0 (DAT) are ignored by the DW_apb_i2c. However, when you read this register, these bits return the value of data received on the DW_apb_i2c interface.\n\n Reset value: 0x0
    inline uint32_t I2C1_IC_DATA_CMD_DAT (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field CMD: This bit controls whether a read or a write is performed. This bit does not control the direction when the DW_apb_i2con acts as a slave. It controls only the direction when it acts as a master.\n\n When a command is entered in the TX FIFO, this bit distinguishes the write and read commands. In slave-receiver mode, this bit is a 'don't care' because writes to this register are not required. In slave-transmitter mode, a '0' indicates that the data in IC_DATA_CMD is to be transmitted.\n\n When programming this bit, you should remember the following: attempting to perform a read operation after a General Call command has been sent results in a TX_ABRT interrupt (bit 6 of the IC_RAW_INTR_STAT register), unless bit 11 (SPECIAL) in the IC_TAR register has been cleared. If a '1' is written to this bit after receiving a RD_REQ interrupt, then a TX_ABRT interrupt occurs.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_DATA_CMD_CMD = 1U << 8 ;

  // Field STOP: This bit controls whether a STOP is issued after the byte is sent or received.\n\n - 1 - STOP is issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master immediately tries to start a new transfer by issuing a START and arbitrating for the bus. - 0 - STOP is not issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master continues the current transfer by sending/receiving data bytes according to the value of the CMD bit. If the Tx FIFO is empty, the master holds the SCL line low and stalls the bus until a new command is available in the Tx FIFO. Reset value: 0x0
    const uint32_t I2C1_IC_DATA_CMD_STOP = 1U << 9 ;

  // Field RESTART: This bit controls whether a RESTART is issued before the byte is sent or received.\n\n 1 - If IC_RESTART_EN is 1, a RESTART is issued before the data is sent/received (according to the value of CMD), regardless of whether or not the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.\n\n 0 - If IC_RESTART_EN is 1, a RESTART is issued only if the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_DATA_CMD_RESTART = 1U << 10 ;

  // Field FIRST_DATA_BYTE: Indicates the first data byte received after the address phase for receive transfer in Master receiver or Slave receiver mode.\n\n Reset value : 0x0\n\n NOTE: In case of APB_DATA_WIDTH=8,\n\n 1. The user has to perform two APB Reads to IC_DATA_CMD in order to get status on 11 bit.\n\n 2. In order to read the 11 bit, the user has to perform the first data byte read [7:0] (offset 0x10) and then perform the second read [15:8] (offset 0x11) in order to know the status of 11 bit (whether the data received in previous read is a first data byte or not).\n\n 3. The 11th bit is an optional read field, user can ignore 2nd byte read [15:8] (offset 0x11) if not interested in FIRST_DATA_BYTE status.
    const uint32_t I2C1_IC_DATA_CMD_FIRST_DATA_BYTE = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register IC_SS_SCL_HCNT: Standard Speed I2C Clock SCL High Count Register
  static volatile uint32_t & I2C1_IC_SS_SCL_HCNT __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 20)) ;

  // Field IC_SS_SCL_HCNT: This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for standard speed. For more information, refer to 'IC_CLK Frequency Configuration'.\n\n This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. For designs with APB_DATA_WIDTH = 8, the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed.\n\n NOTE: This register must not be programmed to a value higher than 65525, because DW_apb_i2c uses a 16-bit counter to flag an I2C bus idle condition when this counter reaches a value of IC_SS_SCL_HCNT + 10.
    inline uint32_t I2C1_IC_SS_SCL_HCNT_IC_SS_SCL_HCNT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IC_SS_SCL_LCNT: Standard Speed I2C Clock SCL Low Count Register
  static volatile uint32_t & I2C1_IC_SS_SCL_LCNT __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 24)) ;

  // Field IC_SS_SCL_LCNT: This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for standard speed. For more information, refer to 'IC_CLK Frequency Configuration'\n\n This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n The minimum valid value is 8; hardware prevents values less than this being written, and if attempted, results in 8 being set. For designs with APB_DATA_WIDTH = 8, the order of programming is important to ensure the correct operation of DW_apb_i2c. The lower byte must be programmed first, and then the upper byte is programmed.
    inline uint32_t I2C1_IC_SS_SCL_LCNT_IC_SS_SCL_LCNT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IC_FS_SCL_HCNT: Fast Mode or Fast Mode Plus I2C Clock SCL High Count Register
  static volatile uint32_t & I2C1_IC_FS_SCL_HCNT __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 28)) ;

  // Field IC_FS_SCL_HCNT: This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for fast mode or fast mode plus. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. For more information, refer to 'IC_CLK Frequency Configuration'.\n\n This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE = standard. This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. For designs with APB_DATA_WIDTH == 8 the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed.
    inline uint32_t I2C1_IC_FS_SCL_HCNT_IC_FS_SCL_HCNT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IC_FS_SCL_LCNT: Fast Mode or Fast Mode Plus I2C Clock SCL Low Count Register
  static volatile uint32_t & I2C1_IC_FS_SCL_LCNT __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 32)) ;

  // Field IC_FS_SCL_LCNT: This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. For more information, refer to 'IC_CLK Frequency Configuration'.\n\n This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE = standard.\n\n This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n The minimum valid value is 8; hardware prevents values less than this being written, and if attempted results in 8 being set. For designs with APB_DATA_WIDTH = 8 the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed. If the value is less than 8 then the count value gets changed to 8.
    inline uint32_t I2C1_IC_FS_SCL_LCNT_IC_FS_SCL_LCNT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IC_INTR_STAT: I2C Interrupt Status Register\n\n Each bit in this register has a corresponding mask bit in the IC_INTR_MASK register. These bits are cleared by reading the matching interrupt clear register. The unmasked raw versions of these bits are available in the IC_RAW_INTR_STAT register.
  static volatile uint32_t & I2C1_IC_INTR_STAT __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 44)) ;

  // Field R_RX_UNDER: See IC_RAW_INTR_STAT for a detailed description of R_RX_UNDER bit.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_INTR_STAT_R_RX_UNDER = 1U << 0 ;

  // Field R_RX_OVER: See IC_RAW_INTR_STAT for a detailed description of R_RX_OVER bit.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_INTR_STAT_R_RX_OVER = 1U << 1 ;

  // Field R_RX_FULL: See IC_RAW_INTR_STAT for a detailed description of R_RX_FULL bit.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_INTR_STAT_R_RX_FULL = 1U << 2 ;

  // Field R_TX_OVER: See IC_RAW_INTR_STAT for a detailed description of R_TX_OVER bit.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_INTR_STAT_R_TX_OVER = 1U << 3 ;

  // Field R_TX_EMPTY: See IC_RAW_INTR_STAT for a detailed description of R_TX_EMPTY bit.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_INTR_STAT_R_TX_EMPTY = 1U << 4 ;

  // Field R_RD_REQ: See IC_RAW_INTR_STAT for a detailed description of R_RD_REQ bit.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_INTR_STAT_R_RD_REQ = 1U << 5 ;

  // Field R_TX_ABRT: See IC_RAW_INTR_STAT for a detailed description of R_TX_ABRT bit.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_INTR_STAT_R_TX_ABRT = 1U << 6 ;

  // Field R_RX_DONE: See IC_RAW_INTR_STAT for a detailed description of R_RX_DONE bit.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_INTR_STAT_R_RX_DONE = 1U << 7 ;

  // Field R_ACTIVITY: See IC_RAW_INTR_STAT for a detailed description of R_ACTIVITY bit.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_INTR_STAT_R_ACTIVITY = 1U << 8 ;

  // Field R_STOP_DET: See IC_RAW_INTR_STAT for a detailed description of R_STOP_DET bit.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_INTR_STAT_R_STOP_DET = 1U << 9 ;

  // Field R_START_DET: See IC_RAW_INTR_STAT for a detailed description of R_START_DET bit.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_INTR_STAT_R_START_DET = 1U << 10 ;

  // Field R_GEN_CALL: See IC_RAW_INTR_STAT for a detailed description of R_GEN_CALL bit.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_INTR_STAT_R_GEN_CALL = 1U << 11 ;

  // Field R_RESTART_DET: See IC_RAW_INTR_STAT for a detailed description of R_RESTART_DET bit.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_INTR_STAT_R_RESTART_DET = 1U << 12 ;

  // Field R_MASTER_ON_HOLD: See IC_RAW_INTR_STAT for a detailed description of R_MASTER_ON_HOLD bit.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_INTR_STAT_R_MASTER_ON_HOLD = 1U << 13 ;

//------------------------------------------------------------------------------

//---  Register IC_INTR_MASK: I2C Interrupt Mask Register.\n\n These bits mask their corresponding interrupt status bits. This register is active low; a value of 0 masks the interrupt, whereas a value of 1 unmasks the interrupt.
  static volatile uint32_t & I2C1_IC_INTR_MASK __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 48)) ;

  // Field M_RX_UNDER: This bit masks the R_RX_UNDER interrupt in IC_INTR_STAT register.\n\n Reset value: 0x1
    const uint32_t I2C1_IC_INTR_MASK_M_RX_UNDER = 1U << 0 ;

  // Field M_RX_OVER: This bit masks the R_RX_OVER interrupt in IC_INTR_STAT register.\n\n Reset value: 0x1
    const uint32_t I2C1_IC_INTR_MASK_M_RX_OVER = 1U << 1 ;

  // Field M_RX_FULL: This bit masks the R_RX_FULL interrupt in IC_INTR_STAT register.\n\n Reset value: 0x1
    const uint32_t I2C1_IC_INTR_MASK_M_RX_FULL = 1U << 2 ;

  // Field M_TX_OVER: This bit masks the R_TX_OVER interrupt in IC_INTR_STAT register.\n\n Reset value: 0x1
    const uint32_t I2C1_IC_INTR_MASK_M_TX_OVER = 1U << 3 ;

  // Field M_TX_EMPTY: This bit masks the R_TX_EMPTY interrupt in IC_INTR_STAT register.\n\n Reset value: 0x1
    const uint32_t I2C1_IC_INTR_MASK_M_TX_EMPTY = 1U << 4 ;

  // Field M_RD_REQ: This bit masks the R_RD_REQ interrupt in IC_INTR_STAT register.\n\n Reset value: 0x1
    const uint32_t I2C1_IC_INTR_MASK_M_RD_REQ = 1U << 5 ;

  // Field M_TX_ABRT: This bit masks the R_TX_ABRT interrupt in IC_INTR_STAT register.\n\n Reset value: 0x1
    const uint32_t I2C1_IC_INTR_MASK_M_TX_ABRT = 1U << 6 ;

  // Field M_RX_DONE: This bit masks the R_RX_DONE interrupt in IC_INTR_STAT register.\n\n Reset value: 0x1
    const uint32_t I2C1_IC_INTR_MASK_M_RX_DONE = 1U << 7 ;

  // Field M_ACTIVITY: This bit masks the R_ACTIVITY interrupt in IC_INTR_STAT register.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_INTR_MASK_M_ACTIVITY = 1U << 8 ;

  // Field M_STOP_DET: This bit masks the R_STOP_DET interrupt in IC_INTR_STAT register.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_INTR_MASK_M_STOP_DET = 1U << 9 ;

  // Field M_START_DET: This bit masks the R_START_DET interrupt in IC_INTR_STAT register.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_INTR_MASK_M_START_DET = 1U << 10 ;

  // Field M_GEN_CALL: This bit masks the R_GEN_CALL interrupt in IC_INTR_STAT register.\n\n Reset value: 0x1
    const uint32_t I2C1_IC_INTR_MASK_M_GEN_CALL = 1U << 11 ;

  // Field M_RESTART_DET: This bit masks the R_RESTART_DET interrupt in IC_INTR_STAT register.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_INTR_MASK_M_RESTART_DET = 1U << 12 ;

  // Field M_MASTER_ON_HOLD_READ_ONLY: This M_MASTER_ON_HOLD_read_only bit masks the R_MASTER_ON_HOLD interrupt in IC_INTR_STAT register.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_INTR_MASK_M_MASTER_ON_HOLD_READ_ONLY = 1U << 13 ;

//------------------------------------------------------------------------------

//---  Register IC_RAW_INTR_STAT: I2C Raw Interrupt Status Register\n\n Unlike the IC_INTR_STAT register, these bits are not masked so they always show the true status of the DW_apb_i2c.
  static volatile uint32_t & I2C1_IC_RAW_INTR_STAT __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 52)) ;

  // Field RX_UNDER: Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD register. If the module is disabled (IC_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_RAW_INTR_STAT_RX_UNDER = 1U << 0 ;

  // Field RX_OVER: Set if the receive buffer is completely filled to IC_RX_BUFFER_DEPTH and an additional byte is received from an external I2C device. The DW_apb_i2c acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (IC_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.\n\n Note: If bit 9 of the IC_CON register (RX_FIFO_FULL_HLD_CTRL) is programmed to HIGH, then the RX_OVER interrupt never occurs, because the Rx FIFO never overflows.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_RAW_INTR_STAT_RX_OVER = 1U << 1 ;

  // Field RX_FULL: Set when the receive buffer reaches or goes above the RX_TL threshold in the IC_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (IC_ENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the IC_ENABLE bit 0 is programmed with a 0, regardless of the activity that continues.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_RAW_INTR_STAT_RX_FULL = 1U << 2 ;

  // Field TX_OVER: Set during transmit if the transmit buffer is filled to IC_TX_BUFFER_DEPTH and the processor attempts to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_RAW_INTR_STAT_TX_OVER = 1U << 3 ;

  // Field TX_EMPTY: The behavior of the TX_EMPTY interrupt status differs based on the TX_EMPTY_CTRL selection in the IC_CON register. - When TX_EMPTY_CTRL = 0: This bit is set to 1 when the transmit buffer is at or below the threshold value set in the IC_TX_TL register. - When TX_EMPTY_CTRL = 1: This bit is set to 1 when the transmit buffer is at or below the threshold value set in the IC_TX_TL register and the transmission of the address/data from the internal shift register for the most recently popped command is completed. It is automatically cleared by hardware when the buffer level goes above the threshold. When IC_ENABLE[0] is set to 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer any activity, then with ic_en=0, this bit is set to 0.\n\n Reset value: 0x0.
    const uint32_t I2C1_IC_RAW_INTR_STAT_TX_EMPTY = 1U << 4 ;

  // Field RD_REQ: This bit is set to 1 when DW_apb_i2c is acting as a slave and another I2C master is attempting to read data from DW_apb_i2c. The DW_apb_i2c holds the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the IC_DATA_CMD register. This bit is set to 0 just after the processor reads the IC_CLR_RD_REQ register.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_RAW_INTR_STAT_RD_REQ = 1U << 5 ;

  // Field TX_ABRT: This bit indicates if DW_apb_i2c, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a 'transmit abort'. When this bit is set to 1, the IC_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places.\n\n Note: The DW_apb_i2c flushes/resets/empties the TX_FIFO and RX_FIFO whenever there is a transmit abort caused by any of the events tracked by the IC_TX_ABRT_SOURCE register. The FIFOs remains in this flushed state until the register IC_CLR_TX_ABRT is read. Once this read is performed, the Tx FIFO is then ready to accept more data bytes from the APB interface.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_RAW_INTR_STAT_TX_ABRT = 1U << 6 ;

  // Field RX_DONE: When the DW_apb_i2c is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_RAW_INTR_STAT_RX_DONE = 1U << 7 ;

  // Field ACTIVITY: This bit captures DW_apb_i2c activity and stays set until it is cleared. There are four ways to clear it: - Disabling the DW_apb_i2c - Reading the IC_CLR_ACTIVITY register - Reading the IC_CLR_INTR register - System reset Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the DW_apb_i2c module is idle, this bit remains set until cleared, indicating that there was activity on the bus.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_RAW_INTR_STAT_ACTIVITY = 1U << 8 ;

  // Field STOP_DET: Indicates whether a STOP condition has occurred on the I2C interface regardless of whether DW_apb_i2c is operating in slave or master mode.\n\n In Slave Mode: - If IC_CON[7]=1'b1 (STOP_DET_IFADDRESSED), the STOP_DET interrupt will be issued only if slave is addressed. Note: During a general call address, this slave does not issue a STOP_DET interrupt if STOP_DET_IF_ADDRESSED=1'b1, even if the slave responds to the general call address by generating ACK. The STOP_DET interrupt is generated only when the transmitted address matches the slave address (SAR). - If IC_CON[7]=1'b0 (STOP_DET_IFADDRESSED), the STOP_DET interrupt is issued irrespective of whether it is being addressed. In Master Mode: - If IC_CON[10]=1'b1 (STOP_DET_IF_MASTER_ACTIVE),the STOP_DET interrupt will be issued only if Master is active. - If IC_CON[10]=1'b0 (STOP_DET_IFADDRESSED),the STOP_DET interrupt will be issued irrespective of whether master is active or not. Reset value: 0x0
    const uint32_t I2C1_IC_RAW_INTR_STAT_STOP_DET = 1U << 9 ;

  // Field START_DET: Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether DW_apb_i2c is operating in slave or master mode.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_RAW_INTR_STAT_START_DET = 1U << 10 ;

  // Field GEN_CALL: Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling DW_apb_i2c or when the CPU reads bit 0 of the IC_CLR_GEN_CALL register. DW_apb_i2c stores the received data in the Rx buffer.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_RAW_INTR_STAT_GEN_CALL = 1U << 11 ;

  // Field RESTART_DET: Indicates whether a RESTART condition has occurred on the I2C interface when DW_apb_i2c is operating in Slave mode and the slave is being addressed. Enabled only when IC_SLV_RESTART_DET_EN=1.\n\n Note: However, in high-speed mode or during a START BYTE transfer, the RESTART comes before the address field as per the I2C protocol. In this case, the slave is not the addressed slave when the RESTART is issued, therefore DW_apb_i2c does not generate the RESTART_DET interrupt.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_RAW_INTR_STAT_RESTART_DET = 1U << 12 ;

  // Field MASTER_ON_HOLD: Indicates whether master is holding the bus and TX FIFO is empty. Enabled only when I2C_DYNAMIC_TAR_UPDATE=1 and IC_EMPTYFIFO_HOLD_MASTER_EN=1.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_RAW_INTR_STAT_MASTER_ON_HOLD = 1U << 13 ;

//------------------------------------------------------------------------------

//---  Register IC_RX_TL: I2C Receive FIFO Threshold Register
  static volatile uint32_t & I2C1_IC_RX_TL __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 56)) ;

  // Field RX_TL: Receive FIFO Threshold Level.\n\n Controls the level of entries (or above) that triggers the RX_FULL interrupt (bit 2 in IC_RAW_INTR_STAT register). The valid range is 0-255, with the additional restriction that hardware does not allow this value to be set to a value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 1 entry, and a value of 255 sets the threshold for 256 entries.
    inline uint32_t I2C1_IC_RX_TL_RX_TL (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IC_TX_TL: I2C Transmit FIFO Threshold Register
  static volatile uint32_t & I2C1_IC_TX_TL __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 60)) ;

  // Field TX_TL: Transmit FIFO Threshold Level.\n\n Controls the level of entries (or below) that trigger the TX_EMPTY interrupt (bit 4 in IC_RAW_INTR_STAT register). The valid range is 0-255, with the additional restriction that it may not be set to value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 0 entries, and a value of 255 sets the threshold for 255 entries.
    inline uint32_t I2C1_IC_TX_TL_TX_TL (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IC_CLR_INTR: Clear Combined and Individual Interrupt Register
  static volatile uint32_t & I2C1_IC_CLR_INTR __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 64)) ;

  // Field CLR_INTR: Read this register to clear the combined interrupt, all individual interrupts, and the IC_TX_ABRT_SOURCE register. This bit does not clear hardware clearable interrupts but software clearable interrupts. Refer to Bit 9 of the IC_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_CLR_INTR_CLR_INTR = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IC_CLR_RX_UNDER: Clear RX_UNDER Interrupt Register
  static volatile uint32_t & I2C1_IC_CLR_RX_UNDER __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 68)) ;

  // Field CLR_RX_UNDER: Read this register to clear the RX_UNDER interrupt (bit 0) of the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_CLR_RX_UNDER_CLR_RX_UNDER = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IC_CLR_RX_OVER: Clear RX_OVER Interrupt Register
  static volatile uint32_t & I2C1_IC_CLR_RX_OVER __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 72)) ;

  // Field CLR_RX_OVER: Read this register to clear the RX_OVER interrupt (bit 1) of the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_CLR_RX_OVER_CLR_RX_OVER = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IC_CLR_TX_OVER: Clear TX_OVER Interrupt Register
  static volatile uint32_t & I2C1_IC_CLR_TX_OVER __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 76)) ;

  // Field CLR_TX_OVER: Read this register to clear the TX_OVER interrupt (bit 3) of the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_CLR_TX_OVER_CLR_TX_OVER = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IC_CLR_RD_REQ: Clear RD_REQ Interrupt Register
  static volatile uint32_t & I2C1_IC_CLR_RD_REQ __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 80)) ;

  // Field CLR_RD_REQ: Read this register to clear the RD_REQ interrupt (bit 5) of the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_CLR_RD_REQ_CLR_RD_REQ = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IC_CLR_TX_ABRT: Clear TX_ABRT Interrupt Register
  static volatile uint32_t & I2C1_IC_CLR_TX_ABRT __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 84)) ;

  // Field CLR_TX_ABRT: Read this register to clear the TX_ABRT interrupt (bit 6) of the IC_RAW_INTR_STAT register, and the IC_TX_ABRT_SOURCE register. This also releases the TX FIFO from the flushed/reset state, allowing more writes to the TX FIFO. Refer to Bit 9 of the IC_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_CLR_TX_ABRT_CLR_TX_ABRT = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IC_CLR_RX_DONE: Clear RX_DONE Interrupt Register
  static volatile uint32_t & I2C1_IC_CLR_RX_DONE __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 88)) ;

  // Field CLR_RX_DONE: Read this register to clear the RX_DONE interrupt (bit 7) of the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_CLR_RX_DONE_CLR_RX_DONE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IC_CLR_ACTIVITY: Clear ACTIVITY Interrupt Register
  static volatile uint32_t & I2C1_IC_CLR_ACTIVITY __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 92)) ;

  // Field CLR_ACTIVITY: Reading this register clears the ACTIVITY interrupt if the I2C is not active anymore. If the I2C module is still active on the bus, the ACTIVITY interrupt bit continues to be set. It is automatically cleared by hardware if the module is disabled and if there is no further activity on the bus. The value read from this register to get status of the ACTIVITY interrupt (bit 8) of the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_CLR_ACTIVITY_CLR_ACTIVITY = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IC_CLR_STOP_DET: Clear STOP_DET Interrupt Register
  static volatile uint32_t & I2C1_IC_CLR_STOP_DET __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 96)) ;

  // Field CLR_STOP_DET: Read this register to clear the STOP_DET interrupt (bit 9) of the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_CLR_STOP_DET_CLR_STOP_DET = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IC_CLR_START_DET: Clear START_DET Interrupt Register
  static volatile uint32_t & I2C1_IC_CLR_START_DET __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 100)) ;

  // Field CLR_START_DET: Read this register to clear the START_DET interrupt (bit 10) of the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_CLR_START_DET_CLR_START_DET = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IC_CLR_GEN_CALL: Clear GEN_CALL Interrupt Register
  static volatile uint32_t & I2C1_IC_CLR_GEN_CALL __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 104)) ;

  // Field CLR_GEN_CALL: Read this register to clear the GEN_CALL interrupt (bit 11) of IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_CLR_GEN_CALL_CLR_GEN_CALL = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IC_ENABLE: I2C Enable Register
  static volatile uint32_t & I2C1_IC_ENABLE __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 108)) ;

  // Field ENABLE: Controls whether the DW_apb_i2c is enabled. - 0: Disables DW_apb_i2c (TX and RX FIFOs are held in an erased state) - 1: Enables DW_apb_i2c Software can disable DW_apb_i2c while it is active. However, it is important that care be taken to ensure that DW_apb_i2c is disabled properly. A recommended procedure is described in 'Disabling DW_apb_i2c'.\n\n When DW_apb_i2c is disabled, the following occurs: - The TX FIFO and RX FIFO get flushed. - Status bits in the IC_INTR_STAT register are still active until DW_apb_i2c goes into IDLE state. If the module is transmitting, it stops as well as deletes the contents of the transmit buffer after the current transfer is complete. If the module is receiving, the DW_apb_i2c stops the current transfer at the end of the current byte and does not acknowledge the transfer.\n\n In systems with asynchronous pclk and ic_clk when IC_CLK_TYPE parameter set to asynchronous (1), there is a two ic_clk delay when enabling or disabling the DW_apb_i2c. For a detailed description on how to disable DW_apb_i2c, refer to 'Disabling DW_apb_i2c'\n\n Reset value: 0x0
    const uint32_t I2C1_IC_ENABLE_ENABLE = 1U << 0 ;

  // Field ABORT: When set, the controller initiates the transfer abort. - 0: ABORT not initiated or ABORT done - 1: ABORT operation in progress The software can abort the I2C transfer in master mode by setting this bit. The software can set this bit only when ENABLE is already set; otherwise, the controller ignores any write to ABORT bit. The software cannot clear the ABORT bit once set. In response to an ABORT, the controller issues a STOP and flushes the Tx FIFO after completing the current transfer, then sets the TX_ABORT interrupt after the abort operation. The ABORT bit is cleared automatically after the abort operation.\n\n For a detailed description on how to abort I2C transfers, refer to 'Aborting I2C Transfers'.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_ENABLE_ABORT = 1U << 1 ;

  // Field TX_CMD_BLOCK: In Master mode: - 1'b1: Blocks the transmission of data on I2C bus even if Tx FIFO has data to transmit. - 1'b0: The transmission of data starts on I2C bus automatically, as soon as the first data is available in the Tx FIFO. Note: To block the execution of Master commands, set the TX_CMD_BLOCK bit only when Tx FIFO is empty (IC_STATUS[2]==1) and Master is in Idle state (IC_STATUS[5] == 0). Any further commands put in the Tx FIFO are not executed until TX_CMD_BLOCK bit is unset. Reset value: IC_TX_CMD_BLOCK_DEFAULT
    const uint32_t I2C1_IC_ENABLE_TX_CMD_BLOCK = 1U << 2 ;

//------------------------------------------------------------------------------

//---  Register IC_STATUS: I2C Status Register\n\n This is a read-only register used to indicate the current transfer status and FIFO status. The status register may be read at any time. None of the bits in this register request an interrupt.\n\n When the I2C is disabled by writing 0 in bit 0 of the IC_ENABLE register: - Bits 1 and 2 are set to 1 - Bits 3 and 10 are set to 0 When the master or slave state machines goes to idle and ic_en=0: - Bits 5 and 6 are set to 0
  static volatile uint32_t & I2C1_IC_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 112)) ;

  // Field ACTIVITY: I2C Activity Status. Reset value: 0x0
    const uint32_t I2C1_IC_STATUS_ACTIVITY = 1U << 0 ;

  // Field TFNF: Transmit FIFO Not Full. Set when the transmit FIFO contains one or more empty locations, and is cleared when the FIFO is full. - 0: Transmit FIFO is full - 1: Transmit FIFO is not full Reset value: 0x1
    const uint32_t I2C1_IC_STATUS_TFNF = 1U << 1 ;

  // Field TFE: Transmit FIFO Completely Empty. When the transmit FIFO is completely empty, this bit is set. When it contains one or more valid entries, this bit is cleared. This bit field does not request an interrupt. - 0: Transmit FIFO is not empty - 1: Transmit FIFO is empty Reset value: 0x1
    const uint32_t I2C1_IC_STATUS_TFE = 1U << 2 ;

  // Field RFNE: Receive FIFO Not Empty. This bit is set when the receive FIFO contains one or more entries; it is cleared when the receive FIFO is empty. - 0: Receive FIFO is empty - 1: Receive FIFO is not empty Reset value: 0x0
    const uint32_t I2C1_IC_STATUS_RFNE = 1U << 3 ;

  // Field RFF: Receive FIFO Completely Full. When the receive FIFO is completely full, this bit is set. When the receive FIFO contains one or more empty location, this bit is cleared. - 0: Receive FIFO is not full - 1: Receive FIFO is full Reset value: 0x0
    const uint32_t I2C1_IC_STATUS_RFF = 1U << 4 ;

  // Field MST_ACTIVITY: Master FSM Activity Status. When the Master Finite State Machine (FSM) is not in the IDLE state, this bit is set. - 0: Master FSM is in IDLE state so the Master part of DW_apb_i2c is not Active - 1: Master FSM is not in IDLE state so the Master part of DW_apb_i2c is Active Note: IC_STATUS[0]-that is, ACTIVITY bit-is the OR of SLV_ACTIVITY and MST_ACTIVITY bits.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_STATUS_MST_ACTIVITY = 1U << 5 ;

  // Field SLV_ACTIVITY: Slave FSM Activity Status. When the Slave Finite State Machine (FSM) is not in the IDLE state, this bit is set. - 0: Slave FSM is in IDLE state so the Slave part of DW_apb_i2c is not Active - 1: Slave FSM is not in IDLE state so the Slave part of DW_apb_i2c is Active Reset value: 0x0
    const uint32_t I2C1_IC_STATUS_SLV_ACTIVITY = 1U << 6 ;

//------------------------------------------------------------------------------

//---  Register IC_TXFLR: I2C Transmit FIFO Level Register This register contains the number of valid data entries in the transmit FIFO buffer. It is cleared whenever: - The I2C is disabled - There is a transmit abort - that is, TX_ABRT bit is set in the IC_RAW_INTR_STAT register - The slave bulk transmit mode is aborted The register increments whenever data is placed into the transmit FIFO and decrements when data is taken from the transmit FIFO.
  static volatile uint32_t & I2C1_IC_TXFLR __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 116)) ;

  // Field TXFLR: Transmit FIFO Level. Contains the number of valid data entries in the transmit FIFO.\n\n Reset value: 0x0
    inline uint32_t I2C1_IC_TXFLR_TXFLR (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IC_RXFLR: I2C Receive FIFO Level Register This register contains the number of valid data entries in the receive FIFO buffer. It is cleared whenever: - The I2C is disabled - Whenever there is a transmit abort caused by any of the events tracked in IC_TX_ABRT_SOURCE The register increments whenever data is placed into the receive FIFO and decrements when data is taken from the receive FIFO.
  static volatile uint32_t & I2C1_IC_RXFLR __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 120)) ;

  // Field RXFLR: Receive FIFO Level. Contains the number of valid data entries in the receive FIFO.\n\n Reset value: 0x0
    inline uint32_t I2C1_IC_RXFLR_RXFLR (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IC_SDA_HOLD: I2C SDA Hold Time Length Register\n\n The bits [15:0] of this register are used to control the hold time of SDA during transmit in both slave and master mode (after SCL goes from HIGH to LOW).\n\n The bits [23:16] of this register are used to extend the SDA transition (if any) whenever SCL is HIGH in the receiver in either master or slave mode.\n\n Writes to this register succeed only when IC_ENABLE[0]=0.\n\n The values in this register are in units of ic_clk period. The value programmed in IC_SDA_TX_HOLD must be greater than the minimum hold time in each mode one cycle in master mode, seven cycles in slave mode for the value to be implemented.\n\n The programmed SDA hold time during transmit (IC_SDA_TX_HOLD) cannot exceed at any time the duration of the low part of scl. Therefore the programmed value cannot be larger than N_SCL_LOW-2, where N_SCL_LOW is the duration of the low part of the scl period measured in ic_clk cycles.
  static volatile uint32_t & I2C1_IC_SDA_HOLD __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 124)) ;

  // Field IC_SDA_TX_HOLD: Sets the required SDA hold time in units of ic_clk period, when DW_apb_i2c acts as a transmitter.\n\n Reset value: IC_DEFAULT_SDA_HOLD[15:0].
    inline uint32_t I2C1_IC_SDA_HOLD_IC_SDA_TX_HOLD (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field IC_SDA_RX_HOLD: Sets the required SDA hold time in units of ic_clk period, when DW_apb_i2c acts as a receiver.\n\n Reset value: IC_DEFAULT_SDA_HOLD[23:16].
    inline uint32_t I2C1_IC_SDA_HOLD_IC_SDA_RX_HOLD (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register IC_TX_ABRT_SOURCE: I2C Transmit Abort Source Register\n\n This register has 32 bits that indicate the source of the TX_ABRT bit. Except for Bit 9, this register is cleared whenever the IC_CLR_TX_ABRT register or the IC_CLR_INTR register is read. To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; RESTART must be enabled (IC_CON[5]=1), the SPECIAL bit must be cleared (IC_TAR[11]), or the GC_OR_START bit must be cleared (IC_TAR[10]).\n\n Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, Bit 9 clears for one cycle and is then re-asserted.
  static volatile uint32_t & I2C1_IC_TX_ABRT_SOURCE __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 128)) ;

  // Field ABRT_7B_ADDR_NOACK: This field indicates that the Master is in 7-bit addressing mode and the address sent was not acknowledged by any slave.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter or Master-Receiver
    const uint32_t I2C1_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK = 1U << 0 ;

  // Field ABRT_10ADDR1_NOACK: This field indicates that the Master is in 10-bit address mode and the first 10-bit address byte was not acknowledged by any slave.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter or Master-Receiver
    const uint32_t I2C1_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK = 1U << 1 ;

  // Field ABRT_10ADDR2_NOACK: This field indicates that the Master is in 10-bit address mode and that the second address byte of the 10-bit address was not acknowledged by any slave.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter or Master-Receiver
    const uint32_t I2C1_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK = 1U << 2 ;

  // Field ABRT_TXDATA_NOACK: This field indicates the master-mode only bit. When the master receives an acknowledgement for the address, but when it sends data byte(s) following the address, it did not receive an acknowledge from the remote slave(s).\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter
    const uint32_t I2C1_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK = 1U << 3 ;

  // Field ABRT_GCALL_NOACK: This field indicates that DW_apb_i2c in master mode has sent a General Call and no slave on the bus acknowledged the General Call.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter
    const uint32_t I2C1_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK = 1U << 4 ;

  // Field ABRT_GCALL_READ: This field indicates that DW_apb_i2c in the master mode has sent a General Call but the user programmed the byte following the General Call to be a read from the bus (IC_DATA_CMD[9] is set to 1).\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter
    const uint32_t I2C1_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ = 1U << 5 ;

  // Field ABRT_HS_ACKDET: This field indicates that the Master is in High Speed mode and the High Speed Master code was acknowledged (wrong behavior).\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master
    const uint32_t I2C1_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET = 1U << 6 ;

  // Field ABRT_SBYTE_ACKDET: This field indicates that the Master has sent a START Byte and the START Byte was acknowledged (wrong behavior).\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master
    const uint32_t I2C1_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET = 1U << 7 ;

  // Field ABRT_HS_NORSTRT: This field indicates that the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the user is trying to use the master to transfer data in High Speed mode.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter or Master-Receiver
    const uint32_t I2C1_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT = 1U << 8 ;

  // Field ABRT_SBYTE_NORSTRT: To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; restart must be enabled (IC_CON[5]=1), the SPECIAL bit must be cleared (IC_TAR[11]), or the GC_OR_START bit must be cleared (IC_TAR[10]). Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, bit 9 clears for one cycle and then gets reasserted. When this field is set to 1, the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the user is trying to send a START Byte.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master
    const uint32_t I2C1_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT = 1U << 9 ;

  // Field ABRT_10B_RD_NORSTRT: This field indicates that the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the master sends a read command in 10-bit addressing mode.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Receiver
    const uint32_t I2C1_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT = 1U << 10 ;

  // Field ABRT_MASTER_DIS: This field indicates that the User tries to initiate a Master operation with the Master mode disabled.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter or Master-Receiver
    const uint32_t I2C1_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS = 1U << 11 ;

  // Field ARB_LOST: This field specifies that the Master has lost arbitration, or if IC_TX_ABRT_SOURCE[14] is also set, then the slave transmitter has lost arbitration.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter or Slave-Transmitter
    const uint32_t I2C1_IC_TX_ABRT_SOURCE_ARB_LOST = 1U << 12 ;

  // Field ABRT_SLVFLUSH_TXFIFO: This field specifies that the Slave has received a read command and some data exists in the TX FIFO, so the slave issues a TX_ABRT interrupt to flush old data in TX FIFO.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Slave-Transmitter
    const uint32_t I2C1_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO = 1U << 13 ;

  // Field ABRT_SLV_ARBLOST: This field indicates that a Slave has lost the bus while transmitting data to a remote master. IC_TX_ABRT_SOURCE[12] is set at the same time. Note: Even though the slave never 'owns' the bus, something could go wrong on the bus. This is a fail safe check. For instance, during a data transmission at the low-to-high transition of SCL, if what is on the data bus is not what is supposed to be transmitted, then DW_apb_i2c no longer own the bus.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Slave-Transmitter
    const uint32_t I2C1_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST = 1U << 14 ;

  // Field ABRT_SLVRD_INTX: 1: When the processor side responds to a slave mode request for data to be transmitted to a remote master and user writes a 1 in CMD (bit 8) of IC_DATA_CMD register.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Slave-Transmitter
    const uint32_t I2C1_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX = 1U << 15 ;

  // Field ABRT_USER_ABRT: This is a master-mode-only bit. Master has detected the transfer abort (IC_ENABLE[1])\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter
    const uint32_t I2C1_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT = 1U << 16 ;

  // Field TX_FLUSH_CNT: This field indicates the number of Tx FIFO Data Commands which are flushed due to TX_ABRT interrupt. It is cleared whenever I2C is disabled.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter or Slave-Transmitter
    inline uint32_t I2C1_IC_TX_ABRT_SOURCE_TX_FLUSH_CNT (const uint32_t inValue) {return (inValue & 0x1FFU) << 23 ; }

//------------------------------------------------------------------------------

//---  Register IC_SLV_DATA_NACK_ONLY: Generate Slave Data NACK Register\n\n The register is used to generate a NACK for the data part of a transfer when DW_apb_i2c is acting as a slave-receiver. This register only exists when the IC_SLV_DATA_NACK_ONLY parameter is set to 1. When this parameter disabled, this register does not exist and writing to the register's address has no effect.\n\n A write can occur on this register if both of the following conditions are met: - DW_apb_i2c is disabled (IC_ENABLE[0] = 0) - Slave part is inactive (IC_STATUS[6] = 0) Note: The IC_STATUS[6] is a register read-back location for the internal slv_activity signal; the user should poll this before writing the ic_slv_data_nack_only bit.
  static volatile uint32_t & I2C1_IC_SLV_DATA_NACK_ONLY __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 132)) ;

  // Field NACK: Generate NACK. This NACK generation only occurs when DW_apb_i2c is a slave-receiver. If this register is set to a value of 1, it can only generate a NACK after a data byte is received; hence, the data transfer is aborted and the data received is not pushed to the receive buffer.\n\n When the register is set to a value of 0, it generates NACK/ACK, depending on normal criteria. - 1: generate NACK after data byte received - 0: generate NACK/ACK normally Reset value: 0x0
    const uint32_t I2C1_IC_SLV_DATA_NACK_ONLY_NACK = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IC_DMA_CR: DMA Control Register\n\n The register is used to enable the DMA Controller interface operation. There is a separate bit for transmit and receive. This can be programmed regardless of the state of IC_ENABLE.
  static volatile uint32_t & I2C1_IC_DMA_CR __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 136)) ;

  // Field RDMAE: Receive DMA Enable. This bit enables/disables the receive FIFO DMA channel. Reset value: 0x0
    const uint32_t I2C1_IC_DMA_CR_RDMAE = 1U << 0 ;

  // Field TDMAE: Transmit DMA Enable. This bit enables/disables the transmit FIFO DMA channel. Reset value: 0x0
    const uint32_t I2C1_IC_DMA_CR_TDMAE = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register IC_DMA_TDLR: DMA Transmit Data Level Register
  static volatile uint32_t & I2C1_IC_DMA_TDLR __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 140)) ;

  // Field DMATDL: Transmit Data Level. This bit field controls the level at which a DMA request is made by the transmit logic. It is equal to the watermark level; that is, the dma_tx_req signal is generated when the number of valid data entries in the transmit FIFO is equal to or below this field value, and TDMAE = 1.\n\n Reset value: 0x0
    inline uint32_t I2C1_IC_DMA_TDLR_DMATDL (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IC_DMA_RDLR: I2C Receive Data Level Register
  static volatile uint32_t & I2C1_IC_DMA_RDLR __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 144)) ;

  // Field DMARDL: Receive Data Level. This bit field controls the level at which a DMA request is made by the receive logic. The watermark level = DMARDL+1; that is, dma_rx_req is generated when the number of valid data entries in the receive FIFO is equal to or more than this field value + 1, and RDMAE =1. For instance, when DMARDL is 0, then dma_rx_req is asserted when 1 or more data entries are present in the receive FIFO.\n\n Reset value: 0x0
    inline uint32_t I2C1_IC_DMA_RDLR_DMARDL (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IC_SDA_SETUP: I2C SDA Setup Register\n\n This register controls the amount of time delay (in terms of number of ic_clk clock periods) introduced in the rising edge of SCL - relative to SDA changing - when DW_apb_i2c services a read request in a slave-transmitter operation. The relevant I2C requirement is tSU:DAT (note 4) as detailed in the I2C Bus Specification. This register must be programmed with a value equal to or greater than 2.\n\n Writes to this register succeed only when IC_ENABLE[0] = 0.\n\n Note: The length of setup time is calculated using [(IC_SDA_SETUP - 1) * (ic_clk_period)], so if the user requires 10 ic_clk periods of setup time, they should program a value of 11. The IC_SDA_SETUP register is only used by the DW_apb_i2c when operating as a slave transmitter.
  static volatile uint32_t & I2C1_IC_SDA_SETUP __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 148)) ;

  // Field SDA_SETUP: SDA Setup. It is recommended that if the required delay is 1000ns, then for an ic_clk frequency of 10 MHz, IC_SDA_SETUP should be programmed to a value of 11. IC_SDA_SETUP must be programmed with a minimum value of 2.
    inline uint32_t I2C1_IC_SDA_SETUP_SDA_SETUP (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IC_ACK_GENERAL_CALL: I2C ACK General Call Register\n\n The register controls whether DW_apb_i2c responds with a ACK or NACK when it receives an I2C General Call address.\n\n This register is applicable only when the DW_apb_i2c is in slave mode.
  static volatile uint32_t & I2C1_IC_ACK_GENERAL_CALL __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 152)) ;

  // Field ACK_GEN_CALL: ACK General Call. When set to 1, DW_apb_i2c responds with a ACK (by asserting ic_data_oe) when it receives a General Call. Otherwise, DW_apb_i2c responds with a NACK (by negating ic_data_oe).
    const uint32_t I2C1_IC_ACK_GENERAL_CALL_ACK_GEN_CALL = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IC_ENABLE_STATUS: I2C Enable Status Register\n\n The register is used to report the DW_apb_i2c hardware status when the IC_ENABLE[0] register is set from 1 to 0; that is, when DW_apb_i2c is disabled.\n\n If IC_ENABLE[0] has been set to 1, bits 2:1 are forced to 0, and bit 0 is forced to 1.\n\n If IC_ENABLE[0] has been set to 0, bits 2:1 is only be valid as soon as bit 0 is read as '0'.\n\n Note: When IC_ENABLE[0] has been set to 0, a delay occurs for bit 0 to be read as 0 because disabling the DW_apb_i2c depends on I2C bus activities.
  static volatile uint32_t & I2C1_IC_ENABLE_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 156)) ;

  // Field IC_EN: ic_en Status. This bit always reflects the value driven on the output port ic_en. - When read as 1, DW_apb_i2c is deemed to be in an enabled state. - When read as 0, DW_apb_i2c is deemed completely inactive. Note: The CPU can safely read this bit anytime. When this bit is read as 0, the CPU can safely read SLV_RX_DATA_LOST (bit 2) and SLV_DISABLED_WHILE_BUSY (bit 1).\n\n Reset value: 0x0
    const uint32_t I2C1_IC_ENABLE_STATUS_IC_EN = 1U << 0 ;

  // Field SLV_DISABLED_WHILE_BUSY: Slave Disabled While Busy (Transmit, Receive). This bit indicates if a potential or active Slave operation has been aborted due to the setting bit 0 of the IC_ENABLE register from 1 to 0. This bit is set when the CPU writes a 0 to the IC_ENABLE register while:\n\n (a) DW_apb_i2c is receiving the address byte of the Slave-Transmitter operation from a remote master;\n\n OR,\n\n (b) address and data bytes of the Slave-Receiver operation from a remote master.\n\n When read as 1, DW_apb_i2c is deemed to have forced a NACK during any part of an I2C transfer, irrespective of whether the I2C address matches the slave address set in DW_apb_i2c (IC_SAR register) OR if the transfer is completed before IC_ENABLE is set to 0 but has not taken effect.\n\n Note: If the remote I2C master terminates the transfer with a STOP condition before the DW_apb_i2c has a chance to NACK a transfer, and IC_ENABLE[0] has been set to 0, then this bit will also be set to 1.\n\n When read as 0, DW_apb_i2c is deemed to have been disabled when there is master activity, or when the I2C bus is idle.\n\n Note: The CPU can safely read this bit when IC_EN (bit 0) is read as 0.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY = 1U << 1 ;

  // Field SLV_RX_DATA_LOST: Slave Received Data Lost. This bit indicates if a Slave-Receiver operation has been aborted with at least one data byte received from an I2C transfer due to the setting bit 0 of IC_ENABLE from 1 to 0. When read as 1, DW_apb_i2c is deemed to have been actively engaged in an aborted I2C transfer (with matching address) and the data phase of the I2C transfer has been entered, even though a data byte has been responded with a NACK.\n\n Note: If the remote I2C master terminates the transfer with a STOP condition before the DW_apb_i2c has a chance to NACK a transfer, and IC_ENABLE[0] has been set to 0, then this bit is also set to 1.\n\n When read as 0, DW_apb_i2c is deemed to have been disabled without being actively involved in the data phase of a Slave-Receiver transfer.\n\n Note: The CPU can safely read this bit when IC_EN (bit 0) is read as 0.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_ENABLE_STATUS_SLV_RX_DATA_LOST = 1U << 2 ;

//------------------------------------------------------------------------------

//---  Register IC_FS_SPKLEN: I2C SS, FS or FM+ spike suppression limit\n\n This register is used to store the duration, measured in ic_clk cycles, of the longest spike that is filtered out by the spike suppression logic when the component is operating in SS, FS or FM+ modes. The relevant I2C requirement is tSP (table 4) as detailed in the I2C Bus Specification. This register must be programmed with a minimum value of 1.
  static volatile uint32_t & I2C1_IC_FS_SPKLEN __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 160)) ;

  // Field IC_FS_SPKLEN: This register must be set before any I2C bus transaction can take place to ensure stable operation. This register sets the duration, measured in ic_clk cycles, of the longest spike in the SCL or SDA lines that will be filtered out by the spike suppression logic. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect. The minimum valid value is 1; hardware prevents values less than this being written, and if attempted results in 1 being set. or more information, refer to 'Spike Suppression'.
    inline uint32_t I2C1_IC_FS_SPKLEN_IC_FS_SPKLEN (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IC_CLR_RESTART_DET: Clear RESTART_DET Interrupt Register
  static volatile uint32_t & I2C1_IC_CLR_RESTART_DET __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 168)) ;

  // Field CLR_RESTART_DET: Read this register to clear the RESTART_DET interrupt (bit 12) of IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
    const uint32_t I2C1_IC_CLR_RESTART_DET_CLR_RESTART_DET = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IC_COMP_PARAM_1: Component Parameter Register 1\n\n Note This register is not implemented and therefore reads as 0. If it was implemented it would be a constant read-only register that contains encoded information about the component's parameter settings. Fields shown below are the settings for those parameters
  static volatile uint32_t & I2C1_IC_COMP_PARAM_1 __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 244)) ;

  // Field APB_DATA_WIDTH: APB data bus width is 32 bits
    inline uint32_t I2C1_IC_COMP_PARAM_1_APB_DATA_WIDTH (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field MAX_SPEED_MODE: MAX SPEED MODE = FAST MODE
    inline uint32_t I2C1_IC_COMP_PARAM_1_MAX_SPEED_MODE (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field HC_COUNT_VALUES: Programmable count values for each mode.
    const uint32_t I2C1_IC_COMP_PARAM_1_HC_COUNT_VALUES = 1U << 4 ;

  // Field INTR_IO: COMBINED Interrupt outputs
    const uint32_t I2C1_IC_COMP_PARAM_1_INTR_IO = 1U << 5 ;

  // Field HAS_DMA: DMA handshaking signals are enabled
    const uint32_t I2C1_IC_COMP_PARAM_1_HAS_DMA = 1U << 6 ;

  // Field ADD_ENCODED_PARAMS: Encoded parameters not visible
    const uint32_t I2C1_IC_COMP_PARAM_1_ADD_ENCODED_PARAMS = 1U << 7 ;

  // Field RX_BUFFER_DEPTH: RX Buffer Depth = 16
    inline uint32_t I2C1_IC_COMP_PARAM_1_RX_BUFFER_DEPTH (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field TX_BUFFER_DEPTH: TX Buffer Depth = 16
    inline uint32_t I2C1_IC_COMP_PARAM_1_TX_BUFFER_DEPTH (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register IC_COMP_VERSION: I2C Component Version Register
  static volatile uint32_t & I2C1_IC_COMP_VERSION __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 248)) ;

  // Field IC_COMP_VERSION: 
    inline uint32_t I2C1_IC_COMP_VERSION_IC_COMP_VERSION (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IC_COMP_TYPE: I2C Component Type Register
  static volatile uint32_t & I2C1_IC_COMP_TYPE __attribute__((unused)) = * ((volatile uint32_t *) (0x40048000 + 252)) ;

  // Field IC_COMP_TYPE: Designware Component Type number = 0x44_57_01_40. This assigned unique hex value is constant and is derived from the two ASCII letters 'DW' followed by a 16-bit unsigned number.
    inline uint32_t I2C1_IC_COMP_TYPE_IC_COMP_TYPE (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral IO_BANK0: 
//------------------------------------------------------------------------------

//---  Register GPIO0_STATUS: GPIO status
  static volatile uint32_t & IO_BANK0_GPIO0_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 0)) ;

  // Field OUTFROMPERI: output signal from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO0_STATUS_OUTFROMPERI = 1U << 8 ;

  // Field OUTTOPAD: output signal to pad after register override is applied
    const uint32_t IO_BANK0_GPIO0_STATUS_OUTTOPAD = 1U << 9 ;

  // Field OEFROMPERI: output enable from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO0_STATUS_OEFROMPERI = 1U << 12 ;

  // Field OETOPAD: output enable to pad after register override is applied
    const uint32_t IO_BANK0_GPIO0_STATUS_OETOPAD = 1U << 13 ;

  // Field INFROMPAD: input signal from pad, before override is applied
    const uint32_t IO_BANK0_GPIO0_STATUS_INFROMPAD = 1U << 17 ;

  // Field INTOPERI: input signal to peripheral, after override is applied
    const uint32_t IO_BANK0_GPIO0_STATUS_INTOPERI = 1U << 19 ;

  // Field IRQFROMPAD: interrupt from pad before override is applied
    const uint32_t IO_BANK0_GPIO0_STATUS_IRQFROMPAD = 1U << 24 ;

  // Field IRQTOPROC: interrupt to processors, after override is applied
    const uint32_t IO_BANK0_GPIO0_STATUS_IRQTOPROC = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register GPIO0_CTRL: GPIO control including function select and overrides.
  static volatile uint32_t & IO_BANK0_GPIO0_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 4)) ;

  // Field FUNCSEL: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
    inline uint32_t IO_BANK0_GPIO0_CTRL_FUNCSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OUTOVER: 
    inline uint32_t IO_BANK0_GPIO0_CTRL_OUTOVER (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OEOVER: 
    inline uint32_t IO_BANK0_GPIO0_CTRL_OEOVER (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INOVER: 
    inline uint32_t IO_BANK0_GPIO0_CTRL_INOVER (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field IRQOVER: 
    inline uint32_t IO_BANK0_GPIO0_CTRL_IRQOVER (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register GPIO1_STATUS: GPIO status
  static volatile uint32_t & IO_BANK0_GPIO1_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 8)) ;

  // Field OUTFROMPERI: output signal from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO1_STATUS_OUTFROMPERI = 1U << 8 ;

  // Field OUTTOPAD: output signal to pad after register override is applied
    const uint32_t IO_BANK0_GPIO1_STATUS_OUTTOPAD = 1U << 9 ;

  // Field OEFROMPERI: output enable from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO1_STATUS_OEFROMPERI = 1U << 12 ;

  // Field OETOPAD: output enable to pad after register override is applied
    const uint32_t IO_BANK0_GPIO1_STATUS_OETOPAD = 1U << 13 ;

  // Field INFROMPAD: input signal from pad, before override is applied
    const uint32_t IO_BANK0_GPIO1_STATUS_INFROMPAD = 1U << 17 ;

  // Field INTOPERI: input signal to peripheral, after override is applied
    const uint32_t IO_BANK0_GPIO1_STATUS_INTOPERI = 1U << 19 ;

  // Field IRQFROMPAD: interrupt from pad before override is applied
    const uint32_t IO_BANK0_GPIO1_STATUS_IRQFROMPAD = 1U << 24 ;

  // Field IRQTOPROC: interrupt to processors, after override is applied
    const uint32_t IO_BANK0_GPIO1_STATUS_IRQTOPROC = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register GPIO1_CTRL: GPIO control including function select and overrides.
  static volatile uint32_t & IO_BANK0_GPIO1_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 12)) ;

  // Field FUNCSEL: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
    inline uint32_t IO_BANK0_GPIO1_CTRL_FUNCSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OUTOVER: 
    inline uint32_t IO_BANK0_GPIO1_CTRL_OUTOVER (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OEOVER: 
    inline uint32_t IO_BANK0_GPIO1_CTRL_OEOVER (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INOVER: 
    inline uint32_t IO_BANK0_GPIO1_CTRL_INOVER (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field IRQOVER: 
    inline uint32_t IO_BANK0_GPIO1_CTRL_IRQOVER (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register GPIO2_STATUS: GPIO status
  static volatile uint32_t & IO_BANK0_GPIO2_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 16)) ;

  // Field OUTFROMPERI: output signal from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO2_STATUS_OUTFROMPERI = 1U << 8 ;

  // Field OUTTOPAD: output signal to pad after register override is applied
    const uint32_t IO_BANK0_GPIO2_STATUS_OUTTOPAD = 1U << 9 ;

  // Field OEFROMPERI: output enable from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO2_STATUS_OEFROMPERI = 1U << 12 ;

  // Field OETOPAD: output enable to pad after register override is applied
    const uint32_t IO_BANK0_GPIO2_STATUS_OETOPAD = 1U << 13 ;

  // Field INFROMPAD: input signal from pad, before override is applied
    const uint32_t IO_BANK0_GPIO2_STATUS_INFROMPAD = 1U << 17 ;

  // Field INTOPERI: input signal to peripheral, after override is applied
    const uint32_t IO_BANK0_GPIO2_STATUS_INTOPERI = 1U << 19 ;

  // Field IRQFROMPAD: interrupt from pad before override is applied
    const uint32_t IO_BANK0_GPIO2_STATUS_IRQFROMPAD = 1U << 24 ;

  // Field IRQTOPROC: interrupt to processors, after override is applied
    const uint32_t IO_BANK0_GPIO2_STATUS_IRQTOPROC = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register GPIO2_CTRL: GPIO control including function select and overrides.
  static volatile uint32_t & IO_BANK0_GPIO2_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 20)) ;

  // Field FUNCSEL: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
    inline uint32_t IO_BANK0_GPIO2_CTRL_FUNCSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OUTOVER: 
    inline uint32_t IO_BANK0_GPIO2_CTRL_OUTOVER (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OEOVER: 
    inline uint32_t IO_BANK0_GPIO2_CTRL_OEOVER (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INOVER: 
    inline uint32_t IO_BANK0_GPIO2_CTRL_INOVER (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field IRQOVER: 
    inline uint32_t IO_BANK0_GPIO2_CTRL_IRQOVER (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register GPIO3_STATUS: GPIO status
  static volatile uint32_t & IO_BANK0_GPIO3_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 24)) ;

  // Field OUTFROMPERI: output signal from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO3_STATUS_OUTFROMPERI = 1U << 8 ;

  // Field OUTTOPAD: output signal to pad after register override is applied
    const uint32_t IO_BANK0_GPIO3_STATUS_OUTTOPAD = 1U << 9 ;

  // Field OEFROMPERI: output enable from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO3_STATUS_OEFROMPERI = 1U << 12 ;

  // Field OETOPAD: output enable to pad after register override is applied
    const uint32_t IO_BANK0_GPIO3_STATUS_OETOPAD = 1U << 13 ;

  // Field INFROMPAD: input signal from pad, before override is applied
    const uint32_t IO_BANK0_GPIO3_STATUS_INFROMPAD = 1U << 17 ;

  // Field INTOPERI: input signal to peripheral, after override is applied
    const uint32_t IO_BANK0_GPIO3_STATUS_INTOPERI = 1U << 19 ;

  // Field IRQFROMPAD: interrupt from pad before override is applied
    const uint32_t IO_BANK0_GPIO3_STATUS_IRQFROMPAD = 1U << 24 ;

  // Field IRQTOPROC: interrupt to processors, after override is applied
    const uint32_t IO_BANK0_GPIO3_STATUS_IRQTOPROC = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register GPIO3_CTRL: GPIO control including function select and overrides.
  static volatile uint32_t & IO_BANK0_GPIO3_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 28)) ;

  // Field FUNCSEL: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
    inline uint32_t IO_BANK0_GPIO3_CTRL_FUNCSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OUTOVER: 
    inline uint32_t IO_BANK0_GPIO3_CTRL_OUTOVER (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OEOVER: 
    inline uint32_t IO_BANK0_GPIO3_CTRL_OEOVER (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INOVER: 
    inline uint32_t IO_BANK0_GPIO3_CTRL_INOVER (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field IRQOVER: 
    inline uint32_t IO_BANK0_GPIO3_CTRL_IRQOVER (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register GPIO4_STATUS: GPIO status
  static volatile uint32_t & IO_BANK0_GPIO4_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 32)) ;

  // Field OUTFROMPERI: output signal from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO4_STATUS_OUTFROMPERI = 1U << 8 ;

  // Field OUTTOPAD: output signal to pad after register override is applied
    const uint32_t IO_BANK0_GPIO4_STATUS_OUTTOPAD = 1U << 9 ;

  // Field OEFROMPERI: output enable from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO4_STATUS_OEFROMPERI = 1U << 12 ;

  // Field OETOPAD: output enable to pad after register override is applied
    const uint32_t IO_BANK0_GPIO4_STATUS_OETOPAD = 1U << 13 ;

  // Field INFROMPAD: input signal from pad, before override is applied
    const uint32_t IO_BANK0_GPIO4_STATUS_INFROMPAD = 1U << 17 ;

  // Field INTOPERI: input signal to peripheral, after override is applied
    const uint32_t IO_BANK0_GPIO4_STATUS_INTOPERI = 1U << 19 ;

  // Field IRQFROMPAD: interrupt from pad before override is applied
    const uint32_t IO_BANK0_GPIO4_STATUS_IRQFROMPAD = 1U << 24 ;

  // Field IRQTOPROC: interrupt to processors, after override is applied
    const uint32_t IO_BANK0_GPIO4_STATUS_IRQTOPROC = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register GPIO4_CTRL: GPIO control including function select and overrides.
  static volatile uint32_t & IO_BANK0_GPIO4_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 36)) ;

  // Field FUNCSEL: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
    inline uint32_t IO_BANK0_GPIO4_CTRL_FUNCSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OUTOVER: 
    inline uint32_t IO_BANK0_GPIO4_CTRL_OUTOVER (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OEOVER: 
    inline uint32_t IO_BANK0_GPIO4_CTRL_OEOVER (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INOVER: 
    inline uint32_t IO_BANK0_GPIO4_CTRL_INOVER (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field IRQOVER: 
    inline uint32_t IO_BANK0_GPIO4_CTRL_IRQOVER (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register GPIO5_STATUS: GPIO status
  static volatile uint32_t & IO_BANK0_GPIO5_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 40)) ;

  // Field OUTFROMPERI: output signal from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO5_STATUS_OUTFROMPERI = 1U << 8 ;

  // Field OUTTOPAD: output signal to pad after register override is applied
    const uint32_t IO_BANK0_GPIO5_STATUS_OUTTOPAD = 1U << 9 ;

  // Field OEFROMPERI: output enable from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO5_STATUS_OEFROMPERI = 1U << 12 ;

  // Field OETOPAD: output enable to pad after register override is applied
    const uint32_t IO_BANK0_GPIO5_STATUS_OETOPAD = 1U << 13 ;

  // Field INFROMPAD: input signal from pad, before override is applied
    const uint32_t IO_BANK0_GPIO5_STATUS_INFROMPAD = 1U << 17 ;

  // Field INTOPERI: input signal to peripheral, after override is applied
    const uint32_t IO_BANK0_GPIO5_STATUS_INTOPERI = 1U << 19 ;

  // Field IRQFROMPAD: interrupt from pad before override is applied
    const uint32_t IO_BANK0_GPIO5_STATUS_IRQFROMPAD = 1U << 24 ;

  // Field IRQTOPROC: interrupt to processors, after override is applied
    const uint32_t IO_BANK0_GPIO5_STATUS_IRQTOPROC = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register GPIO5_CTRL: GPIO control including function select and overrides.
  static volatile uint32_t & IO_BANK0_GPIO5_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 44)) ;

  // Field FUNCSEL: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
    inline uint32_t IO_BANK0_GPIO5_CTRL_FUNCSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OUTOVER: 
    inline uint32_t IO_BANK0_GPIO5_CTRL_OUTOVER (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OEOVER: 
    inline uint32_t IO_BANK0_GPIO5_CTRL_OEOVER (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INOVER: 
    inline uint32_t IO_BANK0_GPIO5_CTRL_INOVER (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field IRQOVER: 
    inline uint32_t IO_BANK0_GPIO5_CTRL_IRQOVER (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register GPIO6_STATUS: GPIO status
  static volatile uint32_t & IO_BANK0_GPIO6_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 48)) ;

  // Field OUTFROMPERI: output signal from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO6_STATUS_OUTFROMPERI = 1U << 8 ;

  // Field OUTTOPAD: output signal to pad after register override is applied
    const uint32_t IO_BANK0_GPIO6_STATUS_OUTTOPAD = 1U << 9 ;

  // Field OEFROMPERI: output enable from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO6_STATUS_OEFROMPERI = 1U << 12 ;

  // Field OETOPAD: output enable to pad after register override is applied
    const uint32_t IO_BANK0_GPIO6_STATUS_OETOPAD = 1U << 13 ;

  // Field INFROMPAD: input signal from pad, before override is applied
    const uint32_t IO_BANK0_GPIO6_STATUS_INFROMPAD = 1U << 17 ;

  // Field INTOPERI: input signal to peripheral, after override is applied
    const uint32_t IO_BANK0_GPIO6_STATUS_INTOPERI = 1U << 19 ;

  // Field IRQFROMPAD: interrupt from pad before override is applied
    const uint32_t IO_BANK0_GPIO6_STATUS_IRQFROMPAD = 1U << 24 ;

  // Field IRQTOPROC: interrupt to processors, after override is applied
    const uint32_t IO_BANK0_GPIO6_STATUS_IRQTOPROC = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register GPIO6_CTRL: GPIO control including function select and overrides.
  static volatile uint32_t & IO_BANK0_GPIO6_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 52)) ;

  // Field FUNCSEL: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
    inline uint32_t IO_BANK0_GPIO6_CTRL_FUNCSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OUTOVER: 
    inline uint32_t IO_BANK0_GPIO6_CTRL_OUTOVER (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OEOVER: 
    inline uint32_t IO_BANK0_GPIO6_CTRL_OEOVER (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INOVER: 
    inline uint32_t IO_BANK0_GPIO6_CTRL_INOVER (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field IRQOVER: 
    inline uint32_t IO_BANK0_GPIO6_CTRL_IRQOVER (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register GPIO7_STATUS: GPIO status
  static volatile uint32_t & IO_BANK0_GPIO7_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 56)) ;

  // Field OUTFROMPERI: output signal from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO7_STATUS_OUTFROMPERI = 1U << 8 ;

  // Field OUTTOPAD: output signal to pad after register override is applied
    const uint32_t IO_BANK0_GPIO7_STATUS_OUTTOPAD = 1U << 9 ;

  // Field OEFROMPERI: output enable from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO7_STATUS_OEFROMPERI = 1U << 12 ;

  // Field OETOPAD: output enable to pad after register override is applied
    const uint32_t IO_BANK0_GPIO7_STATUS_OETOPAD = 1U << 13 ;

  // Field INFROMPAD: input signal from pad, before override is applied
    const uint32_t IO_BANK0_GPIO7_STATUS_INFROMPAD = 1U << 17 ;

  // Field INTOPERI: input signal to peripheral, after override is applied
    const uint32_t IO_BANK0_GPIO7_STATUS_INTOPERI = 1U << 19 ;

  // Field IRQFROMPAD: interrupt from pad before override is applied
    const uint32_t IO_BANK0_GPIO7_STATUS_IRQFROMPAD = 1U << 24 ;

  // Field IRQTOPROC: interrupt to processors, after override is applied
    const uint32_t IO_BANK0_GPIO7_STATUS_IRQTOPROC = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register GPIO7_CTRL: GPIO control including function select and overrides.
  static volatile uint32_t & IO_BANK0_GPIO7_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 60)) ;

  // Field FUNCSEL: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
    inline uint32_t IO_BANK0_GPIO7_CTRL_FUNCSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OUTOVER: 
    inline uint32_t IO_BANK0_GPIO7_CTRL_OUTOVER (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OEOVER: 
    inline uint32_t IO_BANK0_GPIO7_CTRL_OEOVER (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INOVER: 
    inline uint32_t IO_BANK0_GPIO7_CTRL_INOVER (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field IRQOVER: 
    inline uint32_t IO_BANK0_GPIO7_CTRL_IRQOVER (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register GPIO8_STATUS: GPIO status
  static volatile uint32_t & IO_BANK0_GPIO8_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 64)) ;

  // Field OUTFROMPERI: output signal from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO8_STATUS_OUTFROMPERI = 1U << 8 ;

  // Field OUTTOPAD: output signal to pad after register override is applied
    const uint32_t IO_BANK0_GPIO8_STATUS_OUTTOPAD = 1U << 9 ;

  // Field OEFROMPERI: output enable from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO8_STATUS_OEFROMPERI = 1U << 12 ;

  // Field OETOPAD: output enable to pad after register override is applied
    const uint32_t IO_BANK0_GPIO8_STATUS_OETOPAD = 1U << 13 ;

  // Field INFROMPAD: input signal from pad, before override is applied
    const uint32_t IO_BANK0_GPIO8_STATUS_INFROMPAD = 1U << 17 ;

  // Field INTOPERI: input signal to peripheral, after override is applied
    const uint32_t IO_BANK0_GPIO8_STATUS_INTOPERI = 1U << 19 ;

  // Field IRQFROMPAD: interrupt from pad before override is applied
    const uint32_t IO_BANK0_GPIO8_STATUS_IRQFROMPAD = 1U << 24 ;

  // Field IRQTOPROC: interrupt to processors, after override is applied
    const uint32_t IO_BANK0_GPIO8_STATUS_IRQTOPROC = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register GPIO8_CTRL: GPIO control including function select and overrides.
  static volatile uint32_t & IO_BANK0_GPIO8_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 68)) ;

  // Field FUNCSEL: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
    inline uint32_t IO_BANK0_GPIO8_CTRL_FUNCSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OUTOVER: 
    inline uint32_t IO_BANK0_GPIO8_CTRL_OUTOVER (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OEOVER: 
    inline uint32_t IO_BANK0_GPIO8_CTRL_OEOVER (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INOVER: 
    inline uint32_t IO_BANK0_GPIO8_CTRL_INOVER (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field IRQOVER: 
    inline uint32_t IO_BANK0_GPIO8_CTRL_IRQOVER (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register GPIO9_STATUS: GPIO status
  static volatile uint32_t & IO_BANK0_GPIO9_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 72)) ;

  // Field OUTFROMPERI: output signal from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO9_STATUS_OUTFROMPERI = 1U << 8 ;

  // Field OUTTOPAD: output signal to pad after register override is applied
    const uint32_t IO_BANK0_GPIO9_STATUS_OUTTOPAD = 1U << 9 ;

  // Field OEFROMPERI: output enable from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO9_STATUS_OEFROMPERI = 1U << 12 ;

  // Field OETOPAD: output enable to pad after register override is applied
    const uint32_t IO_BANK0_GPIO9_STATUS_OETOPAD = 1U << 13 ;

  // Field INFROMPAD: input signal from pad, before override is applied
    const uint32_t IO_BANK0_GPIO9_STATUS_INFROMPAD = 1U << 17 ;

  // Field INTOPERI: input signal to peripheral, after override is applied
    const uint32_t IO_BANK0_GPIO9_STATUS_INTOPERI = 1U << 19 ;

  // Field IRQFROMPAD: interrupt from pad before override is applied
    const uint32_t IO_BANK0_GPIO9_STATUS_IRQFROMPAD = 1U << 24 ;

  // Field IRQTOPROC: interrupt to processors, after override is applied
    const uint32_t IO_BANK0_GPIO9_STATUS_IRQTOPROC = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register GPIO9_CTRL: GPIO control including function select and overrides.
  static volatile uint32_t & IO_BANK0_GPIO9_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 76)) ;

  // Field FUNCSEL: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
    inline uint32_t IO_BANK0_GPIO9_CTRL_FUNCSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OUTOVER: 
    inline uint32_t IO_BANK0_GPIO9_CTRL_OUTOVER (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OEOVER: 
    inline uint32_t IO_BANK0_GPIO9_CTRL_OEOVER (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INOVER: 
    inline uint32_t IO_BANK0_GPIO9_CTRL_INOVER (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field IRQOVER: 
    inline uint32_t IO_BANK0_GPIO9_CTRL_IRQOVER (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register GPIO10_STATUS: GPIO status
  static volatile uint32_t & IO_BANK0_GPIO10_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 80)) ;

  // Field OUTFROMPERI: output signal from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO10_STATUS_OUTFROMPERI = 1U << 8 ;

  // Field OUTTOPAD: output signal to pad after register override is applied
    const uint32_t IO_BANK0_GPIO10_STATUS_OUTTOPAD = 1U << 9 ;

  // Field OEFROMPERI: output enable from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO10_STATUS_OEFROMPERI = 1U << 12 ;

  // Field OETOPAD: output enable to pad after register override is applied
    const uint32_t IO_BANK0_GPIO10_STATUS_OETOPAD = 1U << 13 ;

  // Field INFROMPAD: input signal from pad, before override is applied
    const uint32_t IO_BANK0_GPIO10_STATUS_INFROMPAD = 1U << 17 ;

  // Field INTOPERI: input signal to peripheral, after override is applied
    const uint32_t IO_BANK0_GPIO10_STATUS_INTOPERI = 1U << 19 ;

  // Field IRQFROMPAD: interrupt from pad before override is applied
    const uint32_t IO_BANK0_GPIO10_STATUS_IRQFROMPAD = 1U << 24 ;

  // Field IRQTOPROC: interrupt to processors, after override is applied
    const uint32_t IO_BANK0_GPIO10_STATUS_IRQTOPROC = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register GPIO10_CTRL: GPIO control including function select and overrides.
  static volatile uint32_t & IO_BANK0_GPIO10_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 84)) ;

  // Field FUNCSEL: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
    inline uint32_t IO_BANK0_GPIO10_CTRL_FUNCSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OUTOVER: 
    inline uint32_t IO_BANK0_GPIO10_CTRL_OUTOVER (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OEOVER: 
    inline uint32_t IO_BANK0_GPIO10_CTRL_OEOVER (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INOVER: 
    inline uint32_t IO_BANK0_GPIO10_CTRL_INOVER (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field IRQOVER: 
    inline uint32_t IO_BANK0_GPIO10_CTRL_IRQOVER (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register GPIO11_STATUS: GPIO status
  static volatile uint32_t & IO_BANK0_GPIO11_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 88)) ;

  // Field OUTFROMPERI: output signal from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO11_STATUS_OUTFROMPERI = 1U << 8 ;

  // Field OUTTOPAD: output signal to pad after register override is applied
    const uint32_t IO_BANK0_GPIO11_STATUS_OUTTOPAD = 1U << 9 ;

  // Field OEFROMPERI: output enable from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO11_STATUS_OEFROMPERI = 1U << 12 ;

  // Field OETOPAD: output enable to pad after register override is applied
    const uint32_t IO_BANK0_GPIO11_STATUS_OETOPAD = 1U << 13 ;

  // Field INFROMPAD: input signal from pad, before override is applied
    const uint32_t IO_BANK0_GPIO11_STATUS_INFROMPAD = 1U << 17 ;

  // Field INTOPERI: input signal to peripheral, after override is applied
    const uint32_t IO_BANK0_GPIO11_STATUS_INTOPERI = 1U << 19 ;

  // Field IRQFROMPAD: interrupt from pad before override is applied
    const uint32_t IO_BANK0_GPIO11_STATUS_IRQFROMPAD = 1U << 24 ;

  // Field IRQTOPROC: interrupt to processors, after override is applied
    const uint32_t IO_BANK0_GPIO11_STATUS_IRQTOPROC = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register GPIO11_CTRL: GPIO control including function select and overrides.
  static volatile uint32_t & IO_BANK0_GPIO11_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 92)) ;

  // Field FUNCSEL: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
    inline uint32_t IO_BANK0_GPIO11_CTRL_FUNCSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OUTOVER: 
    inline uint32_t IO_BANK0_GPIO11_CTRL_OUTOVER (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OEOVER: 
    inline uint32_t IO_BANK0_GPIO11_CTRL_OEOVER (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INOVER: 
    inline uint32_t IO_BANK0_GPIO11_CTRL_INOVER (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field IRQOVER: 
    inline uint32_t IO_BANK0_GPIO11_CTRL_IRQOVER (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register GPIO12_STATUS: GPIO status
  static volatile uint32_t & IO_BANK0_GPIO12_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 96)) ;

  // Field OUTFROMPERI: output signal from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO12_STATUS_OUTFROMPERI = 1U << 8 ;

  // Field OUTTOPAD: output signal to pad after register override is applied
    const uint32_t IO_BANK0_GPIO12_STATUS_OUTTOPAD = 1U << 9 ;

  // Field OEFROMPERI: output enable from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO12_STATUS_OEFROMPERI = 1U << 12 ;

  // Field OETOPAD: output enable to pad after register override is applied
    const uint32_t IO_BANK0_GPIO12_STATUS_OETOPAD = 1U << 13 ;

  // Field INFROMPAD: input signal from pad, before override is applied
    const uint32_t IO_BANK0_GPIO12_STATUS_INFROMPAD = 1U << 17 ;

  // Field INTOPERI: input signal to peripheral, after override is applied
    const uint32_t IO_BANK0_GPIO12_STATUS_INTOPERI = 1U << 19 ;

  // Field IRQFROMPAD: interrupt from pad before override is applied
    const uint32_t IO_BANK0_GPIO12_STATUS_IRQFROMPAD = 1U << 24 ;

  // Field IRQTOPROC: interrupt to processors, after override is applied
    const uint32_t IO_BANK0_GPIO12_STATUS_IRQTOPROC = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register GPIO12_CTRL: GPIO control including function select and overrides.
  static volatile uint32_t & IO_BANK0_GPIO12_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 100)) ;

  // Field FUNCSEL: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
    inline uint32_t IO_BANK0_GPIO12_CTRL_FUNCSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OUTOVER: 
    inline uint32_t IO_BANK0_GPIO12_CTRL_OUTOVER (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OEOVER: 
    inline uint32_t IO_BANK0_GPIO12_CTRL_OEOVER (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INOVER: 
    inline uint32_t IO_BANK0_GPIO12_CTRL_INOVER (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field IRQOVER: 
    inline uint32_t IO_BANK0_GPIO12_CTRL_IRQOVER (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register GPIO13_STATUS: GPIO status
  static volatile uint32_t & IO_BANK0_GPIO13_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 104)) ;

  // Field OUTFROMPERI: output signal from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO13_STATUS_OUTFROMPERI = 1U << 8 ;

  // Field OUTTOPAD: output signal to pad after register override is applied
    const uint32_t IO_BANK0_GPIO13_STATUS_OUTTOPAD = 1U << 9 ;

  // Field OEFROMPERI: output enable from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO13_STATUS_OEFROMPERI = 1U << 12 ;

  // Field OETOPAD: output enable to pad after register override is applied
    const uint32_t IO_BANK0_GPIO13_STATUS_OETOPAD = 1U << 13 ;

  // Field INFROMPAD: input signal from pad, before override is applied
    const uint32_t IO_BANK0_GPIO13_STATUS_INFROMPAD = 1U << 17 ;

  // Field INTOPERI: input signal to peripheral, after override is applied
    const uint32_t IO_BANK0_GPIO13_STATUS_INTOPERI = 1U << 19 ;

  // Field IRQFROMPAD: interrupt from pad before override is applied
    const uint32_t IO_BANK0_GPIO13_STATUS_IRQFROMPAD = 1U << 24 ;

  // Field IRQTOPROC: interrupt to processors, after override is applied
    const uint32_t IO_BANK0_GPIO13_STATUS_IRQTOPROC = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register GPIO13_CTRL: GPIO control including function select and overrides.
  static volatile uint32_t & IO_BANK0_GPIO13_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 108)) ;

  // Field FUNCSEL: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
    inline uint32_t IO_BANK0_GPIO13_CTRL_FUNCSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OUTOVER: 
    inline uint32_t IO_BANK0_GPIO13_CTRL_OUTOVER (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OEOVER: 
    inline uint32_t IO_BANK0_GPIO13_CTRL_OEOVER (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INOVER: 
    inline uint32_t IO_BANK0_GPIO13_CTRL_INOVER (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field IRQOVER: 
    inline uint32_t IO_BANK0_GPIO13_CTRL_IRQOVER (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register GPIO14_STATUS: GPIO status
  static volatile uint32_t & IO_BANK0_GPIO14_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 112)) ;

  // Field OUTFROMPERI: output signal from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO14_STATUS_OUTFROMPERI = 1U << 8 ;

  // Field OUTTOPAD: output signal to pad after register override is applied
    const uint32_t IO_BANK0_GPIO14_STATUS_OUTTOPAD = 1U << 9 ;

  // Field OEFROMPERI: output enable from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO14_STATUS_OEFROMPERI = 1U << 12 ;

  // Field OETOPAD: output enable to pad after register override is applied
    const uint32_t IO_BANK0_GPIO14_STATUS_OETOPAD = 1U << 13 ;

  // Field INFROMPAD: input signal from pad, before override is applied
    const uint32_t IO_BANK0_GPIO14_STATUS_INFROMPAD = 1U << 17 ;

  // Field INTOPERI: input signal to peripheral, after override is applied
    const uint32_t IO_BANK0_GPIO14_STATUS_INTOPERI = 1U << 19 ;

  // Field IRQFROMPAD: interrupt from pad before override is applied
    const uint32_t IO_BANK0_GPIO14_STATUS_IRQFROMPAD = 1U << 24 ;

  // Field IRQTOPROC: interrupt to processors, after override is applied
    const uint32_t IO_BANK0_GPIO14_STATUS_IRQTOPROC = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register GPIO14_CTRL: GPIO control including function select and overrides.
  static volatile uint32_t & IO_BANK0_GPIO14_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 116)) ;

  // Field FUNCSEL: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
    inline uint32_t IO_BANK0_GPIO14_CTRL_FUNCSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OUTOVER: 
    inline uint32_t IO_BANK0_GPIO14_CTRL_OUTOVER (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OEOVER: 
    inline uint32_t IO_BANK0_GPIO14_CTRL_OEOVER (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INOVER: 
    inline uint32_t IO_BANK0_GPIO14_CTRL_INOVER (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field IRQOVER: 
    inline uint32_t IO_BANK0_GPIO14_CTRL_IRQOVER (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register GPIO15_STATUS: GPIO status
  static volatile uint32_t & IO_BANK0_GPIO15_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 120)) ;

  // Field OUTFROMPERI: output signal from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO15_STATUS_OUTFROMPERI = 1U << 8 ;

  // Field OUTTOPAD: output signal to pad after register override is applied
    const uint32_t IO_BANK0_GPIO15_STATUS_OUTTOPAD = 1U << 9 ;

  // Field OEFROMPERI: output enable from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO15_STATUS_OEFROMPERI = 1U << 12 ;

  // Field OETOPAD: output enable to pad after register override is applied
    const uint32_t IO_BANK0_GPIO15_STATUS_OETOPAD = 1U << 13 ;

  // Field INFROMPAD: input signal from pad, before override is applied
    const uint32_t IO_BANK0_GPIO15_STATUS_INFROMPAD = 1U << 17 ;

  // Field INTOPERI: input signal to peripheral, after override is applied
    const uint32_t IO_BANK0_GPIO15_STATUS_INTOPERI = 1U << 19 ;

  // Field IRQFROMPAD: interrupt from pad before override is applied
    const uint32_t IO_BANK0_GPIO15_STATUS_IRQFROMPAD = 1U << 24 ;

  // Field IRQTOPROC: interrupt to processors, after override is applied
    const uint32_t IO_BANK0_GPIO15_STATUS_IRQTOPROC = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register GPIO15_CTRL: GPIO control including function select and overrides.
  static volatile uint32_t & IO_BANK0_GPIO15_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 124)) ;

  // Field FUNCSEL: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
    inline uint32_t IO_BANK0_GPIO15_CTRL_FUNCSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OUTOVER: 
    inline uint32_t IO_BANK0_GPIO15_CTRL_OUTOVER (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OEOVER: 
    inline uint32_t IO_BANK0_GPIO15_CTRL_OEOVER (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INOVER: 
    inline uint32_t IO_BANK0_GPIO15_CTRL_INOVER (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field IRQOVER: 
    inline uint32_t IO_BANK0_GPIO15_CTRL_IRQOVER (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register GPIO16_STATUS: GPIO status
  static volatile uint32_t & IO_BANK0_GPIO16_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 128)) ;

  // Field OUTFROMPERI: output signal from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO16_STATUS_OUTFROMPERI = 1U << 8 ;

  // Field OUTTOPAD: output signal to pad after register override is applied
    const uint32_t IO_BANK0_GPIO16_STATUS_OUTTOPAD = 1U << 9 ;

  // Field OEFROMPERI: output enable from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO16_STATUS_OEFROMPERI = 1U << 12 ;

  // Field OETOPAD: output enable to pad after register override is applied
    const uint32_t IO_BANK0_GPIO16_STATUS_OETOPAD = 1U << 13 ;

  // Field INFROMPAD: input signal from pad, before override is applied
    const uint32_t IO_BANK0_GPIO16_STATUS_INFROMPAD = 1U << 17 ;

  // Field INTOPERI: input signal to peripheral, after override is applied
    const uint32_t IO_BANK0_GPIO16_STATUS_INTOPERI = 1U << 19 ;

  // Field IRQFROMPAD: interrupt from pad before override is applied
    const uint32_t IO_BANK0_GPIO16_STATUS_IRQFROMPAD = 1U << 24 ;

  // Field IRQTOPROC: interrupt to processors, after override is applied
    const uint32_t IO_BANK0_GPIO16_STATUS_IRQTOPROC = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register GPIO16_CTRL: GPIO control including function select and overrides.
  static volatile uint32_t & IO_BANK0_GPIO16_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 132)) ;

  // Field FUNCSEL: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
    inline uint32_t IO_BANK0_GPIO16_CTRL_FUNCSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OUTOVER: 
    inline uint32_t IO_BANK0_GPIO16_CTRL_OUTOVER (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OEOVER: 
    inline uint32_t IO_BANK0_GPIO16_CTRL_OEOVER (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INOVER: 
    inline uint32_t IO_BANK0_GPIO16_CTRL_INOVER (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field IRQOVER: 
    inline uint32_t IO_BANK0_GPIO16_CTRL_IRQOVER (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register GPIO17_STATUS: GPIO status
  static volatile uint32_t & IO_BANK0_GPIO17_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 136)) ;

  // Field OUTFROMPERI: output signal from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO17_STATUS_OUTFROMPERI = 1U << 8 ;

  // Field OUTTOPAD: output signal to pad after register override is applied
    const uint32_t IO_BANK0_GPIO17_STATUS_OUTTOPAD = 1U << 9 ;

  // Field OEFROMPERI: output enable from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO17_STATUS_OEFROMPERI = 1U << 12 ;

  // Field OETOPAD: output enable to pad after register override is applied
    const uint32_t IO_BANK0_GPIO17_STATUS_OETOPAD = 1U << 13 ;

  // Field INFROMPAD: input signal from pad, before override is applied
    const uint32_t IO_BANK0_GPIO17_STATUS_INFROMPAD = 1U << 17 ;

  // Field INTOPERI: input signal to peripheral, after override is applied
    const uint32_t IO_BANK0_GPIO17_STATUS_INTOPERI = 1U << 19 ;

  // Field IRQFROMPAD: interrupt from pad before override is applied
    const uint32_t IO_BANK0_GPIO17_STATUS_IRQFROMPAD = 1U << 24 ;

  // Field IRQTOPROC: interrupt to processors, after override is applied
    const uint32_t IO_BANK0_GPIO17_STATUS_IRQTOPROC = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register GPIO17_CTRL: GPIO control including function select and overrides.
  static volatile uint32_t & IO_BANK0_GPIO17_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 140)) ;

  // Field FUNCSEL: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
    inline uint32_t IO_BANK0_GPIO17_CTRL_FUNCSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OUTOVER: 
    inline uint32_t IO_BANK0_GPIO17_CTRL_OUTOVER (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OEOVER: 
    inline uint32_t IO_BANK0_GPIO17_CTRL_OEOVER (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INOVER: 
    inline uint32_t IO_BANK0_GPIO17_CTRL_INOVER (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field IRQOVER: 
    inline uint32_t IO_BANK0_GPIO17_CTRL_IRQOVER (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register GPIO18_STATUS: GPIO status
  static volatile uint32_t & IO_BANK0_GPIO18_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 144)) ;

  // Field OUTFROMPERI: output signal from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO18_STATUS_OUTFROMPERI = 1U << 8 ;

  // Field OUTTOPAD: output signal to pad after register override is applied
    const uint32_t IO_BANK0_GPIO18_STATUS_OUTTOPAD = 1U << 9 ;

  // Field OEFROMPERI: output enable from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO18_STATUS_OEFROMPERI = 1U << 12 ;

  // Field OETOPAD: output enable to pad after register override is applied
    const uint32_t IO_BANK0_GPIO18_STATUS_OETOPAD = 1U << 13 ;

  // Field INFROMPAD: input signal from pad, before override is applied
    const uint32_t IO_BANK0_GPIO18_STATUS_INFROMPAD = 1U << 17 ;

  // Field INTOPERI: input signal to peripheral, after override is applied
    const uint32_t IO_BANK0_GPIO18_STATUS_INTOPERI = 1U << 19 ;

  // Field IRQFROMPAD: interrupt from pad before override is applied
    const uint32_t IO_BANK0_GPIO18_STATUS_IRQFROMPAD = 1U << 24 ;

  // Field IRQTOPROC: interrupt to processors, after override is applied
    const uint32_t IO_BANK0_GPIO18_STATUS_IRQTOPROC = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register GPIO18_CTRL: GPIO control including function select and overrides.
  static volatile uint32_t & IO_BANK0_GPIO18_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 148)) ;

  // Field FUNCSEL: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
    inline uint32_t IO_BANK0_GPIO18_CTRL_FUNCSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OUTOVER: 
    inline uint32_t IO_BANK0_GPIO18_CTRL_OUTOVER (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OEOVER: 
    inline uint32_t IO_BANK0_GPIO18_CTRL_OEOVER (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INOVER: 
    inline uint32_t IO_BANK0_GPIO18_CTRL_INOVER (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field IRQOVER: 
    inline uint32_t IO_BANK0_GPIO18_CTRL_IRQOVER (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register GPIO19_STATUS: GPIO status
  static volatile uint32_t & IO_BANK0_GPIO19_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 152)) ;

  // Field OUTFROMPERI: output signal from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO19_STATUS_OUTFROMPERI = 1U << 8 ;

  // Field OUTTOPAD: output signal to pad after register override is applied
    const uint32_t IO_BANK0_GPIO19_STATUS_OUTTOPAD = 1U << 9 ;

  // Field OEFROMPERI: output enable from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO19_STATUS_OEFROMPERI = 1U << 12 ;

  // Field OETOPAD: output enable to pad after register override is applied
    const uint32_t IO_BANK0_GPIO19_STATUS_OETOPAD = 1U << 13 ;

  // Field INFROMPAD: input signal from pad, before override is applied
    const uint32_t IO_BANK0_GPIO19_STATUS_INFROMPAD = 1U << 17 ;

  // Field INTOPERI: input signal to peripheral, after override is applied
    const uint32_t IO_BANK0_GPIO19_STATUS_INTOPERI = 1U << 19 ;

  // Field IRQFROMPAD: interrupt from pad before override is applied
    const uint32_t IO_BANK0_GPIO19_STATUS_IRQFROMPAD = 1U << 24 ;

  // Field IRQTOPROC: interrupt to processors, after override is applied
    const uint32_t IO_BANK0_GPIO19_STATUS_IRQTOPROC = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register GPIO19_CTRL: GPIO control including function select and overrides.
  static volatile uint32_t & IO_BANK0_GPIO19_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 156)) ;

  // Field FUNCSEL: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
    inline uint32_t IO_BANK0_GPIO19_CTRL_FUNCSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OUTOVER: 
    inline uint32_t IO_BANK0_GPIO19_CTRL_OUTOVER (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OEOVER: 
    inline uint32_t IO_BANK0_GPIO19_CTRL_OEOVER (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INOVER: 
    inline uint32_t IO_BANK0_GPIO19_CTRL_INOVER (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field IRQOVER: 
    inline uint32_t IO_BANK0_GPIO19_CTRL_IRQOVER (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register GPIO20_STATUS: GPIO status
  static volatile uint32_t & IO_BANK0_GPIO20_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 160)) ;

  // Field OUTFROMPERI: output signal from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO20_STATUS_OUTFROMPERI = 1U << 8 ;

  // Field OUTTOPAD: output signal to pad after register override is applied
    const uint32_t IO_BANK0_GPIO20_STATUS_OUTTOPAD = 1U << 9 ;

  // Field OEFROMPERI: output enable from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO20_STATUS_OEFROMPERI = 1U << 12 ;

  // Field OETOPAD: output enable to pad after register override is applied
    const uint32_t IO_BANK0_GPIO20_STATUS_OETOPAD = 1U << 13 ;

  // Field INFROMPAD: input signal from pad, before override is applied
    const uint32_t IO_BANK0_GPIO20_STATUS_INFROMPAD = 1U << 17 ;

  // Field INTOPERI: input signal to peripheral, after override is applied
    const uint32_t IO_BANK0_GPIO20_STATUS_INTOPERI = 1U << 19 ;

  // Field IRQFROMPAD: interrupt from pad before override is applied
    const uint32_t IO_BANK0_GPIO20_STATUS_IRQFROMPAD = 1U << 24 ;

  // Field IRQTOPROC: interrupt to processors, after override is applied
    const uint32_t IO_BANK0_GPIO20_STATUS_IRQTOPROC = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register GPIO20_CTRL: GPIO control including function select and overrides.
  static volatile uint32_t & IO_BANK0_GPIO20_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 164)) ;

  // Field FUNCSEL: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
    inline uint32_t IO_BANK0_GPIO20_CTRL_FUNCSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OUTOVER: 
    inline uint32_t IO_BANK0_GPIO20_CTRL_OUTOVER (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OEOVER: 
    inline uint32_t IO_BANK0_GPIO20_CTRL_OEOVER (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INOVER: 
    inline uint32_t IO_BANK0_GPIO20_CTRL_INOVER (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field IRQOVER: 
    inline uint32_t IO_BANK0_GPIO20_CTRL_IRQOVER (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register GPIO21_STATUS: GPIO status
  static volatile uint32_t & IO_BANK0_GPIO21_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 168)) ;

  // Field OUTFROMPERI: output signal from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO21_STATUS_OUTFROMPERI = 1U << 8 ;

  // Field OUTTOPAD: output signal to pad after register override is applied
    const uint32_t IO_BANK0_GPIO21_STATUS_OUTTOPAD = 1U << 9 ;

  // Field OEFROMPERI: output enable from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO21_STATUS_OEFROMPERI = 1U << 12 ;

  // Field OETOPAD: output enable to pad after register override is applied
    const uint32_t IO_BANK0_GPIO21_STATUS_OETOPAD = 1U << 13 ;

  // Field INFROMPAD: input signal from pad, before override is applied
    const uint32_t IO_BANK0_GPIO21_STATUS_INFROMPAD = 1U << 17 ;

  // Field INTOPERI: input signal to peripheral, after override is applied
    const uint32_t IO_BANK0_GPIO21_STATUS_INTOPERI = 1U << 19 ;

  // Field IRQFROMPAD: interrupt from pad before override is applied
    const uint32_t IO_BANK0_GPIO21_STATUS_IRQFROMPAD = 1U << 24 ;

  // Field IRQTOPROC: interrupt to processors, after override is applied
    const uint32_t IO_BANK0_GPIO21_STATUS_IRQTOPROC = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register GPIO21_CTRL: GPIO control including function select and overrides.
  static volatile uint32_t & IO_BANK0_GPIO21_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 172)) ;

  // Field FUNCSEL: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
    inline uint32_t IO_BANK0_GPIO21_CTRL_FUNCSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OUTOVER: 
    inline uint32_t IO_BANK0_GPIO21_CTRL_OUTOVER (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OEOVER: 
    inline uint32_t IO_BANK0_GPIO21_CTRL_OEOVER (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INOVER: 
    inline uint32_t IO_BANK0_GPIO21_CTRL_INOVER (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field IRQOVER: 
    inline uint32_t IO_BANK0_GPIO21_CTRL_IRQOVER (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register GPIO22_STATUS: GPIO status
  static volatile uint32_t & IO_BANK0_GPIO22_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 176)) ;

  // Field OUTFROMPERI: output signal from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO22_STATUS_OUTFROMPERI = 1U << 8 ;

  // Field OUTTOPAD: output signal to pad after register override is applied
    const uint32_t IO_BANK0_GPIO22_STATUS_OUTTOPAD = 1U << 9 ;

  // Field OEFROMPERI: output enable from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO22_STATUS_OEFROMPERI = 1U << 12 ;

  // Field OETOPAD: output enable to pad after register override is applied
    const uint32_t IO_BANK0_GPIO22_STATUS_OETOPAD = 1U << 13 ;

  // Field INFROMPAD: input signal from pad, before override is applied
    const uint32_t IO_BANK0_GPIO22_STATUS_INFROMPAD = 1U << 17 ;

  // Field INTOPERI: input signal to peripheral, after override is applied
    const uint32_t IO_BANK0_GPIO22_STATUS_INTOPERI = 1U << 19 ;

  // Field IRQFROMPAD: interrupt from pad before override is applied
    const uint32_t IO_BANK0_GPIO22_STATUS_IRQFROMPAD = 1U << 24 ;

  // Field IRQTOPROC: interrupt to processors, after override is applied
    const uint32_t IO_BANK0_GPIO22_STATUS_IRQTOPROC = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register GPIO22_CTRL: GPIO control including function select and overrides.
  static volatile uint32_t & IO_BANK0_GPIO22_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 180)) ;

  // Field FUNCSEL: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
    inline uint32_t IO_BANK0_GPIO22_CTRL_FUNCSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OUTOVER: 
    inline uint32_t IO_BANK0_GPIO22_CTRL_OUTOVER (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OEOVER: 
    inline uint32_t IO_BANK0_GPIO22_CTRL_OEOVER (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INOVER: 
    inline uint32_t IO_BANK0_GPIO22_CTRL_INOVER (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field IRQOVER: 
    inline uint32_t IO_BANK0_GPIO22_CTRL_IRQOVER (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register GPIO23_STATUS: GPIO status
  static volatile uint32_t & IO_BANK0_GPIO23_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 184)) ;

  // Field OUTFROMPERI: output signal from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO23_STATUS_OUTFROMPERI = 1U << 8 ;

  // Field OUTTOPAD: output signal to pad after register override is applied
    const uint32_t IO_BANK0_GPIO23_STATUS_OUTTOPAD = 1U << 9 ;

  // Field OEFROMPERI: output enable from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO23_STATUS_OEFROMPERI = 1U << 12 ;

  // Field OETOPAD: output enable to pad after register override is applied
    const uint32_t IO_BANK0_GPIO23_STATUS_OETOPAD = 1U << 13 ;

  // Field INFROMPAD: input signal from pad, before override is applied
    const uint32_t IO_BANK0_GPIO23_STATUS_INFROMPAD = 1U << 17 ;

  // Field INTOPERI: input signal to peripheral, after override is applied
    const uint32_t IO_BANK0_GPIO23_STATUS_INTOPERI = 1U << 19 ;

  // Field IRQFROMPAD: interrupt from pad before override is applied
    const uint32_t IO_BANK0_GPIO23_STATUS_IRQFROMPAD = 1U << 24 ;

  // Field IRQTOPROC: interrupt to processors, after override is applied
    const uint32_t IO_BANK0_GPIO23_STATUS_IRQTOPROC = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register GPIO23_CTRL: GPIO control including function select and overrides.
  static volatile uint32_t & IO_BANK0_GPIO23_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 188)) ;

  // Field FUNCSEL: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
    inline uint32_t IO_BANK0_GPIO23_CTRL_FUNCSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OUTOVER: 
    inline uint32_t IO_BANK0_GPIO23_CTRL_OUTOVER (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OEOVER: 
    inline uint32_t IO_BANK0_GPIO23_CTRL_OEOVER (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INOVER: 
    inline uint32_t IO_BANK0_GPIO23_CTRL_INOVER (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field IRQOVER: 
    inline uint32_t IO_BANK0_GPIO23_CTRL_IRQOVER (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register GPIO24_STATUS: GPIO status
  static volatile uint32_t & IO_BANK0_GPIO24_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 192)) ;

  // Field OUTFROMPERI: output signal from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO24_STATUS_OUTFROMPERI = 1U << 8 ;

  // Field OUTTOPAD: output signal to pad after register override is applied
    const uint32_t IO_BANK0_GPIO24_STATUS_OUTTOPAD = 1U << 9 ;

  // Field OEFROMPERI: output enable from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO24_STATUS_OEFROMPERI = 1U << 12 ;

  // Field OETOPAD: output enable to pad after register override is applied
    const uint32_t IO_BANK0_GPIO24_STATUS_OETOPAD = 1U << 13 ;

  // Field INFROMPAD: input signal from pad, before override is applied
    const uint32_t IO_BANK0_GPIO24_STATUS_INFROMPAD = 1U << 17 ;

  // Field INTOPERI: input signal to peripheral, after override is applied
    const uint32_t IO_BANK0_GPIO24_STATUS_INTOPERI = 1U << 19 ;

  // Field IRQFROMPAD: interrupt from pad before override is applied
    const uint32_t IO_BANK0_GPIO24_STATUS_IRQFROMPAD = 1U << 24 ;

  // Field IRQTOPROC: interrupt to processors, after override is applied
    const uint32_t IO_BANK0_GPIO24_STATUS_IRQTOPROC = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register GPIO24_CTRL: GPIO control including function select and overrides.
  static volatile uint32_t & IO_BANK0_GPIO24_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 196)) ;

  // Field FUNCSEL: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
    inline uint32_t IO_BANK0_GPIO24_CTRL_FUNCSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OUTOVER: 
    inline uint32_t IO_BANK0_GPIO24_CTRL_OUTOVER (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OEOVER: 
    inline uint32_t IO_BANK0_GPIO24_CTRL_OEOVER (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INOVER: 
    inline uint32_t IO_BANK0_GPIO24_CTRL_INOVER (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field IRQOVER: 
    inline uint32_t IO_BANK0_GPIO24_CTRL_IRQOVER (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register GPIO25_STATUS: GPIO status
  static volatile uint32_t & IO_BANK0_GPIO25_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 200)) ;

  // Field OUTFROMPERI: output signal from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO25_STATUS_OUTFROMPERI = 1U << 8 ;

  // Field OUTTOPAD: output signal to pad after register override is applied
    const uint32_t IO_BANK0_GPIO25_STATUS_OUTTOPAD = 1U << 9 ;

  // Field OEFROMPERI: output enable from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO25_STATUS_OEFROMPERI = 1U << 12 ;

  // Field OETOPAD: output enable to pad after register override is applied
    const uint32_t IO_BANK0_GPIO25_STATUS_OETOPAD = 1U << 13 ;

  // Field INFROMPAD: input signal from pad, before override is applied
    const uint32_t IO_BANK0_GPIO25_STATUS_INFROMPAD = 1U << 17 ;

  // Field INTOPERI: input signal to peripheral, after override is applied
    const uint32_t IO_BANK0_GPIO25_STATUS_INTOPERI = 1U << 19 ;

  // Field IRQFROMPAD: interrupt from pad before override is applied
    const uint32_t IO_BANK0_GPIO25_STATUS_IRQFROMPAD = 1U << 24 ;

  // Field IRQTOPROC: interrupt to processors, after override is applied
    const uint32_t IO_BANK0_GPIO25_STATUS_IRQTOPROC = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register GPIO25_CTRL: GPIO control including function select and overrides.
  static volatile uint32_t & IO_BANK0_GPIO25_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 204)) ;

  // Field FUNCSEL: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
    inline uint32_t IO_BANK0_GPIO25_CTRL_FUNCSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OUTOVER: 
    inline uint32_t IO_BANK0_GPIO25_CTRL_OUTOVER (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OEOVER: 
    inline uint32_t IO_BANK0_GPIO25_CTRL_OEOVER (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INOVER: 
    inline uint32_t IO_BANK0_GPIO25_CTRL_INOVER (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field IRQOVER: 
    inline uint32_t IO_BANK0_GPIO25_CTRL_IRQOVER (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register GPIO26_STATUS: GPIO status
  static volatile uint32_t & IO_BANK0_GPIO26_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 208)) ;

  // Field OUTFROMPERI: output signal from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO26_STATUS_OUTFROMPERI = 1U << 8 ;

  // Field OUTTOPAD: output signal to pad after register override is applied
    const uint32_t IO_BANK0_GPIO26_STATUS_OUTTOPAD = 1U << 9 ;

  // Field OEFROMPERI: output enable from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO26_STATUS_OEFROMPERI = 1U << 12 ;

  // Field OETOPAD: output enable to pad after register override is applied
    const uint32_t IO_BANK0_GPIO26_STATUS_OETOPAD = 1U << 13 ;

  // Field INFROMPAD: input signal from pad, before override is applied
    const uint32_t IO_BANK0_GPIO26_STATUS_INFROMPAD = 1U << 17 ;

  // Field INTOPERI: input signal to peripheral, after override is applied
    const uint32_t IO_BANK0_GPIO26_STATUS_INTOPERI = 1U << 19 ;

  // Field IRQFROMPAD: interrupt from pad before override is applied
    const uint32_t IO_BANK0_GPIO26_STATUS_IRQFROMPAD = 1U << 24 ;

  // Field IRQTOPROC: interrupt to processors, after override is applied
    const uint32_t IO_BANK0_GPIO26_STATUS_IRQTOPROC = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register GPIO26_CTRL: GPIO control including function select and overrides.
  static volatile uint32_t & IO_BANK0_GPIO26_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 212)) ;

  // Field FUNCSEL: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
    inline uint32_t IO_BANK0_GPIO26_CTRL_FUNCSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OUTOVER: 
    inline uint32_t IO_BANK0_GPIO26_CTRL_OUTOVER (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OEOVER: 
    inline uint32_t IO_BANK0_GPIO26_CTRL_OEOVER (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INOVER: 
    inline uint32_t IO_BANK0_GPIO26_CTRL_INOVER (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field IRQOVER: 
    inline uint32_t IO_BANK0_GPIO26_CTRL_IRQOVER (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register GPIO27_STATUS: GPIO status
  static volatile uint32_t & IO_BANK0_GPIO27_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 216)) ;

  // Field OUTFROMPERI: output signal from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO27_STATUS_OUTFROMPERI = 1U << 8 ;

  // Field OUTTOPAD: output signal to pad after register override is applied
    const uint32_t IO_BANK0_GPIO27_STATUS_OUTTOPAD = 1U << 9 ;

  // Field OEFROMPERI: output enable from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO27_STATUS_OEFROMPERI = 1U << 12 ;

  // Field OETOPAD: output enable to pad after register override is applied
    const uint32_t IO_BANK0_GPIO27_STATUS_OETOPAD = 1U << 13 ;

  // Field INFROMPAD: input signal from pad, before override is applied
    const uint32_t IO_BANK0_GPIO27_STATUS_INFROMPAD = 1U << 17 ;

  // Field INTOPERI: input signal to peripheral, after override is applied
    const uint32_t IO_BANK0_GPIO27_STATUS_INTOPERI = 1U << 19 ;

  // Field IRQFROMPAD: interrupt from pad before override is applied
    const uint32_t IO_BANK0_GPIO27_STATUS_IRQFROMPAD = 1U << 24 ;

  // Field IRQTOPROC: interrupt to processors, after override is applied
    const uint32_t IO_BANK0_GPIO27_STATUS_IRQTOPROC = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register GPIO27_CTRL: GPIO control including function select and overrides.
  static volatile uint32_t & IO_BANK0_GPIO27_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 220)) ;

  // Field FUNCSEL: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
    inline uint32_t IO_BANK0_GPIO27_CTRL_FUNCSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OUTOVER: 
    inline uint32_t IO_BANK0_GPIO27_CTRL_OUTOVER (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OEOVER: 
    inline uint32_t IO_BANK0_GPIO27_CTRL_OEOVER (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INOVER: 
    inline uint32_t IO_BANK0_GPIO27_CTRL_INOVER (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field IRQOVER: 
    inline uint32_t IO_BANK0_GPIO27_CTRL_IRQOVER (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register GPIO28_STATUS: GPIO status
  static volatile uint32_t & IO_BANK0_GPIO28_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 224)) ;

  // Field OUTFROMPERI: output signal from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO28_STATUS_OUTFROMPERI = 1U << 8 ;

  // Field OUTTOPAD: output signal to pad after register override is applied
    const uint32_t IO_BANK0_GPIO28_STATUS_OUTTOPAD = 1U << 9 ;

  // Field OEFROMPERI: output enable from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO28_STATUS_OEFROMPERI = 1U << 12 ;

  // Field OETOPAD: output enable to pad after register override is applied
    const uint32_t IO_BANK0_GPIO28_STATUS_OETOPAD = 1U << 13 ;

  // Field INFROMPAD: input signal from pad, before override is applied
    const uint32_t IO_BANK0_GPIO28_STATUS_INFROMPAD = 1U << 17 ;

  // Field INTOPERI: input signal to peripheral, after override is applied
    const uint32_t IO_BANK0_GPIO28_STATUS_INTOPERI = 1U << 19 ;

  // Field IRQFROMPAD: interrupt from pad before override is applied
    const uint32_t IO_BANK0_GPIO28_STATUS_IRQFROMPAD = 1U << 24 ;

  // Field IRQTOPROC: interrupt to processors, after override is applied
    const uint32_t IO_BANK0_GPIO28_STATUS_IRQTOPROC = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register GPIO28_CTRL: GPIO control including function select and overrides.
  static volatile uint32_t & IO_BANK0_GPIO28_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 228)) ;

  // Field FUNCSEL: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
    inline uint32_t IO_BANK0_GPIO28_CTRL_FUNCSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OUTOVER: 
    inline uint32_t IO_BANK0_GPIO28_CTRL_OUTOVER (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OEOVER: 
    inline uint32_t IO_BANK0_GPIO28_CTRL_OEOVER (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INOVER: 
    inline uint32_t IO_BANK0_GPIO28_CTRL_INOVER (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field IRQOVER: 
    inline uint32_t IO_BANK0_GPIO28_CTRL_IRQOVER (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register GPIO29_STATUS: GPIO status
  static volatile uint32_t & IO_BANK0_GPIO29_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 232)) ;

  // Field OUTFROMPERI: output signal from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO29_STATUS_OUTFROMPERI = 1U << 8 ;

  // Field OUTTOPAD: output signal to pad after register override is applied
    const uint32_t IO_BANK0_GPIO29_STATUS_OUTTOPAD = 1U << 9 ;

  // Field OEFROMPERI: output enable from selected peripheral, before register override is applied
    const uint32_t IO_BANK0_GPIO29_STATUS_OEFROMPERI = 1U << 12 ;

  // Field OETOPAD: output enable to pad after register override is applied
    const uint32_t IO_BANK0_GPIO29_STATUS_OETOPAD = 1U << 13 ;

  // Field INFROMPAD: input signal from pad, before override is applied
    const uint32_t IO_BANK0_GPIO29_STATUS_INFROMPAD = 1U << 17 ;

  // Field INTOPERI: input signal to peripheral, after override is applied
    const uint32_t IO_BANK0_GPIO29_STATUS_INTOPERI = 1U << 19 ;

  // Field IRQFROMPAD: interrupt from pad before override is applied
    const uint32_t IO_BANK0_GPIO29_STATUS_IRQFROMPAD = 1U << 24 ;

  // Field IRQTOPROC: interrupt to processors, after override is applied
    const uint32_t IO_BANK0_GPIO29_STATUS_IRQTOPROC = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register GPIO29_CTRL: GPIO control including function select and overrides.
  static volatile uint32_t & IO_BANK0_GPIO29_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 236)) ;

  // Field FUNCSEL: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
    inline uint32_t IO_BANK0_GPIO29_CTRL_FUNCSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OUTOVER: 
    inline uint32_t IO_BANK0_GPIO29_CTRL_OUTOVER (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OEOVER: 
    inline uint32_t IO_BANK0_GPIO29_CTRL_OEOVER (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INOVER: 
    inline uint32_t IO_BANK0_GPIO29_CTRL_INOVER (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field IRQOVER: 
    inline uint32_t IO_BANK0_GPIO29_CTRL_IRQOVER (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register INTR0: Raw Interrupts
  static volatile uint32_t & IO_BANK0_INTR0 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 240)) ;

  // Field GPIO0_LEVEL_LOW: 
    const uint32_t IO_BANK0_INTR0_GPIO0_LEVEL_LOW = 1U << 0 ;

  // Field GPIO0_LEVEL_HIGH: 
    const uint32_t IO_BANK0_INTR0_GPIO0_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO0_EDGE_LOW: 
    const uint32_t IO_BANK0_INTR0_GPIO0_EDGE_LOW = 1U << 2 ;

  // Field GPIO0_EDGE_HIGH: 
    const uint32_t IO_BANK0_INTR0_GPIO0_EDGE_HIGH = 1U << 3 ;

  // Field GPIO1_LEVEL_LOW: 
    const uint32_t IO_BANK0_INTR0_GPIO1_LEVEL_LOW = 1U << 4 ;

  // Field GPIO1_LEVEL_HIGH: 
    const uint32_t IO_BANK0_INTR0_GPIO1_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO1_EDGE_LOW: 
    const uint32_t IO_BANK0_INTR0_GPIO1_EDGE_LOW = 1U << 6 ;

  // Field GPIO1_EDGE_HIGH: 
    const uint32_t IO_BANK0_INTR0_GPIO1_EDGE_HIGH = 1U << 7 ;

  // Field GPIO2_LEVEL_LOW: 
    const uint32_t IO_BANK0_INTR0_GPIO2_LEVEL_LOW = 1U << 8 ;

  // Field GPIO2_LEVEL_HIGH: 
    const uint32_t IO_BANK0_INTR0_GPIO2_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO2_EDGE_LOW: 
    const uint32_t IO_BANK0_INTR0_GPIO2_EDGE_LOW = 1U << 10 ;

  // Field GPIO2_EDGE_HIGH: 
    const uint32_t IO_BANK0_INTR0_GPIO2_EDGE_HIGH = 1U << 11 ;

  // Field GPIO3_LEVEL_LOW: 
    const uint32_t IO_BANK0_INTR0_GPIO3_LEVEL_LOW = 1U << 12 ;

  // Field GPIO3_LEVEL_HIGH: 
    const uint32_t IO_BANK0_INTR0_GPIO3_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO3_EDGE_LOW: 
    const uint32_t IO_BANK0_INTR0_GPIO3_EDGE_LOW = 1U << 14 ;

  // Field GPIO3_EDGE_HIGH: 
    const uint32_t IO_BANK0_INTR0_GPIO3_EDGE_HIGH = 1U << 15 ;

  // Field GPIO4_LEVEL_LOW: 
    const uint32_t IO_BANK0_INTR0_GPIO4_LEVEL_LOW = 1U << 16 ;

  // Field GPIO4_LEVEL_HIGH: 
    const uint32_t IO_BANK0_INTR0_GPIO4_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO4_EDGE_LOW: 
    const uint32_t IO_BANK0_INTR0_GPIO4_EDGE_LOW = 1U << 18 ;

  // Field GPIO4_EDGE_HIGH: 
    const uint32_t IO_BANK0_INTR0_GPIO4_EDGE_HIGH = 1U << 19 ;

  // Field GPIO5_LEVEL_LOW: 
    const uint32_t IO_BANK0_INTR0_GPIO5_LEVEL_LOW = 1U << 20 ;

  // Field GPIO5_LEVEL_HIGH: 
    const uint32_t IO_BANK0_INTR0_GPIO5_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO5_EDGE_LOW: 
    const uint32_t IO_BANK0_INTR0_GPIO5_EDGE_LOW = 1U << 22 ;

  // Field GPIO5_EDGE_HIGH: 
    const uint32_t IO_BANK0_INTR0_GPIO5_EDGE_HIGH = 1U << 23 ;

  // Field GPIO6_LEVEL_LOW: 
    const uint32_t IO_BANK0_INTR0_GPIO6_LEVEL_LOW = 1U << 24 ;

  // Field GPIO6_LEVEL_HIGH: 
    const uint32_t IO_BANK0_INTR0_GPIO6_LEVEL_HIGH = 1U << 25 ;

  // Field GPIO6_EDGE_LOW: 
    const uint32_t IO_BANK0_INTR0_GPIO6_EDGE_LOW = 1U << 26 ;

  // Field GPIO6_EDGE_HIGH: 
    const uint32_t IO_BANK0_INTR0_GPIO6_EDGE_HIGH = 1U << 27 ;

  // Field GPIO7_LEVEL_LOW: 
    const uint32_t IO_BANK0_INTR0_GPIO7_LEVEL_LOW = 1U << 28 ;

  // Field GPIO7_LEVEL_HIGH: 
    const uint32_t IO_BANK0_INTR0_GPIO7_LEVEL_HIGH = 1U << 29 ;

  // Field GPIO7_EDGE_LOW: 
    const uint32_t IO_BANK0_INTR0_GPIO7_EDGE_LOW = 1U << 30 ;

  // Field GPIO7_EDGE_HIGH: 
    const uint32_t IO_BANK0_INTR0_GPIO7_EDGE_HIGH = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register INTR1: Raw Interrupts
  static volatile uint32_t & IO_BANK0_INTR1 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 244)) ;

  // Field GPIO8_LEVEL_LOW: 
    const uint32_t IO_BANK0_INTR1_GPIO8_LEVEL_LOW = 1U << 0 ;

  // Field GPIO8_LEVEL_HIGH: 
    const uint32_t IO_BANK0_INTR1_GPIO8_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO8_EDGE_LOW: 
    const uint32_t IO_BANK0_INTR1_GPIO8_EDGE_LOW = 1U << 2 ;

  // Field GPIO8_EDGE_HIGH: 
    const uint32_t IO_BANK0_INTR1_GPIO8_EDGE_HIGH = 1U << 3 ;

  // Field GPIO9_LEVEL_LOW: 
    const uint32_t IO_BANK0_INTR1_GPIO9_LEVEL_LOW = 1U << 4 ;

  // Field GPIO9_LEVEL_HIGH: 
    const uint32_t IO_BANK0_INTR1_GPIO9_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO9_EDGE_LOW: 
    const uint32_t IO_BANK0_INTR1_GPIO9_EDGE_LOW = 1U << 6 ;

  // Field GPIO9_EDGE_HIGH: 
    const uint32_t IO_BANK0_INTR1_GPIO9_EDGE_HIGH = 1U << 7 ;

  // Field GPIO10_LEVEL_LOW: 
    const uint32_t IO_BANK0_INTR1_GPIO10_LEVEL_LOW = 1U << 8 ;

  // Field GPIO10_LEVEL_HIGH: 
    const uint32_t IO_BANK0_INTR1_GPIO10_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO10_EDGE_LOW: 
    const uint32_t IO_BANK0_INTR1_GPIO10_EDGE_LOW = 1U << 10 ;

  // Field GPIO10_EDGE_HIGH: 
    const uint32_t IO_BANK0_INTR1_GPIO10_EDGE_HIGH = 1U << 11 ;

  // Field GPIO11_LEVEL_LOW: 
    const uint32_t IO_BANK0_INTR1_GPIO11_LEVEL_LOW = 1U << 12 ;

  // Field GPIO11_LEVEL_HIGH: 
    const uint32_t IO_BANK0_INTR1_GPIO11_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO11_EDGE_LOW: 
    const uint32_t IO_BANK0_INTR1_GPIO11_EDGE_LOW = 1U << 14 ;

  // Field GPIO11_EDGE_HIGH: 
    const uint32_t IO_BANK0_INTR1_GPIO11_EDGE_HIGH = 1U << 15 ;

  // Field GPIO12_LEVEL_LOW: 
    const uint32_t IO_BANK0_INTR1_GPIO12_LEVEL_LOW = 1U << 16 ;

  // Field GPIO12_LEVEL_HIGH: 
    const uint32_t IO_BANK0_INTR1_GPIO12_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO12_EDGE_LOW: 
    const uint32_t IO_BANK0_INTR1_GPIO12_EDGE_LOW = 1U << 18 ;

  // Field GPIO12_EDGE_HIGH: 
    const uint32_t IO_BANK0_INTR1_GPIO12_EDGE_HIGH = 1U << 19 ;

  // Field GPIO13_LEVEL_LOW: 
    const uint32_t IO_BANK0_INTR1_GPIO13_LEVEL_LOW = 1U << 20 ;

  // Field GPIO13_LEVEL_HIGH: 
    const uint32_t IO_BANK0_INTR1_GPIO13_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO13_EDGE_LOW: 
    const uint32_t IO_BANK0_INTR1_GPIO13_EDGE_LOW = 1U << 22 ;

  // Field GPIO13_EDGE_HIGH: 
    const uint32_t IO_BANK0_INTR1_GPIO13_EDGE_HIGH = 1U << 23 ;

  // Field GPIO14_LEVEL_LOW: 
    const uint32_t IO_BANK0_INTR1_GPIO14_LEVEL_LOW = 1U << 24 ;

  // Field GPIO14_LEVEL_HIGH: 
    const uint32_t IO_BANK0_INTR1_GPIO14_LEVEL_HIGH = 1U << 25 ;

  // Field GPIO14_EDGE_LOW: 
    const uint32_t IO_BANK0_INTR1_GPIO14_EDGE_LOW = 1U << 26 ;

  // Field GPIO14_EDGE_HIGH: 
    const uint32_t IO_BANK0_INTR1_GPIO14_EDGE_HIGH = 1U << 27 ;

  // Field GPIO15_LEVEL_LOW: 
    const uint32_t IO_BANK0_INTR1_GPIO15_LEVEL_LOW = 1U << 28 ;

  // Field GPIO15_LEVEL_HIGH: 
    const uint32_t IO_BANK0_INTR1_GPIO15_LEVEL_HIGH = 1U << 29 ;

  // Field GPIO15_EDGE_LOW: 
    const uint32_t IO_BANK0_INTR1_GPIO15_EDGE_LOW = 1U << 30 ;

  // Field GPIO15_EDGE_HIGH: 
    const uint32_t IO_BANK0_INTR1_GPIO15_EDGE_HIGH = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register INTR2: Raw Interrupts
  static volatile uint32_t & IO_BANK0_INTR2 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 248)) ;

  // Field GPIO16_LEVEL_LOW: 
    const uint32_t IO_BANK0_INTR2_GPIO16_LEVEL_LOW = 1U << 0 ;

  // Field GPIO16_LEVEL_HIGH: 
    const uint32_t IO_BANK0_INTR2_GPIO16_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO16_EDGE_LOW: 
    const uint32_t IO_BANK0_INTR2_GPIO16_EDGE_LOW = 1U << 2 ;

  // Field GPIO16_EDGE_HIGH: 
    const uint32_t IO_BANK0_INTR2_GPIO16_EDGE_HIGH = 1U << 3 ;

  // Field GPIO17_LEVEL_LOW: 
    const uint32_t IO_BANK0_INTR2_GPIO17_LEVEL_LOW = 1U << 4 ;

  // Field GPIO17_LEVEL_HIGH: 
    const uint32_t IO_BANK0_INTR2_GPIO17_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO17_EDGE_LOW: 
    const uint32_t IO_BANK0_INTR2_GPIO17_EDGE_LOW = 1U << 6 ;

  // Field GPIO17_EDGE_HIGH: 
    const uint32_t IO_BANK0_INTR2_GPIO17_EDGE_HIGH = 1U << 7 ;

  // Field GPIO18_LEVEL_LOW: 
    const uint32_t IO_BANK0_INTR2_GPIO18_LEVEL_LOW = 1U << 8 ;

  // Field GPIO18_LEVEL_HIGH: 
    const uint32_t IO_BANK0_INTR2_GPIO18_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO18_EDGE_LOW: 
    const uint32_t IO_BANK0_INTR2_GPIO18_EDGE_LOW = 1U << 10 ;

  // Field GPIO18_EDGE_HIGH: 
    const uint32_t IO_BANK0_INTR2_GPIO18_EDGE_HIGH = 1U << 11 ;

  // Field GPIO19_LEVEL_LOW: 
    const uint32_t IO_BANK0_INTR2_GPIO19_LEVEL_LOW = 1U << 12 ;

  // Field GPIO19_LEVEL_HIGH: 
    const uint32_t IO_BANK0_INTR2_GPIO19_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO19_EDGE_LOW: 
    const uint32_t IO_BANK0_INTR2_GPIO19_EDGE_LOW = 1U << 14 ;

  // Field GPIO19_EDGE_HIGH: 
    const uint32_t IO_BANK0_INTR2_GPIO19_EDGE_HIGH = 1U << 15 ;

  // Field GPIO20_LEVEL_LOW: 
    const uint32_t IO_BANK0_INTR2_GPIO20_LEVEL_LOW = 1U << 16 ;

  // Field GPIO20_LEVEL_HIGH: 
    const uint32_t IO_BANK0_INTR2_GPIO20_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO20_EDGE_LOW: 
    const uint32_t IO_BANK0_INTR2_GPIO20_EDGE_LOW = 1U << 18 ;

  // Field GPIO20_EDGE_HIGH: 
    const uint32_t IO_BANK0_INTR2_GPIO20_EDGE_HIGH = 1U << 19 ;

  // Field GPIO21_LEVEL_LOW: 
    const uint32_t IO_BANK0_INTR2_GPIO21_LEVEL_LOW = 1U << 20 ;

  // Field GPIO21_LEVEL_HIGH: 
    const uint32_t IO_BANK0_INTR2_GPIO21_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO21_EDGE_LOW: 
    const uint32_t IO_BANK0_INTR2_GPIO21_EDGE_LOW = 1U << 22 ;

  // Field GPIO21_EDGE_HIGH: 
    const uint32_t IO_BANK0_INTR2_GPIO21_EDGE_HIGH = 1U << 23 ;

  // Field GPIO22_LEVEL_LOW: 
    const uint32_t IO_BANK0_INTR2_GPIO22_LEVEL_LOW = 1U << 24 ;

  // Field GPIO22_LEVEL_HIGH: 
    const uint32_t IO_BANK0_INTR2_GPIO22_LEVEL_HIGH = 1U << 25 ;

  // Field GPIO22_EDGE_LOW: 
    const uint32_t IO_BANK0_INTR2_GPIO22_EDGE_LOW = 1U << 26 ;

  // Field GPIO22_EDGE_HIGH: 
    const uint32_t IO_BANK0_INTR2_GPIO22_EDGE_HIGH = 1U << 27 ;

  // Field GPIO23_LEVEL_LOW: 
    const uint32_t IO_BANK0_INTR2_GPIO23_LEVEL_LOW = 1U << 28 ;

  // Field GPIO23_LEVEL_HIGH: 
    const uint32_t IO_BANK0_INTR2_GPIO23_LEVEL_HIGH = 1U << 29 ;

  // Field GPIO23_EDGE_LOW: 
    const uint32_t IO_BANK0_INTR2_GPIO23_EDGE_LOW = 1U << 30 ;

  // Field GPIO23_EDGE_HIGH: 
    const uint32_t IO_BANK0_INTR2_GPIO23_EDGE_HIGH = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register INTR3: Raw Interrupts
  static volatile uint32_t & IO_BANK0_INTR3 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 252)) ;

  // Field GPIO24_LEVEL_LOW: 
    const uint32_t IO_BANK0_INTR3_GPIO24_LEVEL_LOW = 1U << 0 ;

  // Field GPIO24_LEVEL_HIGH: 
    const uint32_t IO_BANK0_INTR3_GPIO24_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO24_EDGE_LOW: 
    const uint32_t IO_BANK0_INTR3_GPIO24_EDGE_LOW = 1U << 2 ;

  // Field GPIO24_EDGE_HIGH: 
    const uint32_t IO_BANK0_INTR3_GPIO24_EDGE_HIGH = 1U << 3 ;

  // Field GPIO25_LEVEL_LOW: 
    const uint32_t IO_BANK0_INTR3_GPIO25_LEVEL_LOW = 1U << 4 ;

  // Field GPIO25_LEVEL_HIGH: 
    const uint32_t IO_BANK0_INTR3_GPIO25_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO25_EDGE_LOW: 
    const uint32_t IO_BANK0_INTR3_GPIO25_EDGE_LOW = 1U << 6 ;

  // Field GPIO25_EDGE_HIGH: 
    const uint32_t IO_BANK0_INTR3_GPIO25_EDGE_HIGH = 1U << 7 ;

  // Field GPIO26_LEVEL_LOW: 
    const uint32_t IO_BANK0_INTR3_GPIO26_LEVEL_LOW = 1U << 8 ;

  // Field GPIO26_LEVEL_HIGH: 
    const uint32_t IO_BANK0_INTR3_GPIO26_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO26_EDGE_LOW: 
    const uint32_t IO_BANK0_INTR3_GPIO26_EDGE_LOW = 1U << 10 ;

  // Field GPIO26_EDGE_HIGH: 
    const uint32_t IO_BANK0_INTR3_GPIO26_EDGE_HIGH = 1U << 11 ;

  // Field GPIO27_LEVEL_LOW: 
    const uint32_t IO_BANK0_INTR3_GPIO27_LEVEL_LOW = 1U << 12 ;

  // Field GPIO27_LEVEL_HIGH: 
    const uint32_t IO_BANK0_INTR3_GPIO27_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO27_EDGE_LOW: 
    const uint32_t IO_BANK0_INTR3_GPIO27_EDGE_LOW = 1U << 14 ;

  // Field GPIO27_EDGE_HIGH: 
    const uint32_t IO_BANK0_INTR3_GPIO27_EDGE_HIGH = 1U << 15 ;

  // Field GPIO28_LEVEL_LOW: 
    const uint32_t IO_BANK0_INTR3_GPIO28_LEVEL_LOW = 1U << 16 ;

  // Field GPIO28_LEVEL_HIGH: 
    const uint32_t IO_BANK0_INTR3_GPIO28_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO28_EDGE_LOW: 
    const uint32_t IO_BANK0_INTR3_GPIO28_EDGE_LOW = 1U << 18 ;

  // Field GPIO28_EDGE_HIGH: 
    const uint32_t IO_BANK0_INTR3_GPIO28_EDGE_HIGH = 1U << 19 ;

  // Field GPIO29_LEVEL_LOW: 
    const uint32_t IO_BANK0_INTR3_GPIO29_LEVEL_LOW = 1U << 20 ;

  // Field GPIO29_LEVEL_HIGH: 
    const uint32_t IO_BANK0_INTR3_GPIO29_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO29_EDGE_LOW: 
    const uint32_t IO_BANK0_INTR3_GPIO29_EDGE_LOW = 1U << 22 ;

  // Field GPIO29_EDGE_HIGH: 
    const uint32_t IO_BANK0_INTR3_GPIO29_EDGE_HIGH = 1U << 23 ;

//------------------------------------------------------------------------------

//---  Register PROC0_INTE0: Interrupt Enable for proc0
  static volatile uint32_t & IO_BANK0_PROC0_INTE0 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 256)) ;

  // Field GPIO0_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE0_GPIO0_LEVEL_LOW = 1U << 0 ;

  // Field GPIO0_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE0_GPIO0_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO0_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE0_GPIO0_EDGE_LOW = 1U << 2 ;

  // Field GPIO0_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE0_GPIO0_EDGE_HIGH = 1U << 3 ;

  // Field GPIO1_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE0_GPIO1_LEVEL_LOW = 1U << 4 ;

  // Field GPIO1_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE0_GPIO1_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO1_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE0_GPIO1_EDGE_LOW = 1U << 6 ;

  // Field GPIO1_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE0_GPIO1_EDGE_HIGH = 1U << 7 ;

  // Field GPIO2_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE0_GPIO2_LEVEL_LOW = 1U << 8 ;

  // Field GPIO2_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE0_GPIO2_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO2_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE0_GPIO2_EDGE_LOW = 1U << 10 ;

  // Field GPIO2_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE0_GPIO2_EDGE_HIGH = 1U << 11 ;

  // Field GPIO3_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE0_GPIO3_LEVEL_LOW = 1U << 12 ;

  // Field GPIO3_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE0_GPIO3_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO3_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE0_GPIO3_EDGE_LOW = 1U << 14 ;

  // Field GPIO3_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE0_GPIO3_EDGE_HIGH = 1U << 15 ;

  // Field GPIO4_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE0_GPIO4_LEVEL_LOW = 1U << 16 ;

  // Field GPIO4_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE0_GPIO4_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO4_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE0_GPIO4_EDGE_LOW = 1U << 18 ;

  // Field GPIO4_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE0_GPIO4_EDGE_HIGH = 1U << 19 ;

  // Field GPIO5_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE0_GPIO5_LEVEL_LOW = 1U << 20 ;

  // Field GPIO5_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE0_GPIO5_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO5_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE0_GPIO5_EDGE_LOW = 1U << 22 ;

  // Field GPIO5_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE0_GPIO5_EDGE_HIGH = 1U << 23 ;

  // Field GPIO6_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE0_GPIO6_LEVEL_LOW = 1U << 24 ;

  // Field GPIO6_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE0_GPIO6_LEVEL_HIGH = 1U << 25 ;

  // Field GPIO6_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE0_GPIO6_EDGE_LOW = 1U << 26 ;

  // Field GPIO6_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE0_GPIO6_EDGE_HIGH = 1U << 27 ;

  // Field GPIO7_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE0_GPIO7_LEVEL_LOW = 1U << 28 ;

  // Field GPIO7_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE0_GPIO7_LEVEL_HIGH = 1U << 29 ;

  // Field GPIO7_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE0_GPIO7_EDGE_LOW = 1U << 30 ;

  // Field GPIO7_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE0_GPIO7_EDGE_HIGH = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register PROC0_INTE1: Interrupt Enable for proc0
  static volatile uint32_t & IO_BANK0_PROC0_INTE1 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 260)) ;

  // Field GPIO8_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE1_GPIO8_LEVEL_LOW = 1U << 0 ;

  // Field GPIO8_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE1_GPIO8_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO8_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE1_GPIO8_EDGE_LOW = 1U << 2 ;

  // Field GPIO8_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE1_GPIO8_EDGE_HIGH = 1U << 3 ;

  // Field GPIO9_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE1_GPIO9_LEVEL_LOW = 1U << 4 ;

  // Field GPIO9_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE1_GPIO9_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO9_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE1_GPIO9_EDGE_LOW = 1U << 6 ;

  // Field GPIO9_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE1_GPIO9_EDGE_HIGH = 1U << 7 ;

  // Field GPIO10_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE1_GPIO10_LEVEL_LOW = 1U << 8 ;

  // Field GPIO10_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE1_GPIO10_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO10_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE1_GPIO10_EDGE_LOW = 1U << 10 ;

  // Field GPIO10_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE1_GPIO10_EDGE_HIGH = 1U << 11 ;

  // Field GPIO11_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE1_GPIO11_LEVEL_LOW = 1U << 12 ;

  // Field GPIO11_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE1_GPIO11_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO11_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE1_GPIO11_EDGE_LOW = 1U << 14 ;

  // Field GPIO11_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE1_GPIO11_EDGE_HIGH = 1U << 15 ;

  // Field GPIO12_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE1_GPIO12_LEVEL_LOW = 1U << 16 ;

  // Field GPIO12_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE1_GPIO12_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO12_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE1_GPIO12_EDGE_LOW = 1U << 18 ;

  // Field GPIO12_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE1_GPIO12_EDGE_HIGH = 1U << 19 ;

  // Field GPIO13_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE1_GPIO13_LEVEL_LOW = 1U << 20 ;

  // Field GPIO13_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE1_GPIO13_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO13_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE1_GPIO13_EDGE_LOW = 1U << 22 ;

  // Field GPIO13_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE1_GPIO13_EDGE_HIGH = 1U << 23 ;

  // Field GPIO14_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE1_GPIO14_LEVEL_LOW = 1U << 24 ;

  // Field GPIO14_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE1_GPIO14_LEVEL_HIGH = 1U << 25 ;

  // Field GPIO14_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE1_GPIO14_EDGE_LOW = 1U << 26 ;

  // Field GPIO14_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE1_GPIO14_EDGE_HIGH = 1U << 27 ;

  // Field GPIO15_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE1_GPIO15_LEVEL_LOW = 1U << 28 ;

  // Field GPIO15_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE1_GPIO15_LEVEL_HIGH = 1U << 29 ;

  // Field GPIO15_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE1_GPIO15_EDGE_LOW = 1U << 30 ;

  // Field GPIO15_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE1_GPIO15_EDGE_HIGH = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register PROC0_INTE2: Interrupt Enable for proc0
  static volatile uint32_t & IO_BANK0_PROC0_INTE2 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 264)) ;

  // Field GPIO16_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE2_GPIO16_LEVEL_LOW = 1U << 0 ;

  // Field GPIO16_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE2_GPIO16_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO16_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE2_GPIO16_EDGE_LOW = 1U << 2 ;

  // Field GPIO16_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE2_GPIO16_EDGE_HIGH = 1U << 3 ;

  // Field GPIO17_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE2_GPIO17_LEVEL_LOW = 1U << 4 ;

  // Field GPIO17_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE2_GPIO17_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO17_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE2_GPIO17_EDGE_LOW = 1U << 6 ;

  // Field GPIO17_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE2_GPIO17_EDGE_HIGH = 1U << 7 ;

  // Field GPIO18_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE2_GPIO18_LEVEL_LOW = 1U << 8 ;

  // Field GPIO18_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE2_GPIO18_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO18_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE2_GPIO18_EDGE_LOW = 1U << 10 ;

  // Field GPIO18_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE2_GPIO18_EDGE_HIGH = 1U << 11 ;

  // Field GPIO19_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE2_GPIO19_LEVEL_LOW = 1U << 12 ;

  // Field GPIO19_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE2_GPIO19_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO19_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE2_GPIO19_EDGE_LOW = 1U << 14 ;

  // Field GPIO19_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE2_GPIO19_EDGE_HIGH = 1U << 15 ;

  // Field GPIO20_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE2_GPIO20_LEVEL_LOW = 1U << 16 ;

  // Field GPIO20_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE2_GPIO20_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO20_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE2_GPIO20_EDGE_LOW = 1U << 18 ;

  // Field GPIO20_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE2_GPIO20_EDGE_HIGH = 1U << 19 ;

  // Field GPIO21_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE2_GPIO21_LEVEL_LOW = 1U << 20 ;

  // Field GPIO21_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE2_GPIO21_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO21_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE2_GPIO21_EDGE_LOW = 1U << 22 ;

  // Field GPIO21_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE2_GPIO21_EDGE_HIGH = 1U << 23 ;

  // Field GPIO22_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE2_GPIO22_LEVEL_LOW = 1U << 24 ;

  // Field GPIO22_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE2_GPIO22_LEVEL_HIGH = 1U << 25 ;

  // Field GPIO22_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE2_GPIO22_EDGE_LOW = 1U << 26 ;

  // Field GPIO22_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE2_GPIO22_EDGE_HIGH = 1U << 27 ;

  // Field GPIO23_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE2_GPIO23_LEVEL_LOW = 1U << 28 ;

  // Field GPIO23_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE2_GPIO23_LEVEL_HIGH = 1U << 29 ;

  // Field GPIO23_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE2_GPIO23_EDGE_LOW = 1U << 30 ;

  // Field GPIO23_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE2_GPIO23_EDGE_HIGH = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register PROC0_INTE3: Interrupt Enable for proc0
  static volatile uint32_t & IO_BANK0_PROC0_INTE3 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 268)) ;

  // Field GPIO24_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE3_GPIO24_LEVEL_LOW = 1U << 0 ;

  // Field GPIO24_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE3_GPIO24_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO24_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE3_GPIO24_EDGE_LOW = 1U << 2 ;

  // Field GPIO24_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE3_GPIO24_EDGE_HIGH = 1U << 3 ;

  // Field GPIO25_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE3_GPIO25_LEVEL_LOW = 1U << 4 ;

  // Field GPIO25_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE3_GPIO25_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO25_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE3_GPIO25_EDGE_LOW = 1U << 6 ;

  // Field GPIO25_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE3_GPIO25_EDGE_HIGH = 1U << 7 ;

  // Field GPIO26_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE3_GPIO26_LEVEL_LOW = 1U << 8 ;

  // Field GPIO26_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE3_GPIO26_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO26_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE3_GPIO26_EDGE_LOW = 1U << 10 ;

  // Field GPIO26_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE3_GPIO26_EDGE_HIGH = 1U << 11 ;

  // Field GPIO27_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE3_GPIO27_LEVEL_LOW = 1U << 12 ;

  // Field GPIO27_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE3_GPIO27_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO27_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE3_GPIO27_EDGE_LOW = 1U << 14 ;

  // Field GPIO27_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE3_GPIO27_EDGE_HIGH = 1U << 15 ;

  // Field GPIO28_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE3_GPIO28_LEVEL_LOW = 1U << 16 ;

  // Field GPIO28_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE3_GPIO28_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO28_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE3_GPIO28_EDGE_LOW = 1U << 18 ;

  // Field GPIO28_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE3_GPIO28_EDGE_HIGH = 1U << 19 ;

  // Field GPIO29_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE3_GPIO29_LEVEL_LOW = 1U << 20 ;

  // Field GPIO29_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE3_GPIO29_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO29_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTE3_GPIO29_EDGE_LOW = 1U << 22 ;

  // Field GPIO29_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTE3_GPIO29_EDGE_HIGH = 1U << 23 ;

//------------------------------------------------------------------------------

//---  Register PROC0_INTF0: Interrupt Force for proc0
  static volatile uint32_t & IO_BANK0_PROC0_INTF0 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 272)) ;

  // Field GPIO0_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF0_GPIO0_LEVEL_LOW = 1U << 0 ;

  // Field GPIO0_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF0_GPIO0_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO0_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF0_GPIO0_EDGE_LOW = 1U << 2 ;

  // Field GPIO0_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF0_GPIO0_EDGE_HIGH = 1U << 3 ;

  // Field GPIO1_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF0_GPIO1_LEVEL_LOW = 1U << 4 ;

  // Field GPIO1_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF0_GPIO1_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO1_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF0_GPIO1_EDGE_LOW = 1U << 6 ;

  // Field GPIO1_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF0_GPIO1_EDGE_HIGH = 1U << 7 ;

  // Field GPIO2_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF0_GPIO2_LEVEL_LOW = 1U << 8 ;

  // Field GPIO2_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF0_GPIO2_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO2_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF0_GPIO2_EDGE_LOW = 1U << 10 ;

  // Field GPIO2_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF0_GPIO2_EDGE_HIGH = 1U << 11 ;

  // Field GPIO3_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF0_GPIO3_LEVEL_LOW = 1U << 12 ;

  // Field GPIO3_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF0_GPIO3_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO3_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF0_GPIO3_EDGE_LOW = 1U << 14 ;

  // Field GPIO3_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF0_GPIO3_EDGE_HIGH = 1U << 15 ;

  // Field GPIO4_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF0_GPIO4_LEVEL_LOW = 1U << 16 ;

  // Field GPIO4_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF0_GPIO4_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO4_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF0_GPIO4_EDGE_LOW = 1U << 18 ;

  // Field GPIO4_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF0_GPIO4_EDGE_HIGH = 1U << 19 ;

  // Field GPIO5_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF0_GPIO5_LEVEL_LOW = 1U << 20 ;

  // Field GPIO5_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF0_GPIO5_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO5_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF0_GPIO5_EDGE_LOW = 1U << 22 ;

  // Field GPIO5_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF0_GPIO5_EDGE_HIGH = 1U << 23 ;

  // Field GPIO6_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF0_GPIO6_LEVEL_LOW = 1U << 24 ;

  // Field GPIO6_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF0_GPIO6_LEVEL_HIGH = 1U << 25 ;

  // Field GPIO6_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF0_GPIO6_EDGE_LOW = 1U << 26 ;

  // Field GPIO6_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF0_GPIO6_EDGE_HIGH = 1U << 27 ;

  // Field GPIO7_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF0_GPIO7_LEVEL_LOW = 1U << 28 ;

  // Field GPIO7_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF0_GPIO7_LEVEL_HIGH = 1U << 29 ;

  // Field GPIO7_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF0_GPIO7_EDGE_LOW = 1U << 30 ;

  // Field GPIO7_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF0_GPIO7_EDGE_HIGH = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register PROC0_INTF1: Interrupt Force for proc0
  static volatile uint32_t & IO_BANK0_PROC0_INTF1 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 276)) ;

  // Field GPIO8_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF1_GPIO8_LEVEL_LOW = 1U << 0 ;

  // Field GPIO8_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF1_GPIO8_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO8_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF1_GPIO8_EDGE_LOW = 1U << 2 ;

  // Field GPIO8_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF1_GPIO8_EDGE_HIGH = 1U << 3 ;

  // Field GPIO9_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF1_GPIO9_LEVEL_LOW = 1U << 4 ;

  // Field GPIO9_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF1_GPIO9_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO9_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF1_GPIO9_EDGE_LOW = 1U << 6 ;

  // Field GPIO9_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF1_GPIO9_EDGE_HIGH = 1U << 7 ;

  // Field GPIO10_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF1_GPIO10_LEVEL_LOW = 1U << 8 ;

  // Field GPIO10_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF1_GPIO10_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO10_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF1_GPIO10_EDGE_LOW = 1U << 10 ;

  // Field GPIO10_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF1_GPIO10_EDGE_HIGH = 1U << 11 ;

  // Field GPIO11_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF1_GPIO11_LEVEL_LOW = 1U << 12 ;

  // Field GPIO11_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF1_GPIO11_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO11_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF1_GPIO11_EDGE_LOW = 1U << 14 ;

  // Field GPIO11_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF1_GPIO11_EDGE_HIGH = 1U << 15 ;

  // Field GPIO12_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF1_GPIO12_LEVEL_LOW = 1U << 16 ;

  // Field GPIO12_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF1_GPIO12_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO12_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF1_GPIO12_EDGE_LOW = 1U << 18 ;

  // Field GPIO12_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF1_GPIO12_EDGE_HIGH = 1U << 19 ;

  // Field GPIO13_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF1_GPIO13_LEVEL_LOW = 1U << 20 ;

  // Field GPIO13_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF1_GPIO13_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO13_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF1_GPIO13_EDGE_LOW = 1U << 22 ;

  // Field GPIO13_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF1_GPIO13_EDGE_HIGH = 1U << 23 ;

  // Field GPIO14_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF1_GPIO14_LEVEL_LOW = 1U << 24 ;

  // Field GPIO14_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF1_GPIO14_LEVEL_HIGH = 1U << 25 ;

  // Field GPIO14_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF1_GPIO14_EDGE_LOW = 1U << 26 ;

  // Field GPIO14_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF1_GPIO14_EDGE_HIGH = 1U << 27 ;

  // Field GPIO15_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF1_GPIO15_LEVEL_LOW = 1U << 28 ;

  // Field GPIO15_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF1_GPIO15_LEVEL_HIGH = 1U << 29 ;

  // Field GPIO15_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF1_GPIO15_EDGE_LOW = 1U << 30 ;

  // Field GPIO15_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF1_GPIO15_EDGE_HIGH = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register PROC0_INTF2: Interrupt Force for proc0
  static volatile uint32_t & IO_BANK0_PROC0_INTF2 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 280)) ;

  // Field GPIO16_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF2_GPIO16_LEVEL_LOW = 1U << 0 ;

  // Field GPIO16_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF2_GPIO16_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO16_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF2_GPIO16_EDGE_LOW = 1U << 2 ;

  // Field GPIO16_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF2_GPIO16_EDGE_HIGH = 1U << 3 ;

  // Field GPIO17_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF2_GPIO17_LEVEL_LOW = 1U << 4 ;

  // Field GPIO17_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF2_GPIO17_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO17_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF2_GPIO17_EDGE_LOW = 1U << 6 ;

  // Field GPIO17_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF2_GPIO17_EDGE_HIGH = 1U << 7 ;

  // Field GPIO18_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF2_GPIO18_LEVEL_LOW = 1U << 8 ;

  // Field GPIO18_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF2_GPIO18_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO18_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF2_GPIO18_EDGE_LOW = 1U << 10 ;

  // Field GPIO18_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF2_GPIO18_EDGE_HIGH = 1U << 11 ;

  // Field GPIO19_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF2_GPIO19_LEVEL_LOW = 1U << 12 ;

  // Field GPIO19_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF2_GPIO19_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO19_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF2_GPIO19_EDGE_LOW = 1U << 14 ;

  // Field GPIO19_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF2_GPIO19_EDGE_HIGH = 1U << 15 ;

  // Field GPIO20_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF2_GPIO20_LEVEL_LOW = 1U << 16 ;

  // Field GPIO20_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF2_GPIO20_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO20_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF2_GPIO20_EDGE_LOW = 1U << 18 ;

  // Field GPIO20_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF2_GPIO20_EDGE_HIGH = 1U << 19 ;

  // Field GPIO21_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF2_GPIO21_LEVEL_LOW = 1U << 20 ;

  // Field GPIO21_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF2_GPIO21_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO21_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF2_GPIO21_EDGE_LOW = 1U << 22 ;

  // Field GPIO21_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF2_GPIO21_EDGE_HIGH = 1U << 23 ;

  // Field GPIO22_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF2_GPIO22_LEVEL_LOW = 1U << 24 ;

  // Field GPIO22_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF2_GPIO22_LEVEL_HIGH = 1U << 25 ;

  // Field GPIO22_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF2_GPIO22_EDGE_LOW = 1U << 26 ;

  // Field GPIO22_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF2_GPIO22_EDGE_HIGH = 1U << 27 ;

  // Field GPIO23_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF2_GPIO23_LEVEL_LOW = 1U << 28 ;

  // Field GPIO23_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF2_GPIO23_LEVEL_HIGH = 1U << 29 ;

  // Field GPIO23_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF2_GPIO23_EDGE_LOW = 1U << 30 ;

  // Field GPIO23_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF2_GPIO23_EDGE_HIGH = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register PROC0_INTF3: Interrupt Force for proc0
  static volatile uint32_t & IO_BANK0_PROC0_INTF3 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 284)) ;

  // Field GPIO24_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF3_GPIO24_LEVEL_LOW = 1U << 0 ;

  // Field GPIO24_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF3_GPIO24_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO24_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF3_GPIO24_EDGE_LOW = 1U << 2 ;

  // Field GPIO24_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF3_GPIO24_EDGE_HIGH = 1U << 3 ;

  // Field GPIO25_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF3_GPIO25_LEVEL_LOW = 1U << 4 ;

  // Field GPIO25_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF3_GPIO25_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO25_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF3_GPIO25_EDGE_LOW = 1U << 6 ;

  // Field GPIO25_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF3_GPIO25_EDGE_HIGH = 1U << 7 ;

  // Field GPIO26_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF3_GPIO26_LEVEL_LOW = 1U << 8 ;

  // Field GPIO26_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF3_GPIO26_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO26_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF3_GPIO26_EDGE_LOW = 1U << 10 ;

  // Field GPIO26_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF3_GPIO26_EDGE_HIGH = 1U << 11 ;

  // Field GPIO27_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF3_GPIO27_LEVEL_LOW = 1U << 12 ;

  // Field GPIO27_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF3_GPIO27_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO27_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF3_GPIO27_EDGE_LOW = 1U << 14 ;

  // Field GPIO27_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF3_GPIO27_EDGE_HIGH = 1U << 15 ;

  // Field GPIO28_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF3_GPIO28_LEVEL_LOW = 1U << 16 ;

  // Field GPIO28_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF3_GPIO28_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO28_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF3_GPIO28_EDGE_LOW = 1U << 18 ;

  // Field GPIO28_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF3_GPIO28_EDGE_HIGH = 1U << 19 ;

  // Field GPIO29_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF3_GPIO29_LEVEL_LOW = 1U << 20 ;

  // Field GPIO29_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF3_GPIO29_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO29_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTF3_GPIO29_EDGE_LOW = 1U << 22 ;

  // Field GPIO29_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTF3_GPIO29_EDGE_HIGH = 1U << 23 ;

//------------------------------------------------------------------------------

//---  Register PROC0_INTS0: Interrupt status after masking & forcing for proc0
  static volatile uint32_t & IO_BANK0_PROC0_INTS0 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 288)) ;

  // Field GPIO0_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS0_GPIO0_LEVEL_LOW = 1U << 0 ;

  // Field GPIO0_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS0_GPIO0_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO0_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS0_GPIO0_EDGE_LOW = 1U << 2 ;

  // Field GPIO0_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS0_GPIO0_EDGE_HIGH = 1U << 3 ;

  // Field GPIO1_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS0_GPIO1_LEVEL_LOW = 1U << 4 ;

  // Field GPIO1_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS0_GPIO1_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO1_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS0_GPIO1_EDGE_LOW = 1U << 6 ;

  // Field GPIO1_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS0_GPIO1_EDGE_HIGH = 1U << 7 ;

  // Field GPIO2_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS0_GPIO2_LEVEL_LOW = 1U << 8 ;

  // Field GPIO2_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS0_GPIO2_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO2_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS0_GPIO2_EDGE_LOW = 1U << 10 ;

  // Field GPIO2_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS0_GPIO2_EDGE_HIGH = 1U << 11 ;

  // Field GPIO3_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS0_GPIO3_LEVEL_LOW = 1U << 12 ;

  // Field GPIO3_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS0_GPIO3_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO3_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS0_GPIO3_EDGE_LOW = 1U << 14 ;

  // Field GPIO3_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS0_GPIO3_EDGE_HIGH = 1U << 15 ;

  // Field GPIO4_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS0_GPIO4_LEVEL_LOW = 1U << 16 ;

  // Field GPIO4_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS0_GPIO4_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO4_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS0_GPIO4_EDGE_LOW = 1U << 18 ;

  // Field GPIO4_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS0_GPIO4_EDGE_HIGH = 1U << 19 ;

  // Field GPIO5_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS0_GPIO5_LEVEL_LOW = 1U << 20 ;

  // Field GPIO5_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS0_GPIO5_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO5_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS0_GPIO5_EDGE_LOW = 1U << 22 ;

  // Field GPIO5_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS0_GPIO5_EDGE_HIGH = 1U << 23 ;

  // Field GPIO6_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS0_GPIO6_LEVEL_LOW = 1U << 24 ;

  // Field GPIO6_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS0_GPIO6_LEVEL_HIGH = 1U << 25 ;

  // Field GPIO6_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS0_GPIO6_EDGE_LOW = 1U << 26 ;

  // Field GPIO6_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS0_GPIO6_EDGE_HIGH = 1U << 27 ;

  // Field GPIO7_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS0_GPIO7_LEVEL_LOW = 1U << 28 ;

  // Field GPIO7_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS0_GPIO7_LEVEL_HIGH = 1U << 29 ;

  // Field GPIO7_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS0_GPIO7_EDGE_LOW = 1U << 30 ;

  // Field GPIO7_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS0_GPIO7_EDGE_HIGH = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register PROC0_INTS1: Interrupt status after masking & forcing for proc0
  static volatile uint32_t & IO_BANK0_PROC0_INTS1 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 292)) ;

  // Field GPIO8_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS1_GPIO8_LEVEL_LOW = 1U << 0 ;

  // Field GPIO8_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS1_GPIO8_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO8_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS1_GPIO8_EDGE_LOW = 1U << 2 ;

  // Field GPIO8_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS1_GPIO8_EDGE_HIGH = 1U << 3 ;

  // Field GPIO9_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS1_GPIO9_LEVEL_LOW = 1U << 4 ;

  // Field GPIO9_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS1_GPIO9_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO9_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS1_GPIO9_EDGE_LOW = 1U << 6 ;

  // Field GPIO9_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS1_GPIO9_EDGE_HIGH = 1U << 7 ;

  // Field GPIO10_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS1_GPIO10_LEVEL_LOW = 1U << 8 ;

  // Field GPIO10_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS1_GPIO10_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO10_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS1_GPIO10_EDGE_LOW = 1U << 10 ;

  // Field GPIO10_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS1_GPIO10_EDGE_HIGH = 1U << 11 ;

  // Field GPIO11_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS1_GPIO11_LEVEL_LOW = 1U << 12 ;

  // Field GPIO11_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS1_GPIO11_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO11_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS1_GPIO11_EDGE_LOW = 1U << 14 ;

  // Field GPIO11_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS1_GPIO11_EDGE_HIGH = 1U << 15 ;

  // Field GPIO12_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS1_GPIO12_LEVEL_LOW = 1U << 16 ;

  // Field GPIO12_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS1_GPIO12_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO12_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS1_GPIO12_EDGE_LOW = 1U << 18 ;

  // Field GPIO12_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS1_GPIO12_EDGE_HIGH = 1U << 19 ;

  // Field GPIO13_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS1_GPIO13_LEVEL_LOW = 1U << 20 ;

  // Field GPIO13_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS1_GPIO13_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO13_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS1_GPIO13_EDGE_LOW = 1U << 22 ;

  // Field GPIO13_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS1_GPIO13_EDGE_HIGH = 1U << 23 ;

  // Field GPIO14_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS1_GPIO14_LEVEL_LOW = 1U << 24 ;

  // Field GPIO14_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS1_GPIO14_LEVEL_HIGH = 1U << 25 ;

  // Field GPIO14_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS1_GPIO14_EDGE_LOW = 1U << 26 ;

  // Field GPIO14_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS1_GPIO14_EDGE_HIGH = 1U << 27 ;

  // Field GPIO15_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS1_GPIO15_LEVEL_LOW = 1U << 28 ;

  // Field GPIO15_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS1_GPIO15_LEVEL_HIGH = 1U << 29 ;

  // Field GPIO15_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS1_GPIO15_EDGE_LOW = 1U << 30 ;

  // Field GPIO15_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS1_GPIO15_EDGE_HIGH = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register PROC0_INTS2: Interrupt status after masking & forcing for proc0
  static volatile uint32_t & IO_BANK0_PROC0_INTS2 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 296)) ;

  // Field GPIO16_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS2_GPIO16_LEVEL_LOW = 1U << 0 ;

  // Field GPIO16_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS2_GPIO16_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO16_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS2_GPIO16_EDGE_LOW = 1U << 2 ;

  // Field GPIO16_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS2_GPIO16_EDGE_HIGH = 1U << 3 ;

  // Field GPIO17_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS2_GPIO17_LEVEL_LOW = 1U << 4 ;

  // Field GPIO17_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS2_GPIO17_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO17_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS2_GPIO17_EDGE_LOW = 1U << 6 ;

  // Field GPIO17_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS2_GPIO17_EDGE_HIGH = 1U << 7 ;

  // Field GPIO18_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS2_GPIO18_LEVEL_LOW = 1U << 8 ;

  // Field GPIO18_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS2_GPIO18_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO18_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS2_GPIO18_EDGE_LOW = 1U << 10 ;

  // Field GPIO18_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS2_GPIO18_EDGE_HIGH = 1U << 11 ;

  // Field GPIO19_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS2_GPIO19_LEVEL_LOW = 1U << 12 ;

  // Field GPIO19_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS2_GPIO19_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO19_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS2_GPIO19_EDGE_LOW = 1U << 14 ;

  // Field GPIO19_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS2_GPIO19_EDGE_HIGH = 1U << 15 ;

  // Field GPIO20_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS2_GPIO20_LEVEL_LOW = 1U << 16 ;

  // Field GPIO20_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS2_GPIO20_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO20_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS2_GPIO20_EDGE_LOW = 1U << 18 ;

  // Field GPIO20_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS2_GPIO20_EDGE_HIGH = 1U << 19 ;

  // Field GPIO21_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS2_GPIO21_LEVEL_LOW = 1U << 20 ;

  // Field GPIO21_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS2_GPIO21_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO21_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS2_GPIO21_EDGE_LOW = 1U << 22 ;

  // Field GPIO21_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS2_GPIO21_EDGE_HIGH = 1U << 23 ;

  // Field GPIO22_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS2_GPIO22_LEVEL_LOW = 1U << 24 ;

  // Field GPIO22_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS2_GPIO22_LEVEL_HIGH = 1U << 25 ;

  // Field GPIO22_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS2_GPIO22_EDGE_LOW = 1U << 26 ;

  // Field GPIO22_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS2_GPIO22_EDGE_HIGH = 1U << 27 ;

  // Field GPIO23_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS2_GPIO23_LEVEL_LOW = 1U << 28 ;

  // Field GPIO23_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS2_GPIO23_LEVEL_HIGH = 1U << 29 ;

  // Field GPIO23_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS2_GPIO23_EDGE_LOW = 1U << 30 ;

  // Field GPIO23_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS2_GPIO23_EDGE_HIGH = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register PROC0_INTS3: Interrupt status after masking & forcing for proc0
  static volatile uint32_t & IO_BANK0_PROC0_INTS3 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 300)) ;

  // Field GPIO24_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS3_GPIO24_LEVEL_LOW = 1U << 0 ;

  // Field GPIO24_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS3_GPIO24_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO24_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS3_GPIO24_EDGE_LOW = 1U << 2 ;

  // Field GPIO24_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS3_GPIO24_EDGE_HIGH = 1U << 3 ;

  // Field GPIO25_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS3_GPIO25_LEVEL_LOW = 1U << 4 ;

  // Field GPIO25_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS3_GPIO25_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO25_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS3_GPIO25_EDGE_LOW = 1U << 6 ;

  // Field GPIO25_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS3_GPIO25_EDGE_HIGH = 1U << 7 ;

  // Field GPIO26_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS3_GPIO26_LEVEL_LOW = 1U << 8 ;

  // Field GPIO26_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS3_GPIO26_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO26_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS3_GPIO26_EDGE_LOW = 1U << 10 ;

  // Field GPIO26_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS3_GPIO26_EDGE_HIGH = 1U << 11 ;

  // Field GPIO27_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS3_GPIO27_LEVEL_LOW = 1U << 12 ;

  // Field GPIO27_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS3_GPIO27_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO27_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS3_GPIO27_EDGE_LOW = 1U << 14 ;

  // Field GPIO27_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS3_GPIO27_EDGE_HIGH = 1U << 15 ;

  // Field GPIO28_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS3_GPIO28_LEVEL_LOW = 1U << 16 ;

  // Field GPIO28_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS3_GPIO28_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO28_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS3_GPIO28_EDGE_LOW = 1U << 18 ;

  // Field GPIO28_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS3_GPIO28_EDGE_HIGH = 1U << 19 ;

  // Field GPIO29_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS3_GPIO29_LEVEL_LOW = 1U << 20 ;

  // Field GPIO29_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS3_GPIO29_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO29_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC0_INTS3_GPIO29_EDGE_LOW = 1U << 22 ;

  // Field GPIO29_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC0_INTS3_GPIO29_EDGE_HIGH = 1U << 23 ;

//------------------------------------------------------------------------------

//---  Register PROC1_INTE0: Interrupt Enable for proc1
  static volatile uint32_t & IO_BANK0_PROC1_INTE0 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 304)) ;

  // Field GPIO0_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE0_GPIO0_LEVEL_LOW = 1U << 0 ;

  // Field GPIO0_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE0_GPIO0_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO0_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE0_GPIO0_EDGE_LOW = 1U << 2 ;

  // Field GPIO0_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE0_GPIO0_EDGE_HIGH = 1U << 3 ;

  // Field GPIO1_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE0_GPIO1_LEVEL_LOW = 1U << 4 ;

  // Field GPIO1_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE0_GPIO1_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO1_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE0_GPIO1_EDGE_LOW = 1U << 6 ;

  // Field GPIO1_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE0_GPIO1_EDGE_HIGH = 1U << 7 ;

  // Field GPIO2_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE0_GPIO2_LEVEL_LOW = 1U << 8 ;

  // Field GPIO2_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE0_GPIO2_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO2_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE0_GPIO2_EDGE_LOW = 1U << 10 ;

  // Field GPIO2_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE0_GPIO2_EDGE_HIGH = 1U << 11 ;

  // Field GPIO3_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE0_GPIO3_LEVEL_LOW = 1U << 12 ;

  // Field GPIO3_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE0_GPIO3_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO3_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE0_GPIO3_EDGE_LOW = 1U << 14 ;

  // Field GPIO3_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE0_GPIO3_EDGE_HIGH = 1U << 15 ;

  // Field GPIO4_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE0_GPIO4_LEVEL_LOW = 1U << 16 ;

  // Field GPIO4_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE0_GPIO4_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO4_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE0_GPIO4_EDGE_LOW = 1U << 18 ;

  // Field GPIO4_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE0_GPIO4_EDGE_HIGH = 1U << 19 ;

  // Field GPIO5_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE0_GPIO5_LEVEL_LOW = 1U << 20 ;

  // Field GPIO5_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE0_GPIO5_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO5_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE0_GPIO5_EDGE_LOW = 1U << 22 ;

  // Field GPIO5_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE0_GPIO5_EDGE_HIGH = 1U << 23 ;

  // Field GPIO6_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE0_GPIO6_LEVEL_LOW = 1U << 24 ;

  // Field GPIO6_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE0_GPIO6_LEVEL_HIGH = 1U << 25 ;

  // Field GPIO6_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE0_GPIO6_EDGE_LOW = 1U << 26 ;

  // Field GPIO6_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE0_GPIO6_EDGE_HIGH = 1U << 27 ;

  // Field GPIO7_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE0_GPIO7_LEVEL_LOW = 1U << 28 ;

  // Field GPIO7_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE0_GPIO7_LEVEL_HIGH = 1U << 29 ;

  // Field GPIO7_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE0_GPIO7_EDGE_LOW = 1U << 30 ;

  // Field GPIO7_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE0_GPIO7_EDGE_HIGH = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register PROC1_INTE1: Interrupt Enable for proc1
  static volatile uint32_t & IO_BANK0_PROC1_INTE1 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 308)) ;

  // Field GPIO8_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE1_GPIO8_LEVEL_LOW = 1U << 0 ;

  // Field GPIO8_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE1_GPIO8_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO8_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE1_GPIO8_EDGE_LOW = 1U << 2 ;

  // Field GPIO8_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE1_GPIO8_EDGE_HIGH = 1U << 3 ;

  // Field GPIO9_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE1_GPIO9_LEVEL_LOW = 1U << 4 ;

  // Field GPIO9_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE1_GPIO9_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO9_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE1_GPIO9_EDGE_LOW = 1U << 6 ;

  // Field GPIO9_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE1_GPIO9_EDGE_HIGH = 1U << 7 ;

  // Field GPIO10_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE1_GPIO10_LEVEL_LOW = 1U << 8 ;

  // Field GPIO10_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE1_GPIO10_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO10_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE1_GPIO10_EDGE_LOW = 1U << 10 ;

  // Field GPIO10_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE1_GPIO10_EDGE_HIGH = 1U << 11 ;

  // Field GPIO11_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE1_GPIO11_LEVEL_LOW = 1U << 12 ;

  // Field GPIO11_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE1_GPIO11_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO11_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE1_GPIO11_EDGE_LOW = 1U << 14 ;

  // Field GPIO11_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE1_GPIO11_EDGE_HIGH = 1U << 15 ;

  // Field GPIO12_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE1_GPIO12_LEVEL_LOW = 1U << 16 ;

  // Field GPIO12_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE1_GPIO12_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO12_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE1_GPIO12_EDGE_LOW = 1U << 18 ;

  // Field GPIO12_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE1_GPIO12_EDGE_HIGH = 1U << 19 ;

  // Field GPIO13_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE1_GPIO13_LEVEL_LOW = 1U << 20 ;

  // Field GPIO13_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE1_GPIO13_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO13_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE1_GPIO13_EDGE_LOW = 1U << 22 ;

  // Field GPIO13_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE1_GPIO13_EDGE_HIGH = 1U << 23 ;

  // Field GPIO14_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE1_GPIO14_LEVEL_LOW = 1U << 24 ;

  // Field GPIO14_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE1_GPIO14_LEVEL_HIGH = 1U << 25 ;

  // Field GPIO14_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE1_GPIO14_EDGE_LOW = 1U << 26 ;

  // Field GPIO14_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE1_GPIO14_EDGE_HIGH = 1U << 27 ;

  // Field GPIO15_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE1_GPIO15_LEVEL_LOW = 1U << 28 ;

  // Field GPIO15_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE1_GPIO15_LEVEL_HIGH = 1U << 29 ;

  // Field GPIO15_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE1_GPIO15_EDGE_LOW = 1U << 30 ;

  // Field GPIO15_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE1_GPIO15_EDGE_HIGH = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register PROC1_INTE2: Interrupt Enable for proc1
  static volatile uint32_t & IO_BANK0_PROC1_INTE2 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 312)) ;

  // Field GPIO16_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE2_GPIO16_LEVEL_LOW = 1U << 0 ;

  // Field GPIO16_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE2_GPIO16_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO16_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE2_GPIO16_EDGE_LOW = 1U << 2 ;

  // Field GPIO16_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE2_GPIO16_EDGE_HIGH = 1U << 3 ;

  // Field GPIO17_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE2_GPIO17_LEVEL_LOW = 1U << 4 ;

  // Field GPIO17_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE2_GPIO17_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO17_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE2_GPIO17_EDGE_LOW = 1U << 6 ;

  // Field GPIO17_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE2_GPIO17_EDGE_HIGH = 1U << 7 ;

  // Field GPIO18_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE2_GPIO18_LEVEL_LOW = 1U << 8 ;

  // Field GPIO18_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE2_GPIO18_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO18_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE2_GPIO18_EDGE_LOW = 1U << 10 ;

  // Field GPIO18_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE2_GPIO18_EDGE_HIGH = 1U << 11 ;

  // Field GPIO19_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE2_GPIO19_LEVEL_LOW = 1U << 12 ;

  // Field GPIO19_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE2_GPIO19_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO19_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE2_GPIO19_EDGE_LOW = 1U << 14 ;

  // Field GPIO19_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE2_GPIO19_EDGE_HIGH = 1U << 15 ;

  // Field GPIO20_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE2_GPIO20_LEVEL_LOW = 1U << 16 ;

  // Field GPIO20_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE2_GPIO20_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO20_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE2_GPIO20_EDGE_LOW = 1U << 18 ;

  // Field GPIO20_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE2_GPIO20_EDGE_HIGH = 1U << 19 ;

  // Field GPIO21_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE2_GPIO21_LEVEL_LOW = 1U << 20 ;

  // Field GPIO21_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE2_GPIO21_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO21_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE2_GPIO21_EDGE_LOW = 1U << 22 ;

  // Field GPIO21_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE2_GPIO21_EDGE_HIGH = 1U << 23 ;

  // Field GPIO22_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE2_GPIO22_LEVEL_LOW = 1U << 24 ;

  // Field GPIO22_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE2_GPIO22_LEVEL_HIGH = 1U << 25 ;

  // Field GPIO22_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE2_GPIO22_EDGE_LOW = 1U << 26 ;

  // Field GPIO22_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE2_GPIO22_EDGE_HIGH = 1U << 27 ;

  // Field GPIO23_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE2_GPIO23_LEVEL_LOW = 1U << 28 ;

  // Field GPIO23_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE2_GPIO23_LEVEL_HIGH = 1U << 29 ;

  // Field GPIO23_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE2_GPIO23_EDGE_LOW = 1U << 30 ;

  // Field GPIO23_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE2_GPIO23_EDGE_HIGH = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register PROC1_INTE3: Interrupt Enable for proc1
  static volatile uint32_t & IO_BANK0_PROC1_INTE3 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 316)) ;

  // Field GPIO24_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE3_GPIO24_LEVEL_LOW = 1U << 0 ;

  // Field GPIO24_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE3_GPIO24_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO24_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE3_GPIO24_EDGE_LOW = 1U << 2 ;

  // Field GPIO24_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE3_GPIO24_EDGE_HIGH = 1U << 3 ;

  // Field GPIO25_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE3_GPIO25_LEVEL_LOW = 1U << 4 ;

  // Field GPIO25_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE3_GPIO25_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO25_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE3_GPIO25_EDGE_LOW = 1U << 6 ;

  // Field GPIO25_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE3_GPIO25_EDGE_HIGH = 1U << 7 ;

  // Field GPIO26_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE3_GPIO26_LEVEL_LOW = 1U << 8 ;

  // Field GPIO26_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE3_GPIO26_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO26_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE3_GPIO26_EDGE_LOW = 1U << 10 ;

  // Field GPIO26_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE3_GPIO26_EDGE_HIGH = 1U << 11 ;

  // Field GPIO27_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE3_GPIO27_LEVEL_LOW = 1U << 12 ;

  // Field GPIO27_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE3_GPIO27_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO27_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE3_GPIO27_EDGE_LOW = 1U << 14 ;

  // Field GPIO27_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE3_GPIO27_EDGE_HIGH = 1U << 15 ;

  // Field GPIO28_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE3_GPIO28_LEVEL_LOW = 1U << 16 ;

  // Field GPIO28_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE3_GPIO28_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO28_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE3_GPIO28_EDGE_LOW = 1U << 18 ;

  // Field GPIO28_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE3_GPIO28_EDGE_HIGH = 1U << 19 ;

  // Field GPIO29_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE3_GPIO29_LEVEL_LOW = 1U << 20 ;

  // Field GPIO29_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE3_GPIO29_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO29_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTE3_GPIO29_EDGE_LOW = 1U << 22 ;

  // Field GPIO29_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTE3_GPIO29_EDGE_HIGH = 1U << 23 ;

//------------------------------------------------------------------------------

//---  Register PROC1_INTF0: Interrupt Force for proc1
  static volatile uint32_t & IO_BANK0_PROC1_INTF0 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 320)) ;

  // Field GPIO0_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF0_GPIO0_LEVEL_LOW = 1U << 0 ;

  // Field GPIO0_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF0_GPIO0_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO0_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF0_GPIO0_EDGE_LOW = 1U << 2 ;

  // Field GPIO0_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF0_GPIO0_EDGE_HIGH = 1U << 3 ;

  // Field GPIO1_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF0_GPIO1_LEVEL_LOW = 1U << 4 ;

  // Field GPIO1_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF0_GPIO1_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO1_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF0_GPIO1_EDGE_LOW = 1U << 6 ;

  // Field GPIO1_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF0_GPIO1_EDGE_HIGH = 1U << 7 ;

  // Field GPIO2_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF0_GPIO2_LEVEL_LOW = 1U << 8 ;

  // Field GPIO2_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF0_GPIO2_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO2_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF0_GPIO2_EDGE_LOW = 1U << 10 ;

  // Field GPIO2_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF0_GPIO2_EDGE_HIGH = 1U << 11 ;

  // Field GPIO3_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF0_GPIO3_LEVEL_LOW = 1U << 12 ;

  // Field GPIO3_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF0_GPIO3_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO3_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF0_GPIO3_EDGE_LOW = 1U << 14 ;

  // Field GPIO3_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF0_GPIO3_EDGE_HIGH = 1U << 15 ;

  // Field GPIO4_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF0_GPIO4_LEVEL_LOW = 1U << 16 ;

  // Field GPIO4_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF0_GPIO4_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO4_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF0_GPIO4_EDGE_LOW = 1U << 18 ;

  // Field GPIO4_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF0_GPIO4_EDGE_HIGH = 1U << 19 ;

  // Field GPIO5_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF0_GPIO5_LEVEL_LOW = 1U << 20 ;

  // Field GPIO5_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF0_GPIO5_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO5_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF0_GPIO5_EDGE_LOW = 1U << 22 ;

  // Field GPIO5_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF0_GPIO5_EDGE_HIGH = 1U << 23 ;

  // Field GPIO6_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF0_GPIO6_LEVEL_LOW = 1U << 24 ;

  // Field GPIO6_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF0_GPIO6_LEVEL_HIGH = 1U << 25 ;

  // Field GPIO6_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF0_GPIO6_EDGE_LOW = 1U << 26 ;

  // Field GPIO6_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF0_GPIO6_EDGE_HIGH = 1U << 27 ;

  // Field GPIO7_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF0_GPIO7_LEVEL_LOW = 1U << 28 ;

  // Field GPIO7_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF0_GPIO7_LEVEL_HIGH = 1U << 29 ;

  // Field GPIO7_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF0_GPIO7_EDGE_LOW = 1U << 30 ;

  // Field GPIO7_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF0_GPIO7_EDGE_HIGH = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register PROC1_INTF1: Interrupt Force for proc1
  static volatile uint32_t & IO_BANK0_PROC1_INTF1 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 324)) ;

  // Field GPIO8_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF1_GPIO8_LEVEL_LOW = 1U << 0 ;

  // Field GPIO8_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF1_GPIO8_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO8_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF1_GPIO8_EDGE_LOW = 1U << 2 ;

  // Field GPIO8_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF1_GPIO8_EDGE_HIGH = 1U << 3 ;

  // Field GPIO9_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF1_GPIO9_LEVEL_LOW = 1U << 4 ;

  // Field GPIO9_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF1_GPIO9_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO9_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF1_GPIO9_EDGE_LOW = 1U << 6 ;

  // Field GPIO9_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF1_GPIO9_EDGE_HIGH = 1U << 7 ;

  // Field GPIO10_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF1_GPIO10_LEVEL_LOW = 1U << 8 ;

  // Field GPIO10_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF1_GPIO10_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO10_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF1_GPIO10_EDGE_LOW = 1U << 10 ;

  // Field GPIO10_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF1_GPIO10_EDGE_HIGH = 1U << 11 ;

  // Field GPIO11_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF1_GPIO11_LEVEL_LOW = 1U << 12 ;

  // Field GPIO11_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF1_GPIO11_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO11_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF1_GPIO11_EDGE_LOW = 1U << 14 ;

  // Field GPIO11_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF1_GPIO11_EDGE_HIGH = 1U << 15 ;

  // Field GPIO12_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF1_GPIO12_LEVEL_LOW = 1U << 16 ;

  // Field GPIO12_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF1_GPIO12_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO12_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF1_GPIO12_EDGE_LOW = 1U << 18 ;

  // Field GPIO12_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF1_GPIO12_EDGE_HIGH = 1U << 19 ;

  // Field GPIO13_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF1_GPIO13_LEVEL_LOW = 1U << 20 ;

  // Field GPIO13_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF1_GPIO13_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO13_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF1_GPIO13_EDGE_LOW = 1U << 22 ;

  // Field GPIO13_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF1_GPIO13_EDGE_HIGH = 1U << 23 ;

  // Field GPIO14_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF1_GPIO14_LEVEL_LOW = 1U << 24 ;

  // Field GPIO14_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF1_GPIO14_LEVEL_HIGH = 1U << 25 ;

  // Field GPIO14_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF1_GPIO14_EDGE_LOW = 1U << 26 ;

  // Field GPIO14_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF1_GPIO14_EDGE_HIGH = 1U << 27 ;

  // Field GPIO15_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF1_GPIO15_LEVEL_LOW = 1U << 28 ;

  // Field GPIO15_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF1_GPIO15_LEVEL_HIGH = 1U << 29 ;

  // Field GPIO15_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF1_GPIO15_EDGE_LOW = 1U << 30 ;

  // Field GPIO15_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF1_GPIO15_EDGE_HIGH = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register PROC1_INTF2: Interrupt Force for proc1
  static volatile uint32_t & IO_BANK0_PROC1_INTF2 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 328)) ;

  // Field GPIO16_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF2_GPIO16_LEVEL_LOW = 1U << 0 ;

  // Field GPIO16_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF2_GPIO16_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO16_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF2_GPIO16_EDGE_LOW = 1U << 2 ;

  // Field GPIO16_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF2_GPIO16_EDGE_HIGH = 1U << 3 ;

  // Field GPIO17_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF2_GPIO17_LEVEL_LOW = 1U << 4 ;

  // Field GPIO17_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF2_GPIO17_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO17_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF2_GPIO17_EDGE_LOW = 1U << 6 ;

  // Field GPIO17_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF2_GPIO17_EDGE_HIGH = 1U << 7 ;

  // Field GPIO18_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF2_GPIO18_LEVEL_LOW = 1U << 8 ;

  // Field GPIO18_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF2_GPIO18_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO18_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF2_GPIO18_EDGE_LOW = 1U << 10 ;

  // Field GPIO18_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF2_GPIO18_EDGE_HIGH = 1U << 11 ;

  // Field GPIO19_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF2_GPIO19_LEVEL_LOW = 1U << 12 ;

  // Field GPIO19_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF2_GPIO19_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO19_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF2_GPIO19_EDGE_LOW = 1U << 14 ;

  // Field GPIO19_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF2_GPIO19_EDGE_HIGH = 1U << 15 ;

  // Field GPIO20_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF2_GPIO20_LEVEL_LOW = 1U << 16 ;

  // Field GPIO20_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF2_GPIO20_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO20_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF2_GPIO20_EDGE_LOW = 1U << 18 ;

  // Field GPIO20_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF2_GPIO20_EDGE_HIGH = 1U << 19 ;

  // Field GPIO21_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF2_GPIO21_LEVEL_LOW = 1U << 20 ;

  // Field GPIO21_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF2_GPIO21_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO21_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF2_GPIO21_EDGE_LOW = 1U << 22 ;

  // Field GPIO21_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF2_GPIO21_EDGE_HIGH = 1U << 23 ;

  // Field GPIO22_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF2_GPIO22_LEVEL_LOW = 1U << 24 ;

  // Field GPIO22_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF2_GPIO22_LEVEL_HIGH = 1U << 25 ;

  // Field GPIO22_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF2_GPIO22_EDGE_LOW = 1U << 26 ;

  // Field GPIO22_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF2_GPIO22_EDGE_HIGH = 1U << 27 ;

  // Field GPIO23_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF2_GPIO23_LEVEL_LOW = 1U << 28 ;

  // Field GPIO23_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF2_GPIO23_LEVEL_HIGH = 1U << 29 ;

  // Field GPIO23_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF2_GPIO23_EDGE_LOW = 1U << 30 ;

  // Field GPIO23_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF2_GPIO23_EDGE_HIGH = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register PROC1_INTF3: Interrupt Force for proc1
  static volatile uint32_t & IO_BANK0_PROC1_INTF3 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 332)) ;

  // Field GPIO24_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF3_GPIO24_LEVEL_LOW = 1U << 0 ;

  // Field GPIO24_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF3_GPIO24_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO24_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF3_GPIO24_EDGE_LOW = 1U << 2 ;

  // Field GPIO24_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF3_GPIO24_EDGE_HIGH = 1U << 3 ;

  // Field GPIO25_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF3_GPIO25_LEVEL_LOW = 1U << 4 ;

  // Field GPIO25_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF3_GPIO25_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO25_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF3_GPIO25_EDGE_LOW = 1U << 6 ;

  // Field GPIO25_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF3_GPIO25_EDGE_HIGH = 1U << 7 ;

  // Field GPIO26_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF3_GPIO26_LEVEL_LOW = 1U << 8 ;

  // Field GPIO26_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF3_GPIO26_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO26_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF3_GPIO26_EDGE_LOW = 1U << 10 ;

  // Field GPIO26_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF3_GPIO26_EDGE_HIGH = 1U << 11 ;

  // Field GPIO27_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF3_GPIO27_LEVEL_LOW = 1U << 12 ;

  // Field GPIO27_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF3_GPIO27_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO27_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF3_GPIO27_EDGE_LOW = 1U << 14 ;

  // Field GPIO27_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF3_GPIO27_EDGE_HIGH = 1U << 15 ;

  // Field GPIO28_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF3_GPIO28_LEVEL_LOW = 1U << 16 ;

  // Field GPIO28_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF3_GPIO28_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO28_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF3_GPIO28_EDGE_LOW = 1U << 18 ;

  // Field GPIO28_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF3_GPIO28_EDGE_HIGH = 1U << 19 ;

  // Field GPIO29_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF3_GPIO29_LEVEL_LOW = 1U << 20 ;

  // Field GPIO29_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF3_GPIO29_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO29_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTF3_GPIO29_EDGE_LOW = 1U << 22 ;

  // Field GPIO29_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTF3_GPIO29_EDGE_HIGH = 1U << 23 ;

//------------------------------------------------------------------------------

//---  Register PROC1_INTS0: Interrupt status after masking & forcing for proc1
  static volatile uint32_t & IO_BANK0_PROC1_INTS0 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 336)) ;

  // Field GPIO0_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS0_GPIO0_LEVEL_LOW = 1U << 0 ;

  // Field GPIO0_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS0_GPIO0_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO0_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS0_GPIO0_EDGE_LOW = 1U << 2 ;

  // Field GPIO0_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS0_GPIO0_EDGE_HIGH = 1U << 3 ;

  // Field GPIO1_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS0_GPIO1_LEVEL_LOW = 1U << 4 ;

  // Field GPIO1_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS0_GPIO1_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO1_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS0_GPIO1_EDGE_LOW = 1U << 6 ;

  // Field GPIO1_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS0_GPIO1_EDGE_HIGH = 1U << 7 ;

  // Field GPIO2_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS0_GPIO2_LEVEL_LOW = 1U << 8 ;

  // Field GPIO2_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS0_GPIO2_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO2_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS0_GPIO2_EDGE_LOW = 1U << 10 ;

  // Field GPIO2_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS0_GPIO2_EDGE_HIGH = 1U << 11 ;

  // Field GPIO3_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS0_GPIO3_LEVEL_LOW = 1U << 12 ;

  // Field GPIO3_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS0_GPIO3_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO3_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS0_GPIO3_EDGE_LOW = 1U << 14 ;

  // Field GPIO3_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS0_GPIO3_EDGE_HIGH = 1U << 15 ;

  // Field GPIO4_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS0_GPIO4_LEVEL_LOW = 1U << 16 ;

  // Field GPIO4_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS0_GPIO4_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO4_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS0_GPIO4_EDGE_LOW = 1U << 18 ;

  // Field GPIO4_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS0_GPIO4_EDGE_HIGH = 1U << 19 ;

  // Field GPIO5_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS0_GPIO5_LEVEL_LOW = 1U << 20 ;

  // Field GPIO5_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS0_GPIO5_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO5_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS0_GPIO5_EDGE_LOW = 1U << 22 ;

  // Field GPIO5_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS0_GPIO5_EDGE_HIGH = 1U << 23 ;

  // Field GPIO6_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS0_GPIO6_LEVEL_LOW = 1U << 24 ;

  // Field GPIO6_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS0_GPIO6_LEVEL_HIGH = 1U << 25 ;

  // Field GPIO6_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS0_GPIO6_EDGE_LOW = 1U << 26 ;

  // Field GPIO6_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS0_GPIO6_EDGE_HIGH = 1U << 27 ;

  // Field GPIO7_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS0_GPIO7_LEVEL_LOW = 1U << 28 ;

  // Field GPIO7_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS0_GPIO7_LEVEL_HIGH = 1U << 29 ;

  // Field GPIO7_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS0_GPIO7_EDGE_LOW = 1U << 30 ;

  // Field GPIO7_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS0_GPIO7_EDGE_HIGH = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register PROC1_INTS1: Interrupt status after masking & forcing for proc1
  static volatile uint32_t & IO_BANK0_PROC1_INTS1 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 340)) ;

  // Field GPIO8_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS1_GPIO8_LEVEL_LOW = 1U << 0 ;

  // Field GPIO8_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS1_GPIO8_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO8_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS1_GPIO8_EDGE_LOW = 1U << 2 ;

  // Field GPIO8_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS1_GPIO8_EDGE_HIGH = 1U << 3 ;

  // Field GPIO9_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS1_GPIO9_LEVEL_LOW = 1U << 4 ;

  // Field GPIO9_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS1_GPIO9_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO9_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS1_GPIO9_EDGE_LOW = 1U << 6 ;

  // Field GPIO9_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS1_GPIO9_EDGE_HIGH = 1U << 7 ;

  // Field GPIO10_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS1_GPIO10_LEVEL_LOW = 1U << 8 ;

  // Field GPIO10_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS1_GPIO10_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO10_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS1_GPIO10_EDGE_LOW = 1U << 10 ;

  // Field GPIO10_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS1_GPIO10_EDGE_HIGH = 1U << 11 ;

  // Field GPIO11_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS1_GPIO11_LEVEL_LOW = 1U << 12 ;

  // Field GPIO11_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS1_GPIO11_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO11_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS1_GPIO11_EDGE_LOW = 1U << 14 ;

  // Field GPIO11_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS1_GPIO11_EDGE_HIGH = 1U << 15 ;

  // Field GPIO12_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS1_GPIO12_LEVEL_LOW = 1U << 16 ;

  // Field GPIO12_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS1_GPIO12_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO12_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS1_GPIO12_EDGE_LOW = 1U << 18 ;

  // Field GPIO12_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS1_GPIO12_EDGE_HIGH = 1U << 19 ;

  // Field GPIO13_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS1_GPIO13_LEVEL_LOW = 1U << 20 ;

  // Field GPIO13_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS1_GPIO13_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO13_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS1_GPIO13_EDGE_LOW = 1U << 22 ;

  // Field GPIO13_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS1_GPIO13_EDGE_HIGH = 1U << 23 ;

  // Field GPIO14_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS1_GPIO14_LEVEL_LOW = 1U << 24 ;

  // Field GPIO14_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS1_GPIO14_LEVEL_HIGH = 1U << 25 ;

  // Field GPIO14_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS1_GPIO14_EDGE_LOW = 1U << 26 ;

  // Field GPIO14_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS1_GPIO14_EDGE_HIGH = 1U << 27 ;

  // Field GPIO15_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS1_GPIO15_LEVEL_LOW = 1U << 28 ;

  // Field GPIO15_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS1_GPIO15_LEVEL_HIGH = 1U << 29 ;

  // Field GPIO15_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS1_GPIO15_EDGE_LOW = 1U << 30 ;

  // Field GPIO15_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS1_GPIO15_EDGE_HIGH = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register PROC1_INTS2: Interrupt status after masking & forcing for proc1
  static volatile uint32_t & IO_BANK0_PROC1_INTS2 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 344)) ;

  // Field GPIO16_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS2_GPIO16_LEVEL_LOW = 1U << 0 ;

  // Field GPIO16_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS2_GPIO16_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO16_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS2_GPIO16_EDGE_LOW = 1U << 2 ;

  // Field GPIO16_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS2_GPIO16_EDGE_HIGH = 1U << 3 ;

  // Field GPIO17_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS2_GPIO17_LEVEL_LOW = 1U << 4 ;

  // Field GPIO17_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS2_GPIO17_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO17_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS2_GPIO17_EDGE_LOW = 1U << 6 ;

  // Field GPIO17_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS2_GPIO17_EDGE_HIGH = 1U << 7 ;

  // Field GPIO18_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS2_GPIO18_LEVEL_LOW = 1U << 8 ;

  // Field GPIO18_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS2_GPIO18_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO18_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS2_GPIO18_EDGE_LOW = 1U << 10 ;

  // Field GPIO18_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS2_GPIO18_EDGE_HIGH = 1U << 11 ;

  // Field GPIO19_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS2_GPIO19_LEVEL_LOW = 1U << 12 ;

  // Field GPIO19_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS2_GPIO19_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO19_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS2_GPIO19_EDGE_LOW = 1U << 14 ;

  // Field GPIO19_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS2_GPIO19_EDGE_HIGH = 1U << 15 ;

  // Field GPIO20_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS2_GPIO20_LEVEL_LOW = 1U << 16 ;

  // Field GPIO20_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS2_GPIO20_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO20_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS2_GPIO20_EDGE_LOW = 1U << 18 ;

  // Field GPIO20_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS2_GPIO20_EDGE_HIGH = 1U << 19 ;

  // Field GPIO21_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS2_GPIO21_LEVEL_LOW = 1U << 20 ;

  // Field GPIO21_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS2_GPIO21_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO21_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS2_GPIO21_EDGE_LOW = 1U << 22 ;

  // Field GPIO21_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS2_GPIO21_EDGE_HIGH = 1U << 23 ;

  // Field GPIO22_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS2_GPIO22_LEVEL_LOW = 1U << 24 ;

  // Field GPIO22_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS2_GPIO22_LEVEL_HIGH = 1U << 25 ;

  // Field GPIO22_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS2_GPIO22_EDGE_LOW = 1U << 26 ;

  // Field GPIO22_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS2_GPIO22_EDGE_HIGH = 1U << 27 ;

  // Field GPIO23_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS2_GPIO23_LEVEL_LOW = 1U << 28 ;

  // Field GPIO23_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS2_GPIO23_LEVEL_HIGH = 1U << 29 ;

  // Field GPIO23_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS2_GPIO23_EDGE_LOW = 1U << 30 ;

  // Field GPIO23_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS2_GPIO23_EDGE_HIGH = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register PROC1_INTS3: Interrupt status after masking & forcing for proc1
  static volatile uint32_t & IO_BANK0_PROC1_INTS3 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 348)) ;

  // Field GPIO24_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS3_GPIO24_LEVEL_LOW = 1U << 0 ;

  // Field GPIO24_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS3_GPIO24_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO24_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS3_GPIO24_EDGE_LOW = 1U << 2 ;

  // Field GPIO24_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS3_GPIO24_EDGE_HIGH = 1U << 3 ;

  // Field GPIO25_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS3_GPIO25_LEVEL_LOW = 1U << 4 ;

  // Field GPIO25_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS3_GPIO25_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO25_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS3_GPIO25_EDGE_LOW = 1U << 6 ;

  // Field GPIO25_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS3_GPIO25_EDGE_HIGH = 1U << 7 ;

  // Field GPIO26_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS3_GPIO26_LEVEL_LOW = 1U << 8 ;

  // Field GPIO26_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS3_GPIO26_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO26_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS3_GPIO26_EDGE_LOW = 1U << 10 ;

  // Field GPIO26_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS3_GPIO26_EDGE_HIGH = 1U << 11 ;

  // Field GPIO27_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS3_GPIO27_LEVEL_LOW = 1U << 12 ;

  // Field GPIO27_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS3_GPIO27_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO27_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS3_GPIO27_EDGE_LOW = 1U << 14 ;

  // Field GPIO27_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS3_GPIO27_EDGE_HIGH = 1U << 15 ;

  // Field GPIO28_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS3_GPIO28_LEVEL_LOW = 1U << 16 ;

  // Field GPIO28_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS3_GPIO28_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO28_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS3_GPIO28_EDGE_LOW = 1U << 18 ;

  // Field GPIO28_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS3_GPIO28_EDGE_HIGH = 1U << 19 ;

  // Field GPIO29_LEVEL_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS3_GPIO29_LEVEL_LOW = 1U << 20 ;

  // Field GPIO29_LEVEL_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS3_GPIO29_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO29_EDGE_LOW: 
    const uint32_t IO_BANK0_PROC1_INTS3_GPIO29_EDGE_LOW = 1U << 22 ;

  // Field GPIO29_EDGE_HIGH: 
    const uint32_t IO_BANK0_PROC1_INTS3_GPIO29_EDGE_HIGH = 1U << 23 ;

//------------------------------------------------------------------------------

//---  Register DORMANT_WAKE_INTE0: Interrupt Enable for dormant_wake
  static volatile uint32_t & IO_BANK0_DORMANT_WAKE_INTE0 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 352)) ;

  // Field GPIO0_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_LEVEL_LOW = 1U << 0 ;

  // Field GPIO0_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO0_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_EDGE_LOW = 1U << 2 ;

  // Field GPIO0_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_EDGE_HIGH = 1U << 3 ;

  // Field GPIO1_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_LEVEL_LOW = 1U << 4 ;

  // Field GPIO1_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO1_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_EDGE_LOW = 1U << 6 ;

  // Field GPIO1_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_EDGE_HIGH = 1U << 7 ;

  // Field GPIO2_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_LEVEL_LOW = 1U << 8 ;

  // Field GPIO2_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO2_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_EDGE_LOW = 1U << 10 ;

  // Field GPIO2_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_EDGE_HIGH = 1U << 11 ;

  // Field GPIO3_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_LEVEL_LOW = 1U << 12 ;

  // Field GPIO3_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO3_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_EDGE_LOW = 1U << 14 ;

  // Field GPIO3_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_EDGE_HIGH = 1U << 15 ;

  // Field GPIO4_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_LEVEL_LOW = 1U << 16 ;

  // Field GPIO4_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO4_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_EDGE_LOW = 1U << 18 ;

  // Field GPIO4_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_EDGE_HIGH = 1U << 19 ;

  // Field GPIO5_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_LEVEL_LOW = 1U << 20 ;

  // Field GPIO5_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO5_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_EDGE_LOW = 1U << 22 ;

  // Field GPIO5_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_EDGE_HIGH = 1U << 23 ;

  // Field GPIO6_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_LEVEL_LOW = 1U << 24 ;

  // Field GPIO6_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_LEVEL_HIGH = 1U << 25 ;

  // Field GPIO6_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_EDGE_LOW = 1U << 26 ;

  // Field GPIO6_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_EDGE_HIGH = 1U << 27 ;

  // Field GPIO7_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_LEVEL_LOW = 1U << 28 ;

  // Field GPIO7_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_LEVEL_HIGH = 1U << 29 ;

  // Field GPIO7_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_EDGE_LOW = 1U << 30 ;

  // Field GPIO7_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_EDGE_HIGH = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register DORMANT_WAKE_INTE1: Interrupt Enable for dormant_wake
  static volatile uint32_t & IO_BANK0_DORMANT_WAKE_INTE1 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 356)) ;

  // Field GPIO8_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_LEVEL_LOW = 1U << 0 ;

  // Field GPIO8_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO8_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_EDGE_LOW = 1U << 2 ;

  // Field GPIO8_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_EDGE_HIGH = 1U << 3 ;

  // Field GPIO9_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_LEVEL_LOW = 1U << 4 ;

  // Field GPIO9_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO9_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_EDGE_LOW = 1U << 6 ;

  // Field GPIO9_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_EDGE_HIGH = 1U << 7 ;

  // Field GPIO10_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_LEVEL_LOW = 1U << 8 ;

  // Field GPIO10_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO10_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_EDGE_LOW = 1U << 10 ;

  // Field GPIO10_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_EDGE_HIGH = 1U << 11 ;

  // Field GPIO11_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_LEVEL_LOW = 1U << 12 ;

  // Field GPIO11_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO11_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_EDGE_LOW = 1U << 14 ;

  // Field GPIO11_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_EDGE_HIGH = 1U << 15 ;

  // Field GPIO12_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_LEVEL_LOW = 1U << 16 ;

  // Field GPIO12_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO12_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_EDGE_LOW = 1U << 18 ;

  // Field GPIO12_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_EDGE_HIGH = 1U << 19 ;

  // Field GPIO13_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_LEVEL_LOW = 1U << 20 ;

  // Field GPIO13_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO13_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_EDGE_LOW = 1U << 22 ;

  // Field GPIO13_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_EDGE_HIGH = 1U << 23 ;

  // Field GPIO14_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_LEVEL_LOW = 1U << 24 ;

  // Field GPIO14_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_LEVEL_HIGH = 1U << 25 ;

  // Field GPIO14_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_EDGE_LOW = 1U << 26 ;

  // Field GPIO14_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_EDGE_HIGH = 1U << 27 ;

  // Field GPIO15_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_LEVEL_LOW = 1U << 28 ;

  // Field GPIO15_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_LEVEL_HIGH = 1U << 29 ;

  // Field GPIO15_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_EDGE_LOW = 1U << 30 ;

  // Field GPIO15_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_EDGE_HIGH = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register DORMANT_WAKE_INTE2: Interrupt Enable for dormant_wake
  static volatile uint32_t & IO_BANK0_DORMANT_WAKE_INTE2 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 360)) ;

  // Field GPIO16_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_LEVEL_LOW = 1U << 0 ;

  // Field GPIO16_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO16_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_EDGE_LOW = 1U << 2 ;

  // Field GPIO16_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_EDGE_HIGH = 1U << 3 ;

  // Field GPIO17_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_LEVEL_LOW = 1U << 4 ;

  // Field GPIO17_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO17_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_EDGE_LOW = 1U << 6 ;

  // Field GPIO17_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_EDGE_HIGH = 1U << 7 ;

  // Field GPIO18_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_LEVEL_LOW = 1U << 8 ;

  // Field GPIO18_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO18_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_EDGE_LOW = 1U << 10 ;

  // Field GPIO18_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_EDGE_HIGH = 1U << 11 ;

  // Field GPIO19_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_LEVEL_LOW = 1U << 12 ;

  // Field GPIO19_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO19_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_EDGE_LOW = 1U << 14 ;

  // Field GPIO19_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_EDGE_HIGH = 1U << 15 ;

  // Field GPIO20_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_LEVEL_LOW = 1U << 16 ;

  // Field GPIO20_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO20_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_EDGE_LOW = 1U << 18 ;

  // Field GPIO20_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_EDGE_HIGH = 1U << 19 ;

  // Field GPIO21_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_LEVEL_LOW = 1U << 20 ;

  // Field GPIO21_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO21_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_EDGE_LOW = 1U << 22 ;

  // Field GPIO21_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_EDGE_HIGH = 1U << 23 ;

  // Field GPIO22_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_LEVEL_LOW = 1U << 24 ;

  // Field GPIO22_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_LEVEL_HIGH = 1U << 25 ;

  // Field GPIO22_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_EDGE_LOW = 1U << 26 ;

  // Field GPIO22_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_EDGE_HIGH = 1U << 27 ;

  // Field GPIO23_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_LEVEL_LOW = 1U << 28 ;

  // Field GPIO23_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_LEVEL_HIGH = 1U << 29 ;

  // Field GPIO23_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_EDGE_LOW = 1U << 30 ;

  // Field GPIO23_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_EDGE_HIGH = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register DORMANT_WAKE_INTE3: Interrupt Enable for dormant_wake
  static volatile uint32_t & IO_BANK0_DORMANT_WAKE_INTE3 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 364)) ;

  // Field GPIO24_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_LEVEL_LOW = 1U << 0 ;

  // Field GPIO24_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO24_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_EDGE_LOW = 1U << 2 ;

  // Field GPIO24_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_EDGE_HIGH = 1U << 3 ;

  // Field GPIO25_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_LEVEL_LOW = 1U << 4 ;

  // Field GPIO25_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO25_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_EDGE_LOW = 1U << 6 ;

  // Field GPIO25_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_EDGE_HIGH = 1U << 7 ;

  // Field GPIO26_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_LEVEL_LOW = 1U << 8 ;

  // Field GPIO26_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO26_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_EDGE_LOW = 1U << 10 ;

  // Field GPIO26_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_EDGE_HIGH = 1U << 11 ;

  // Field GPIO27_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_LEVEL_LOW = 1U << 12 ;

  // Field GPIO27_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO27_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_EDGE_LOW = 1U << 14 ;

  // Field GPIO27_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_EDGE_HIGH = 1U << 15 ;

  // Field GPIO28_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_LEVEL_LOW = 1U << 16 ;

  // Field GPIO28_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO28_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_EDGE_LOW = 1U << 18 ;

  // Field GPIO28_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_EDGE_HIGH = 1U << 19 ;

  // Field GPIO29_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_LEVEL_LOW = 1U << 20 ;

  // Field GPIO29_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO29_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_EDGE_LOW = 1U << 22 ;

  // Field GPIO29_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_EDGE_HIGH = 1U << 23 ;

//------------------------------------------------------------------------------

//---  Register DORMANT_WAKE_INTF0: Interrupt Force for dormant_wake
  static volatile uint32_t & IO_BANK0_DORMANT_WAKE_INTF0 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 368)) ;

  // Field GPIO0_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_LEVEL_LOW = 1U << 0 ;

  // Field GPIO0_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO0_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_EDGE_LOW = 1U << 2 ;

  // Field GPIO0_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_EDGE_HIGH = 1U << 3 ;

  // Field GPIO1_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_LEVEL_LOW = 1U << 4 ;

  // Field GPIO1_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO1_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_EDGE_LOW = 1U << 6 ;

  // Field GPIO1_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_EDGE_HIGH = 1U << 7 ;

  // Field GPIO2_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_LEVEL_LOW = 1U << 8 ;

  // Field GPIO2_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO2_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_EDGE_LOW = 1U << 10 ;

  // Field GPIO2_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_EDGE_HIGH = 1U << 11 ;

  // Field GPIO3_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_LEVEL_LOW = 1U << 12 ;

  // Field GPIO3_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO3_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_EDGE_LOW = 1U << 14 ;

  // Field GPIO3_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_EDGE_HIGH = 1U << 15 ;

  // Field GPIO4_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_LEVEL_LOW = 1U << 16 ;

  // Field GPIO4_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO4_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_EDGE_LOW = 1U << 18 ;

  // Field GPIO4_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_EDGE_HIGH = 1U << 19 ;

  // Field GPIO5_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_LEVEL_LOW = 1U << 20 ;

  // Field GPIO5_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO5_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_EDGE_LOW = 1U << 22 ;

  // Field GPIO5_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_EDGE_HIGH = 1U << 23 ;

  // Field GPIO6_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_LEVEL_LOW = 1U << 24 ;

  // Field GPIO6_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_LEVEL_HIGH = 1U << 25 ;

  // Field GPIO6_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_EDGE_LOW = 1U << 26 ;

  // Field GPIO6_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_EDGE_HIGH = 1U << 27 ;

  // Field GPIO7_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_LEVEL_LOW = 1U << 28 ;

  // Field GPIO7_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_LEVEL_HIGH = 1U << 29 ;

  // Field GPIO7_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_EDGE_LOW = 1U << 30 ;

  // Field GPIO7_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_EDGE_HIGH = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register DORMANT_WAKE_INTF1: Interrupt Force for dormant_wake
  static volatile uint32_t & IO_BANK0_DORMANT_WAKE_INTF1 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 372)) ;

  // Field GPIO8_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_LEVEL_LOW = 1U << 0 ;

  // Field GPIO8_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO8_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_EDGE_LOW = 1U << 2 ;

  // Field GPIO8_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_EDGE_HIGH = 1U << 3 ;

  // Field GPIO9_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_LEVEL_LOW = 1U << 4 ;

  // Field GPIO9_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO9_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_EDGE_LOW = 1U << 6 ;

  // Field GPIO9_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_EDGE_HIGH = 1U << 7 ;

  // Field GPIO10_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_LEVEL_LOW = 1U << 8 ;

  // Field GPIO10_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO10_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_EDGE_LOW = 1U << 10 ;

  // Field GPIO10_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_EDGE_HIGH = 1U << 11 ;

  // Field GPIO11_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_LEVEL_LOW = 1U << 12 ;

  // Field GPIO11_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO11_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_EDGE_LOW = 1U << 14 ;

  // Field GPIO11_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_EDGE_HIGH = 1U << 15 ;

  // Field GPIO12_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_LEVEL_LOW = 1U << 16 ;

  // Field GPIO12_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO12_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_EDGE_LOW = 1U << 18 ;

  // Field GPIO12_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_EDGE_HIGH = 1U << 19 ;

  // Field GPIO13_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_LEVEL_LOW = 1U << 20 ;

  // Field GPIO13_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO13_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_EDGE_LOW = 1U << 22 ;

  // Field GPIO13_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_EDGE_HIGH = 1U << 23 ;

  // Field GPIO14_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_LEVEL_LOW = 1U << 24 ;

  // Field GPIO14_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_LEVEL_HIGH = 1U << 25 ;

  // Field GPIO14_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_EDGE_LOW = 1U << 26 ;

  // Field GPIO14_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_EDGE_HIGH = 1U << 27 ;

  // Field GPIO15_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_LEVEL_LOW = 1U << 28 ;

  // Field GPIO15_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_LEVEL_HIGH = 1U << 29 ;

  // Field GPIO15_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_EDGE_LOW = 1U << 30 ;

  // Field GPIO15_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_EDGE_HIGH = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register DORMANT_WAKE_INTF2: Interrupt Force for dormant_wake
  static volatile uint32_t & IO_BANK0_DORMANT_WAKE_INTF2 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 376)) ;

  // Field GPIO16_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_LEVEL_LOW = 1U << 0 ;

  // Field GPIO16_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO16_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_EDGE_LOW = 1U << 2 ;

  // Field GPIO16_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_EDGE_HIGH = 1U << 3 ;

  // Field GPIO17_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_LEVEL_LOW = 1U << 4 ;

  // Field GPIO17_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO17_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_EDGE_LOW = 1U << 6 ;

  // Field GPIO17_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_EDGE_HIGH = 1U << 7 ;

  // Field GPIO18_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_LEVEL_LOW = 1U << 8 ;

  // Field GPIO18_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO18_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_EDGE_LOW = 1U << 10 ;

  // Field GPIO18_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_EDGE_HIGH = 1U << 11 ;

  // Field GPIO19_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_LEVEL_LOW = 1U << 12 ;

  // Field GPIO19_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO19_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_EDGE_LOW = 1U << 14 ;

  // Field GPIO19_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_EDGE_HIGH = 1U << 15 ;

  // Field GPIO20_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_LEVEL_LOW = 1U << 16 ;

  // Field GPIO20_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO20_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_EDGE_LOW = 1U << 18 ;

  // Field GPIO20_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_EDGE_HIGH = 1U << 19 ;

  // Field GPIO21_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_LEVEL_LOW = 1U << 20 ;

  // Field GPIO21_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO21_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_EDGE_LOW = 1U << 22 ;

  // Field GPIO21_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_EDGE_HIGH = 1U << 23 ;

  // Field GPIO22_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_LEVEL_LOW = 1U << 24 ;

  // Field GPIO22_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_LEVEL_HIGH = 1U << 25 ;

  // Field GPIO22_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_EDGE_LOW = 1U << 26 ;

  // Field GPIO22_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_EDGE_HIGH = 1U << 27 ;

  // Field GPIO23_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_LEVEL_LOW = 1U << 28 ;

  // Field GPIO23_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_LEVEL_HIGH = 1U << 29 ;

  // Field GPIO23_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_EDGE_LOW = 1U << 30 ;

  // Field GPIO23_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_EDGE_HIGH = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register DORMANT_WAKE_INTF3: Interrupt Force for dormant_wake
  static volatile uint32_t & IO_BANK0_DORMANT_WAKE_INTF3 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 380)) ;

  // Field GPIO24_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_LEVEL_LOW = 1U << 0 ;

  // Field GPIO24_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO24_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_EDGE_LOW = 1U << 2 ;

  // Field GPIO24_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_EDGE_HIGH = 1U << 3 ;

  // Field GPIO25_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_LEVEL_LOW = 1U << 4 ;

  // Field GPIO25_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO25_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_EDGE_LOW = 1U << 6 ;

  // Field GPIO25_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_EDGE_HIGH = 1U << 7 ;

  // Field GPIO26_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_LEVEL_LOW = 1U << 8 ;

  // Field GPIO26_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO26_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_EDGE_LOW = 1U << 10 ;

  // Field GPIO26_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_EDGE_HIGH = 1U << 11 ;

  // Field GPIO27_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_LEVEL_LOW = 1U << 12 ;

  // Field GPIO27_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO27_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_EDGE_LOW = 1U << 14 ;

  // Field GPIO27_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_EDGE_HIGH = 1U << 15 ;

  // Field GPIO28_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_LEVEL_LOW = 1U << 16 ;

  // Field GPIO28_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO28_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_EDGE_LOW = 1U << 18 ;

  // Field GPIO28_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_EDGE_HIGH = 1U << 19 ;

  // Field GPIO29_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_LEVEL_LOW = 1U << 20 ;

  // Field GPIO29_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO29_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_EDGE_LOW = 1U << 22 ;

  // Field GPIO29_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_EDGE_HIGH = 1U << 23 ;

//------------------------------------------------------------------------------

//---  Register DORMANT_WAKE_INTS0: Interrupt status after masking & forcing for dormant_wake
  static volatile uint32_t & IO_BANK0_DORMANT_WAKE_INTS0 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 384)) ;

  // Field GPIO0_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_LEVEL_LOW = 1U << 0 ;

  // Field GPIO0_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO0_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_EDGE_LOW = 1U << 2 ;

  // Field GPIO0_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_EDGE_HIGH = 1U << 3 ;

  // Field GPIO1_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_LEVEL_LOW = 1U << 4 ;

  // Field GPIO1_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO1_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_EDGE_LOW = 1U << 6 ;

  // Field GPIO1_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_EDGE_HIGH = 1U << 7 ;

  // Field GPIO2_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_LEVEL_LOW = 1U << 8 ;

  // Field GPIO2_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO2_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_EDGE_LOW = 1U << 10 ;

  // Field GPIO2_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_EDGE_HIGH = 1U << 11 ;

  // Field GPIO3_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_LEVEL_LOW = 1U << 12 ;

  // Field GPIO3_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO3_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_EDGE_LOW = 1U << 14 ;

  // Field GPIO3_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_EDGE_HIGH = 1U << 15 ;

  // Field GPIO4_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_LEVEL_LOW = 1U << 16 ;

  // Field GPIO4_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO4_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_EDGE_LOW = 1U << 18 ;

  // Field GPIO4_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_EDGE_HIGH = 1U << 19 ;

  // Field GPIO5_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_LEVEL_LOW = 1U << 20 ;

  // Field GPIO5_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO5_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_EDGE_LOW = 1U << 22 ;

  // Field GPIO5_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_EDGE_HIGH = 1U << 23 ;

  // Field GPIO6_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_LEVEL_LOW = 1U << 24 ;

  // Field GPIO6_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_LEVEL_HIGH = 1U << 25 ;

  // Field GPIO6_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_EDGE_LOW = 1U << 26 ;

  // Field GPIO6_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_EDGE_HIGH = 1U << 27 ;

  // Field GPIO7_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_LEVEL_LOW = 1U << 28 ;

  // Field GPIO7_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_LEVEL_HIGH = 1U << 29 ;

  // Field GPIO7_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_EDGE_LOW = 1U << 30 ;

  // Field GPIO7_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_EDGE_HIGH = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register DORMANT_WAKE_INTS1: Interrupt status after masking & forcing for dormant_wake
  static volatile uint32_t & IO_BANK0_DORMANT_WAKE_INTS1 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 388)) ;

  // Field GPIO8_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_LEVEL_LOW = 1U << 0 ;

  // Field GPIO8_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO8_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_EDGE_LOW = 1U << 2 ;

  // Field GPIO8_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_EDGE_HIGH = 1U << 3 ;

  // Field GPIO9_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_LEVEL_LOW = 1U << 4 ;

  // Field GPIO9_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO9_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_EDGE_LOW = 1U << 6 ;

  // Field GPIO9_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_EDGE_HIGH = 1U << 7 ;

  // Field GPIO10_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_LEVEL_LOW = 1U << 8 ;

  // Field GPIO10_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO10_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_EDGE_LOW = 1U << 10 ;

  // Field GPIO10_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_EDGE_HIGH = 1U << 11 ;

  // Field GPIO11_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_LEVEL_LOW = 1U << 12 ;

  // Field GPIO11_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO11_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_EDGE_LOW = 1U << 14 ;

  // Field GPIO11_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_EDGE_HIGH = 1U << 15 ;

  // Field GPIO12_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_LEVEL_LOW = 1U << 16 ;

  // Field GPIO12_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO12_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_EDGE_LOW = 1U << 18 ;

  // Field GPIO12_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_EDGE_HIGH = 1U << 19 ;

  // Field GPIO13_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_LEVEL_LOW = 1U << 20 ;

  // Field GPIO13_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO13_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_EDGE_LOW = 1U << 22 ;

  // Field GPIO13_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_EDGE_HIGH = 1U << 23 ;

  // Field GPIO14_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_LEVEL_LOW = 1U << 24 ;

  // Field GPIO14_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_LEVEL_HIGH = 1U << 25 ;

  // Field GPIO14_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_EDGE_LOW = 1U << 26 ;

  // Field GPIO14_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_EDGE_HIGH = 1U << 27 ;

  // Field GPIO15_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_LEVEL_LOW = 1U << 28 ;

  // Field GPIO15_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_LEVEL_HIGH = 1U << 29 ;

  // Field GPIO15_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_EDGE_LOW = 1U << 30 ;

  // Field GPIO15_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_EDGE_HIGH = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register DORMANT_WAKE_INTS2: Interrupt status after masking & forcing for dormant_wake
  static volatile uint32_t & IO_BANK0_DORMANT_WAKE_INTS2 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 392)) ;

  // Field GPIO16_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_LEVEL_LOW = 1U << 0 ;

  // Field GPIO16_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO16_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_EDGE_LOW = 1U << 2 ;

  // Field GPIO16_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_EDGE_HIGH = 1U << 3 ;

  // Field GPIO17_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_LEVEL_LOW = 1U << 4 ;

  // Field GPIO17_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO17_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_EDGE_LOW = 1U << 6 ;

  // Field GPIO17_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_EDGE_HIGH = 1U << 7 ;

  // Field GPIO18_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_LEVEL_LOW = 1U << 8 ;

  // Field GPIO18_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO18_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_EDGE_LOW = 1U << 10 ;

  // Field GPIO18_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_EDGE_HIGH = 1U << 11 ;

  // Field GPIO19_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_LEVEL_LOW = 1U << 12 ;

  // Field GPIO19_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO19_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_EDGE_LOW = 1U << 14 ;

  // Field GPIO19_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_EDGE_HIGH = 1U << 15 ;

  // Field GPIO20_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_LEVEL_LOW = 1U << 16 ;

  // Field GPIO20_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO20_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_EDGE_LOW = 1U << 18 ;

  // Field GPIO20_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_EDGE_HIGH = 1U << 19 ;

  // Field GPIO21_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_LEVEL_LOW = 1U << 20 ;

  // Field GPIO21_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO21_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_EDGE_LOW = 1U << 22 ;

  // Field GPIO21_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_EDGE_HIGH = 1U << 23 ;

  // Field GPIO22_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_LEVEL_LOW = 1U << 24 ;

  // Field GPIO22_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_LEVEL_HIGH = 1U << 25 ;

  // Field GPIO22_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_EDGE_LOW = 1U << 26 ;

  // Field GPIO22_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_EDGE_HIGH = 1U << 27 ;

  // Field GPIO23_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_LEVEL_LOW = 1U << 28 ;

  // Field GPIO23_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_LEVEL_HIGH = 1U << 29 ;

  // Field GPIO23_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_EDGE_LOW = 1U << 30 ;

  // Field GPIO23_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_EDGE_HIGH = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register DORMANT_WAKE_INTS3: Interrupt status after masking & forcing for dormant_wake
  static volatile uint32_t & IO_BANK0_DORMANT_WAKE_INTS3 __attribute__((unused)) = * ((volatile uint32_t *) (0x40014000 + 396)) ;

  // Field GPIO24_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_LEVEL_LOW = 1U << 0 ;

  // Field GPIO24_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO24_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_EDGE_LOW = 1U << 2 ;

  // Field GPIO24_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_EDGE_HIGH = 1U << 3 ;

  // Field GPIO25_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_LEVEL_LOW = 1U << 4 ;

  // Field GPIO25_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO25_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_EDGE_LOW = 1U << 6 ;

  // Field GPIO25_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_EDGE_HIGH = 1U << 7 ;

  // Field GPIO26_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_LEVEL_LOW = 1U << 8 ;

  // Field GPIO26_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO26_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_EDGE_LOW = 1U << 10 ;

  // Field GPIO26_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_EDGE_HIGH = 1U << 11 ;

  // Field GPIO27_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_LEVEL_LOW = 1U << 12 ;

  // Field GPIO27_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO27_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_EDGE_LOW = 1U << 14 ;

  // Field GPIO27_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_EDGE_HIGH = 1U << 15 ;

  // Field GPIO28_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_LEVEL_LOW = 1U << 16 ;

  // Field GPIO28_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO28_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_EDGE_LOW = 1U << 18 ;

  // Field GPIO28_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_EDGE_HIGH = 1U << 19 ;

  // Field GPIO29_LEVEL_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_LEVEL_LOW = 1U << 20 ;

  // Field GPIO29_LEVEL_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO29_EDGE_LOW: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_EDGE_LOW = 1U << 22 ;

  // Field GPIO29_EDGE_HIGH: 
    const uint32_t IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_EDGE_HIGH = 1U << 23 ;

//------------------------------------------------------------------------------
// Peripheral IO_QSPI: 
//------------------------------------------------------------------------------

//---  Register GPIO_QSPI_SCLK_STATUS: GPIO status
  static volatile uint32_t & IO_QSPI_GPIO_QSPI_SCLK_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40018000 + 0)) ;

  // Field OUTFROMPERI: output signal from selected peripheral, before register override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SCLK_STATUS_OUTFROMPERI = 1U << 8 ;

  // Field OUTTOPAD: output signal to pad after register override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SCLK_STATUS_OUTTOPAD = 1U << 9 ;

  // Field OEFROMPERI: output enable from selected peripheral, before register override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SCLK_STATUS_OEFROMPERI = 1U << 12 ;

  // Field OETOPAD: output enable to pad after register override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SCLK_STATUS_OETOPAD = 1U << 13 ;

  // Field INFROMPAD: input signal from pad, before override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SCLK_STATUS_INFROMPAD = 1U << 17 ;

  // Field INTOPERI: input signal to peripheral, after override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SCLK_STATUS_INTOPERI = 1U << 19 ;

  // Field IRQFROMPAD: interrupt from pad before override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SCLK_STATUS_IRQFROMPAD = 1U << 24 ;

  // Field IRQTOPROC: interrupt to processors, after override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SCLK_STATUS_IRQTOPROC = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register GPIO_QSPI_SCLK_CTRL: GPIO control including function select and overrides.
  static volatile uint32_t & IO_QSPI_GPIO_QSPI_SCLK_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40018000 + 4)) ;

  // Field FUNCSEL: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
    inline uint32_t IO_QSPI_GPIO_QSPI_SCLK_CTRL_FUNCSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OUTOVER: 
    inline uint32_t IO_QSPI_GPIO_QSPI_SCLK_CTRL_OUTOVER (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OEOVER: 
    inline uint32_t IO_QSPI_GPIO_QSPI_SCLK_CTRL_OEOVER (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INOVER: 
    inline uint32_t IO_QSPI_GPIO_QSPI_SCLK_CTRL_INOVER (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field IRQOVER: 
    inline uint32_t IO_QSPI_GPIO_QSPI_SCLK_CTRL_IRQOVER (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register GPIO_QSPI_SS_STATUS: GPIO status
  static volatile uint32_t & IO_QSPI_GPIO_QSPI_SS_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40018000 + 8)) ;

  // Field OUTFROMPERI: output signal from selected peripheral, before register override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SS_STATUS_OUTFROMPERI = 1U << 8 ;

  // Field OUTTOPAD: output signal to pad after register override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SS_STATUS_OUTTOPAD = 1U << 9 ;

  // Field OEFROMPERI: output enable from selected peripheral, before register override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SS_STATUS_OEFROMPERI = 1U << 12 ;

  // Field OETOPAD: output enable to pad after register override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SS_STATUS_OETOPAD = 1U << 13 ;

  // Field INFROMPAD: input signal from pad, before override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SS_STATUS_INFROMPAD = 1U << 17 ;

  // Field INTOPERI: input signal to peripheral, after override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SS_STATUS_INTOPERI = 1U << 19 ;

  // Field IRQFROMPAD: interrupt from pad before override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SS_STATUS_IRQFROMPAD = 1U << 24 ;

  // Field IRQTOPROC: interrupt to processors, after override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SS_STATUS_IRQTOPROC = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register GPIO_QSPI_SS_CTRL: GPIO control including function select and overrides.
  static volatile uint32_t & IO_QSPI_GPIO_QSPI_SS_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40018000 + 12)) ;

  // Field FUNCSEL: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
    inline uint32_t IO_QSPI_GPIO_QSPI_SS_CTRL_FUNCSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OUTOVER: 
    inline uint32_t IO_QSPI_GPIO_QSPI_SS_CTRL_OUTOVER (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OEOVER: 
    inline uint32_t IO_QSPI_GPIO_QSPI_SS_CTRL_OEOVER (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INOVER: 
    inline uint32_t IO_QSPI_GPIO_QSPI_SS_CTRL_INOVER (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field IRQOVER: 
    inline uint32_t IO_QSPI_GPIO_QSPI_SS_CTRL_IRQOVER (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register GPIO_QSPI_SD0_STATUS: GPIO status
  static volatile uint32_t & IO_QSPI_GPIO_QSPI_SD0_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40018000 + 16)) ;

  // Field OUTFROMPERI: output signal from selected peripheral, before register override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SD0_STATUS_OUTFROMPERI = 1U << 8 ;

  // Field OUTTOPAD: output signal to pad after register override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SD0_STATUS_OUTTOPAD = 1U << 9 ;

  // Field OEFROMPERI: output enable from selected peripheral, before register override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SD0_STATUS_OEFROMPERI = 1U << 12 ;

  // Field OETOPAD: output enable to pad after register override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SD0_STATUS_OETOPAD = 1U << 13 ;

  // Field INFROMPAD: input signal from pad, before override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SD0_STATUS_INFROMPAD = 1U << 17 ;

  // Field INTOPERI: input signal to peripheral, after override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SD0_STATUS_INTOPERI = 1U << 19 ;

  // Field IRQFROMPAD: interrupt from pad before override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SD0_STATUS_IRQFROMPAD = 1U << 24 ;

  // Field IRQTOPROC: interrupt to processors, after override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SD0_STATUS_IRQTOPROC = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register GPIO_QSPI_SD0_CTRL: GPIO control including function select and overrides.
  static volatile uint32_t & IO_QSPI_GPIO_QSPI_SD0_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40018000 + 20)) ;

  // Field FUNCSEL: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
    inline uint32_t IO_QSPI_GPIO_QSPI_SD0_CTRL_FUNCSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OUTOVER: 
    inline uint32_t IO_QSPI_GPIO_QSPI_SD0_CTRL_OUTOVER (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OEOVER: 
    inline uint32_t IO_QSPI_GPIO_QSPI_SD0_CTRL_OEOVER (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INOVER: 
    inline uint32_t IO_QSPI_GPIO_QSPI_SD0_CTRL_INOVER (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field IRQOVER: 
    inline uint32_t IO_QSPI_GPIO_QSPI_SD0_CTRL_IRQOVER (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register GPIO_QSPI_SD1_STATUS: GPIO status
  static volatile uint32_t & IO_QSPI_GPIO_QSPI_SD1_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40018000 + 24)) ;

  // Field OUTFROMPERI: output signal from selected peripheral, before register override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SD1_STATUS_OUTFROMPERI = 1U << 8 ;

  // Field OUTTOPAD: output signal to pad after register override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SD1_STATUS_OUTTOPAD = 1U << 9 ;

  // Field OEFROMPERI: output enable from selected peripheral, before register override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SD1_STATUS_OEFROMPERI = 1U << 12 ;

  // Field OETOPAD: output enable to pad after register override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SD1_STATUS_OETOPAD = 1U << 13 ;

  // Field INFROMPAD: input signal from pad, before override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SD1_STATUS_INFROMPAD = 1U << 17 ;

  // Field INTOPERI: input signal to peripheral, after override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SD1_STATUS_INTOPERI = 1U << 19 ;

  // Field IRQFROMPAD: interrupt from pad before override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SD1_STATUS_IRQFROMPAD = 1U << 24 ;

  // Field IRQTOPROC: interrupt to processors, after override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SD1_STATUS_IRQTOPROC = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register GPIO_QSPI_SD1_CTRL: GPIO control including function select and overrides.
  static volatile uint32_t & IO_QSPI_GPIO_QSPI_SD1_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40018000 + 28)) ;

  // Field FUNCSEL: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
    inline uint32_t IO_QSPI_GPIO_QSPI_SD1_CTRL_FUNCSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OUTOVER: 
    inline uint32_t IO_QSPI_GPIO_QSPI_SD1_CTRL_OUTOVER (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OEOVER: 
    inline uint32_t IO_QSPI_GPIO_QSPI_SD1_CTRL_OEOVER (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INOVER: 
    inline uint32_t IO_QSPI_GPIO_QSPI_SD1_CTRL_INOVER (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field IRQOVER: 
    inline uint32_t IO_QSPI_GPIO_QSPI_SD1_CTRL_IRQOVER (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register GPIO_QSPI_SD2_STATUS: GPIO status
  static volatile uint32_t & IO_QSPI_GPIO_QSPI_SD2_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40018000 + 32)) ;

  // Field OUTFROMPERI: output signal from selected peripheral, before register override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SD2_STATUS_OUTFROMPERI = 1U << 8 ;

  // Field OUTTOPAD: output signal to pad after register override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SD2_STATUS_OUTTOPAD = 1U << 9 ;

  // Field OEFROMPERI: output enable from selected peripheral, before register override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SD2_STATUS_OEFROMPERI = 1U << 12 ;

  // Field OETOPAD: output enable to pad after register override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SD2_STATUS_OETOPAD = 1U << 13 ;

  // Field INFROMPAD: input signal from pad, before override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SD2_STATUS_INFROMPAD = 1U << 17 ;

  // Field INTOPERI: input signal to peripheral, after override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SD2_STATUS_INTOPERI = 1U << 19 ;

  // Field IRQFROMPAD: interrupt from pad before override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SD2_STATUS_IRQFROMPAD = 1U << 24 ;

  // Field IRQTOPROC: interrupt to processors, after override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SD2_STATUS_IRQTOPROC = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register GPIO_QSPI_SD2_CTRL: GPIO control including function select and overrides.
  static volatile uint32_t & IO_QSPI_GPIO_QSPI_SD2_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40018000 + 36)) ;

  // Field FUNCSEL: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
    inline uint32_t IO_QSPI_GPIO_QSPI_SD2_CTRL_FUNCSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OUTOVER: 
    inline uint32_t IO_QSPI_GPIO_QSPI_SD2_CTRL_OUTOVER (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OEOVER: 
    inline uint32_t IO_QSPI_GPIO_QSPI_SD2_CTRL_OEOVER (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INOVER: 
    inline uint32_t IO_QSPI_GPIO_QSPI_SD2_CTRL_INOVER (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field IRQOVER: 
    inline uint32_t IO_QSPI_GPIO_QSPI_SD2_CTRL_IRQOVER (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register GPIO_QSPI_SD3_STATUS: GPIO status
  static volatile uint32_t & IO_QSPI_GPIO_QSPI_SD3_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40018000 + 40)) ;

  // Field OUTFROMPERI: output signal from selected peripheral, before register override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SD3_STATUS_OUTFROMPERI = 1U << 8 ;

  // Field OUTTOPAD: output signal to pad after register override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SD3_STATUS_OUTTOPAD = 1U << 9 ;

  // Field OEFROMPERI: output enable from selected peripheral, before register override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SD3_STATUS_OEFROMPERI = 1U << 12 ;

  // Field OETOPAD: output enable to pad after register override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SD3_STATUS_OETOPAD = 1U << 13 ;

  // Field INFROMPAD: input signal from pad, before override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SD3_STATUS_INFROMPAD = 1U << 17 ;

  // Field INTOPERI: input signal to peripheral, after override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SD3_STATUS_INTOPERI = 1U << 19 ;

  // Field IRQFROMPAD: interrupt from pad before override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SD3_STATUS_IRQFROMPAD = 1U << 24 ;

  // Field IRQTOPROC: interrupt to processors, after override is applied
    const uint32_t IO_QSPI_GPIO_QSPI_SD3_STATUS_IRQTOPROC = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register GPIO_QSPI_SD3_CTRL: GPIO control including function select and overrides.
  static volatile uint32_t & IO_QSPI_GPIO_QSPI_SD3_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40018000 + 44)) ;

  // Field FUNCSEL: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
    inline uint32_t IO_QSPI_GPIO_QSPI_SD3_CTRL_FUNCSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OUTOVER: 
    inline uint32_t IO_QSPI_GPIO_QSPI_SD3_CTRL_OUTOVER (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OEOVER: 
    inline uint32_t IO_QSPI_GPIO_QSPI_SD3_CTRL_OEOVER (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INOVER: 
    inline uint32_t IO_QSPI_GPIO_QSPI_SD3_CTRL_INOVER (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field IRQOVER: 
    inline uint32_t IO_QSPI_GPIO_QSPI_SD3_CTRL_IRQOVER (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register INTR: Raw Interrupts
  static volatile uint32_t & IO_QSPI_INTR __attribute__((unused)) = * ((volatile uint32_t *) (0x40018000 + 48)) ;

  // Field GPIO_QSPI_SCLK_LEVEL_LOW: 
    const uint32_t IO_QSPI_INTR_GPIO_QSPI_SCLK_LEVEL_LOW = 1U << 0 ;

  // Field GPIO_QSPI_SCLK_LEVEL_HIGH: 
    const uint32_t IO_QSPI_INTR_GPIO_QSPI_SCLK_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO_QSPI_SCLK_EDGE_LOW: 
    const uint32_t IO_QSPI_INTR_GPIO_QSPI_SCLK_EDGE_LOW = 1U << 2 ;

  // Field GPIO_QSPI_SCLK_EDGE_HIGH: 
    const uint32_t IO_QSPI_INTR_GPIO_QSPI_SCLK_EDGE_HIGH = 1U << 3 ;

  // Field GPIO_QSPI_SS_LEVEL_LOW: 
    const uint32_t IO_QSPI_INTR_GPIO_QSPI_SS_LEVEL_LOW = 1U << 4 ;

  // Field GPIO_QSPI_SS_LEVEL_HIGH: 
    const uint32_t IO_QSPI_INTR_GPIO_QSPI_SS_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO_QSPI_SS_EDGE_LOW: 
    const uint32_t IO_QSPI_INTR_GPIO_QSPI_SS_EDGE_LOW = 1U << 6 ;

  // Field GPIO_QSPI_SS_EDGE_HIGH: 
    const uint32_t IO_QSPI_INTR_GPIO_QSPI_SS_EDGE_HIGH = 1U << 7 ;

  // Field GPIO_QSPI_SD0_LEVEL_LOW: 
    const uint32_t IO_QSPI_INTR_GPIO_QSPI_SD0_LEVEL_LOW = 1U << 8 ;

  // Field GPIO_QSPI_SD0_LEVEL_HIGH: 
    const uint32_t IO_QSPI_INTR_GPIO_QSPI_SD0_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO_QSPI_SD0_EDGE_LOW: 
    const uint32_t IO_QSPI_INTR_GPIO_QSPI_SD0_EDGE_LOW = 1U << 10 ;

  // Field GPIO_QSPI_SD0_EDGE_HIGH: 
    const uint32_t IO_QSPI_INTR_GPIO_QSPI_SD0_EDGE_HIGH = 1U << 11 ;

  // Field GPIO_QSPI_SD1_LEVEL_LOW: 
    const uint32_t IO_QSPI_INTR_GPIO_QSPI_SD1_LEVEL_LOW = 1U << 12 ;

  // Field GPIO_QSPI_SD1_LEVEL_HIGH: 
    const uint32_t IO_QSPI_INTR_GPIO_QSPI_SD1_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO_QSPI_SD1_EDGE_LOW: 
    const uint32_t IO_QSPI_INTR_GPIO_QSPI_SD1_EDGE_LOW = 1U << 14 ;

  // Field GPIO_QSPI_SD1_EDGE_HIGH: 
    const uint32_t IO_QSPI_INTR_GPIO_QSPI_SD1_EDGE_HIGH = 1U << 15 ;

  // Field GPIO_QSPI_SD2_LEVEL_LOW: 
    const uint32_t IO_QSPI_INTR_GPIO_QSPI_SD2_LEVEL_LOW = 1U << 16 ;

  // Field GPIO_QSPI_SD2_LEVEL_HIGH: 
    const uint32_t IO_QSPI_INTR_GPIO_QSPI_SD2_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO_QSPI_SD2_EDGE_LOW: 
    const uint32_t IO_QSPI_INTR_GPIO_QSPI_SD2_EDGE_LOW = 1U << 18 ;

  // Field GPIO_QSPI_SD2_EDGE_HIGH: 
    const uint32_t IO_QSPI_INTR_GPIO_QSPI_SD2_EDGE_HIGH = 1U << 19 ;

  // Field GPIO_QSPI_SD3_LEVEL_LOW: 
    const uint32_t IO_QSPI_INTR_GPIO_QSPI_SD3_LEVEL_LOW = 1U << 20 ;

  // Field GPIO_QSPI_SD3_LEVEL_HIGH: 
    const uint32_t IO_QSPI_INTR_GPIO_QSPI_SD3_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO_QSPI_SD3_EDGE_LOW: 
    const uint32_t IO_QSPI_INTR_GPIO_QSPI_SD3_EDGE_LOW = 1U << 22 ;

  // Field GPIO_QSPI_SD3_EDGE_HIGH: 
    const uint32_t IO_QSPI_INTR_GPIO_QSPI_SD3_EDGE_HIGH = 1U << 23 ;

//------------------------------------------------------------------------------

//---  Register PROC0_INTE: Interrupt Enable for proc0
  static volatile uint32_t & IO_QSPI_PROC0_INTE __attribute__((unused)) = * ((volatile uint32_t *) (0x40018000 + 52)) ;

  // Field GPIO_QSPI_SCLK_LEVEL_LOW: 
    const uint32_t IO_QSPI_PROC0_INTE_GPIO_QSPI_SCLK_LEVEL_LOW = 1U << 0 ;

  // Field GPIO_QSPI_SCLK_LEVEL_HIGH: 
    const uint32_t IO_QSPI_PROC0_INTE_GPIO_QSPI_SCLK_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO_QSPI_SCLK_EDGE_LOW: 
    const uint32_t IO_QSPI_PROC0_INTE_GPIO_QSPI_SCLK_EDGE_LOW = 1U << 2 ;

  // Field GPIO_QSPI_SCLK_EDGE_HIGH: 
    const uint32_t IO_QSPI_PROC0_INTE_GPIO_QSPI_SCLK_EDGE_HIGH = 1U << 3 ;

  // Field GPIO_QSPI_SS_LEVEL_LOW: 
    const uint32_t IO_QSPI_PROC0_INTE_GPIO_QSPI_SS_LEVEL_LOW = 1U << 4 ;

  // Field GPIO_QSPI_SS_LEVEL_HIGH: 
    const uint32_t IO_QSPI_PROC0_INTE_GPIO_QSPI_SS_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO_QSPI_SS_EDGE_LOW: 
    const uint32_t IO_QSPI_PROC0_INTE_GPIO_QSPI_SS_EDGE_LOW = 1U << 6 ;

  // Field GPIO_QSPI_SS_EDGE_HIGH: 
    const uint32_t IO_QSPI_PROC0_INTE_GPIO_QSPI_SS_EDGE_HIGH = 1U << 7 ;

  // Field GPIO_QSPI_SD0_LEVEL_LOW: 
    const uint32_t IO_QSPI_PROC0_INTE_GPIO_QSPI_SD0_LEVEL_LOW = 1U << 8 ;

  // Field GPIO_QSPI_SD0_LEVEL_HIGH: 
    const uint32_t IO_QSPI_PROC0_INTE_GPIO_QSPI_SD0_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO_QSPI_SD0_EDGE_LOW: 
    const uint32_t IO_QSPI_PROC0_INTE_GPIO_QSPI_SD0_EDGE_LOW = 1U << 10 ;

  // Field GPIO_QSPI_SD0_EDGE_HIGH: 
    const uint32_t IO_QSPI_PROC0_INTE_GPIO_QSPI_SD0_EDGE_HIGH = 1U << 11 ;

  // Field GPIO_QSPI_SD1_LEVEL_LOW: 
    const uint32_t IO_QSPI_PROC0_INTE_GPIO_QSPI_SD1_LEVEL_LOW = 1U << 12 ;

  // Field GPIO_QSPI_SD1_LEVEL_HIGH: 
    const uint32_t IO_QSPI_PROC0_INTE_GPIO_QSPI_SD1_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO_QSPI_SD1_EDGE_LOW: 
    const uint32_t IO_QSPI_PROC0_INTE_GPIO_QSPI_SD1_EDGE_LOW = 1U << 14 ;

  // Field GPIO_QSPI_SD1_EDGE_HIGH: 
    const uint32_t IO_QSPI_PROC0_INTE_GPIO_QSPI_SD1_EDGE_HIGH = 1U << 15 ;

  // Field GPIO_QSPI_SD2_LEVEL_LOW: 
    const uint32_t IO_QSPI_PROC0_INTE_GPIO_QSPI_SD2_LEVEL_LOW = 1U << 16 ;

  // Field GPIO_QSPI_SD2_LEVEL_HIGH: 
    const uint32_t IO_QSPI_PROC0_INTE_GPIO_QSPI_SD2_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO_QSPI_SD2_EDGE_LOW: 
    const uint32_t IO_QSPI_PROC0_INTE_GPIO_QSPI_SD2_EDGE_LOW = 1U << 18 ;

  // Field GPIO_QSPI_SD2_EDGE_HIGH: 
    const uint32_t IO_QSPI_PROC0_INTE_GPIO_QSPI_SD2_EDGE_HIGH = 1U << 19 ;

  // Field GPIO_QSPI_SD3_LEVEL_LOW: 
    const uint32_t IO_QSPI_PROC0_INTE_GPIO_QSPI_SD3_LEVEL_LOW = 1U << 20 ;

  // Field GPIO_QSPI_SD3_LEVEL_HIGH: 
    const uint32_t IO_QSPI_PROC0_INTE_GPIO_QSPI_SD3_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO_QSPI_SD3_EDGE_LOW: 
    const uint32_t IO_QSPI_PROC0_INTE_GPIO_QSPI_SD3_EDGE_LOW = 1U << 22 ;

  // Field GPIO_QSPI_SD3_EDGE_HIGH: 
    const uint32_t IO_QSPI_PROC0_INTE_GPIO_QSPI_SD3_EDGE_HIGH = 1U << 23 ;

//------------------------------------------------------------------------------

//---  Register PROC0_INTF: Interrupt Force for proc0
  static volatile uint32_t & IO_QSPI_PROC0_INTF __attribute__((unused)) = * ((volatile uint32_t *) (0x40018000 + 56)) ;

  // Field GPIO_QSPI_SCLK_LEVEL_LOW: 
    const uint32_t IO_QSPI_PROC0_INTF_GPIO_QSPI_SCLK_LEVEL_LOW = 1U << 0 ;

  // Field GPIO_QSPI_SCLK_LEVEL_HIGH: 
    const uint32_t IO_QSPI_PROC0_INTF_GPIO_QSPI_SCLK_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO_QSPI_SCLK_EDGE_LOW: 
    const uint32_t IO_QSPI_PROC0_INTF_GPIO_QSPI_SCLK_EDGE_LOW = 1U << 2 ;

  // Field GPIO_QSPI_SCLK_EDGE_HIGH: 
    const uint32_t IO_QSPI_PROC0_INTF_GPIO_QSPI_SCLK_EDGE_HIGH = 1U << 3 ;

  // Field GPIO_QSPI_SS_LEVEL_LOW: 
    const uint32_t IO_QSPI_PROC0_INTF_GPIO_QSPI_SS_LEVEL_LOW = 1U << 4 ;

  // Field GPIO_QSPI_SS_LEVEL_HIGH: 
    const uint32_t IO_QSPI_PROC0_INTF_GPIO_QSPI_SS_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO_QSPI_SS_EDGE_LOW: 
    const uint32_t IO_QSPI_PROC0_INTF_GPIO_QSPI_SS_EDGE_LOW = 1U << 6 ;

  // Field GPIO_QSPI_SS_EDGE_HIGH: 
    const uint32_t IO_QSPI_PROC0_INTF_GPIO_QSPI_SS_EDGE_HIGH = 1U << 7 ;

  // Field GPIO_QSPI_SD0_LEVEL_LOW: 
    const uint32_t IO_QSPI_PROC0_INTF_GPIO_QSPI_SD0_LEVEL_LOW = 1U << 8 ;

  // Field GPIO_QSPI_SD0_LEVEL_HIGH: 
    const uint32_t IO_QSPI_PROC0_INTF_GPIO_QSPI_SD0_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO_QSPI_SD0_EDGE_LOW: 
    const uint32_t IO_QSPI_PROC0_INTF_GPIO_QSPI_SD0_EDGE_LOW = 1U << 10 ;

  // Field GPIO_QSPI_SD0_EDGE_HIGH: 
    const uint32_t IO_QSPI_PROC0_INTF_GPIO_QSPI_SD0_EDGE_HIGH = 1U << 11 ;

  // Field GPIO_QSPI_SD1_LEVEL_LOW: 
    const uint32_t IO_QSPI_PROC0_INTF_GPIO_QSPI_SD1_LEVEL_LOW = 1U << 12 ;

  // Field GPIO_QSPI_SD1_LEVEL_HIGH: 
    const uint32_t IO_QSPI_PROC0_INTF_GPIO_QSPI_SD1_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO_QSPI_SD1_EDGE_LOW: 
    const uint32_t IO_QSPI_PROC0_INTF_GPIO_QSPI_SD1_EDGE_LOW = 1U << 14 ;

  // Field GPIO_QSPI_SD1_EDGE_HIGH: 
    const uint32_t IO_QSPI_PROC0_INTF_GPIO_QSPI_SD1_EDGE_HIGH = 1U << 15 ;

  // Field GPIO_QSPI_SD2_LEVEL_LOW: 
    const uint32_t IO_QSPI_PROC0_INTF_GPIO_QSPI_SD2_LEVEL_LOW = 1U << 16 ;

  // Field GPIO_QSPI_SD2_LEVEL_HIGH: 
    const uint32_t IO_QSPI_PROC0_INTF_GPIO_QSPI_SD2_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO_QSPI_SD2_EDGE_LOW: 
    const uint32_t IO_QSPI_PROC0_INTF_GPIO_QSPI_SD2_EDGE_LOW = 1U << 18 ;

  // Field GPIO_QSPI_SD2_EDGE_HIGH: 
    const uint32_t IO_QSPI_PROC0_INTF_GPIO_QSPI_SD2_EDGE_HIGH = 1U << 19 ;

  // Field GPIO_QSPI_SD3_LEVEL_LOW: 
    const uint32_t IO_QSPI_PROC0_INTF_GPIO_QSPI_SD3_LEVEL_LOW = 1U << 20 ;

  // Field GPIO_QSPI_SD3_LEVEL_HIGH: 
    const uint32_t IO_QSPI_PROC0_INTF_GPIO_QSPI_SD3_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO_QSPI_SD3_EDGE_LOW: 
    const uint32_t IO_QSPI_PROC0_INTF_GPIO_QSPI_SD3_EDGE_LOW = 1U << 22 ;

  // Field GPIO_QSPI_SD3_EDGE_HIGH: 
    const uint32_t IO_QSPI_PROC0_INTF_GPIO_QSPI_SD3_EDGE_HIGH = 1U << 23 ;

//------------------------------------------------------------------------------

//---  Register PROC0_INTS: Interrupt status after masking & forcing for proc0
  static volatile uint32_t & IO_QSPI_PROC0_INTS __attribute__((unused)) = * ((volatile uint32_t *) (0x40018000 + 60)) ;

  // Field GPIO_QSPI_SCLK_LEVEL_LOW: 
    const uint32_t IO_QSPI_PROC0_INTS_GPIO_QSPI_SCLK_LEVEL_LOW = 1U << 0 ;

  // Field GPIO_QSPI_SCLK_LEVEL_HIGH: 
    const uint32_t IO_QSPI_PROC0_INTS_GPIO_QSPI_SCLK_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO_QSPI_SCLK_EDGE_LOW: 
    const uint32_t IO_QSPI_PROC0_INTS_GPIO_QSPI_SCLK_EDGE_LOW = 1U << 2 ;

  // Field GPIO_QSPI_SCLK_EDGE_HIGH: 
    const uint32_t IO_QSPI_PROC0_INTS_GPIO_QSPI_SCLK_EDGE_HIGH = 1U << 3 ;

  // Field GPIO_QSPI_SS_LEVEL_LOW: 
    const uint32_t IO_QSPI_PROC0_INTS_GPIO_QSPI_SS_LEVEL_LOW = 1U << 4 ;

  // Field GPIO_QSPI_SS_LEVEL_HIGH: 
    const uint32_t IO_QSPI_PROC0_INTS_GPIO_QSPI_SS_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO_QSPI_SS_EDGE_LOW: 
    const uint32_t IO_QSPI_PROC0_INTS_GPIO_QSPI_SS_EDGE_LOW = 1U << 6 ;

  // Field GPIO_QSPI_SS_EDGE_HIGH: 
    const uint32_t IO_QSPI_PROC0_INTS_GPIO_QSPI_SS_EDGE_HIGH = 1U << 7 ;

  // Field GPIO_QSPI_SD0_LEVEL_LOW: 
    const uint32_t IO_QSPI_PROC0_INTS_GPIO_QSPI_SD0_LEVEL_LOW = 1U << 8 ;

  // Field GPIO_QSPI_SD0_LEVEL_HIGH: 
    const uint32_t IO_QSPI_PROC0_INTS_GPIO_QSPI_SD0_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO_QSPI_SD0_EDGE_LOW: 
    const uint32_t IO_QSPI_PROC0_INTS_GPIO_QSPI_SD0_EDGE_LOW = 1U << 10 ;

  // Field GPIO_QSPI_SD0_EDGE_HIGH: 
    const uint32_t IO_QSPI_PROC0_INTS_GPIO_QSPI_SD0_EDGE_HIGH = 1U << 11 ;

  // Field GPIO_QSPI_SD1_LEVEL_LOW: 
    const uint32_t IO_QSPI_PROC0_INTS_GPIO_QSPI_SD1_LEVEL_LOW = 1U << 12 ;

  // Field GPIO_QSPI_SD1_LEVEL_HIGH: 
    const uint32_t IO_QSPI_PROC0_INTS_GPIO_QSPI_SD1_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO_QSPI_SD1_EDGE_LOW: 
    const uint32_t IO_QSPI_PROC0_INTS_GPIO_QSPI_SD1_EDGE_LOW = 1U << 14 ;

  // Field GPIO_QSPI_SD1_EDGE_HIGH: 
    const uint32_t IO_QSPI_PROC0_INTS_GPIO_QSPI_SD1_EDGE_HIGH = 1U << 15 ;

  // Field GPIO_QSPI_SD2_LEVEL_LOW: 
    const uint32_t IO_QSPI_PROC0_INTS_GPIO_QSPI_SD2_LEVEL_LOW = 1U << 16 ;

  // Field GPIO_QSPI_SD2_LEVEL_HIGH: 
    const uint32_t IO_QSPI_PROC0_INTS_GPIO_QSPI_SD2_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO_QSPI_SD2_EDGE_LOW: 
    const uint32_t IO_QSPI_PROC0_INTS_GPIO_QSPI_SD2_EDGE_LOW = 1U << 18 ;

  // Field GPIO_QSPI_SD2_EDGE_HIGH: 
    const uint32_t IO_QSPI_PROC0_INTS_GPIO_QSPI_SD2_EDGE_HIGH = 1U << 19 ;

  // Field GPIO_QSPI_SD3_LEVEL_LOW: 
    const uint32_t IO_QSPI_PROC0_INTS_GPIO_QSPI_SD3_LEVEL_LOW = 1U << 20 ;

  // Field GPIO_QSPI_SD3_LEVEL_HIGH: 
    const uint32_t IO_QSPI_PROC0_INTS_GPIO_QSPI_SD3_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO_QSPI_SD3_EDGE_LOW: 
    const uint32_t IO_QSPI_PROC0_INTS_GPIO_QSPI_SD3_EDGE_LOW = 1U << 22 ;

  // Field GPIO_QSPI_SD3_EDGE_HIGH: 
    const uint32_t IO_QSPI_PROC0_INTS_GPIO_QSPI_SD3_EDGE_HIGH = 1U << 23 ;

//------------------------------------------------------------------------------

//---  Register PROC1_INTE: Interrupt Enable for proc1
  static volatile uint32_t & IO_QSPI_PROC1_INTE __attribute__((unused)) = * ((volatile uint32_t *) (0x40018000 + 64)) ;

  // Field GPIO_QSPI_SCLK_LEVEL_LOW: 
    const uint32_t IO_QSPI_PROC1_INTE_GPIO_QSPI_SCLK_LEVEL_LOW = 1U << 0 ;

  // Field GPIO_QSPI_SCLK_LEVEL_HIGH: 
    const uint32_t IO_QSPI_PROC1_INTE_GPIO_QSPI_SCLK_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO_QSPI_SCLK_EDGE_LOW: 
    const uint32_t IO_QSPI_PROC1_INTE_GPIO_QSPI_SCLK_EDGE_LOW = 1U << 2 ;

  // Field GPIO_QSPI_SCLK_EDGE_HIGH: 
    const uint32_t IO_QSPI_PROC1_INTE_GPIO_QSPI_SCLK_EDGE_HIGH = 1U << 3 ;

  // Field GPIO_QSPI_SS_LEVEL_LOW: 
    const uint32_t IO_QSPI_PROC1_INTE_GPIO_QSPI_SS_LEVEL_LOW = 1U << 4 ;

  // Field GPIO_QSPI_SS_LEVEL_HIGH: 
    const uint32_t IO_QSPI_PROC1_INTE_GPIO_QSPI_SS_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO_QSPI_SS_EDGE_LOW: 
    const uint32_t IO_QSPI_PROC1_INTE_GPIO_QSPI_SS_EDGE_LOW = 1U << 6 ;

  // Field GPIO_QSPI_SS_EDGE_HIGH: 
    const uint32_t IO_QSPI_PROC1_INTE_GPIO_QSPI_SS_EDGE_HIGH = 1U << 7 ;

  // Field GPIO_QSPI_SD0_LEVEL_LOW: 
    const uint32_t IO_QSPI_PROC1_INTE_GPIO_QSPI_SD0_LEVEL_LOW = 1U << 8 ;

  // Field GPIO_QSPI_SD0_LEVEL_HIGH: 
    const uint32_t IO_QSPI_PROC1_INTE_GPIO_QSPI_SD0_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO_QSPI_SD0_EDGE_LOW: 
    const uint32_t IO_QSPI_PROC1_INTE_GPIO_QSPI_SD0_EDGE_LOW = 1U << 10 ;

  // Field GPIO_QSPI_SD0_EDGE_HIGH: 
    const uint32_t IO_QSPI_PROC1_INTE_GPIO_QSPI_SD0_EDGE_HIGH = 1U << 11 ;

  // Field GPIO_QSPI_SD1_LEVEL_LOW: 
    const uint32_t IO_QSPI_PROC1_INTE_GPIO_QSPI_SD1_LEVEL_LOW = 1U << 12 ;

  // Field GPIO_QSPI_SD1_LEVEL_HIGH: 
    const uint32_t IO_QSPI_PROC1_INTE_GPIO_QSPI_SD1_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO_QSPI_SD1_EDGE_LOW: 
    const uint32_t IO_QSPI_PROC1_INTE_GPIO_QSPI_SD1_EDGE_LOW = 1U << 14 ;

  // Field GPIO_QSPI_SD1_EDGE_HIGH: 
    const uint32_t IO_QSPI_PROC1_INTE_GPIO_QSPI_SD1_EDGE_HIGH = 1U << 15 ;

  // Field GPIO_QSPI_SD2_LEVEL_LOW: 
    const uint32_t IO_QSPI_PROC1_INTE_GPIO_QSPI_SD2_LEVEL_LOW = 1U << 16 ;

  // Field GPIO_QSPI_SD2_LEVEL_HIGH: 
    const uint32_t IO_QSPI_PROC1_INTE_GPIO_QSPI_SD2_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO_QSPI_SD2_EDGE_LOW: 
    const uint32_t IO_QSPI_PROC1_INTE_GPIO_QSPI_SD2_EDGE_LOW = 1U << 18 ;

  // Field GPIO_QSPI_SD2_EDGE_HIGH: 
    const uint32_t IO_QSPI_PROC1_INTE_GPIO_QSPI_SD2_EDGE_HIGH = 1U << 19 ;

  // Field GPIO_QSPI_SD3_LEVEL_LOW: 
    const uint32_t IO_QSPI_PROC1_INTE_GPIO_QSPI_SD3_LEVEL_LOW = 1U << 20 ;

  // Field GPIO_QSPI_SD3_LEVEL_HIGH: 
    const uint32_t IO_QSPI_PROC1_INTE_GPIO_QSPI_SD3_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO_QSPI_SD3_EDGE_LOW: 
    const uint32_t IO_QSPI_PROC1_INTE_GPIO_QSPI_SD3_EDGE_LOW = 1U << 22 ;

  // Field GPIO_QSPI_SD3_EDGE_HIGH: 
    const uint32_t IO_QSPI_PROC1_INTE_GPIO_QSPI_SD3_EDGE_HIGH = 1U << 23 ;

//------------------------------------------------------------------------------

//---  Register PROC1_INTF: Interrupt Force for proc1
  static volatile uint32_t & IO_QSPI_PROC1_INTF __attribute__((unused)) = * ((volatile uint32_t *) (0x40018000 + 68)) ;

  // Field GPIO_QSPI_SCLK_LEVEL_LOW: 
    const uint32_t IO_QSPI_PROC1_INTF_GPIO_QSPI_SCLK_LEVEL_LOW = 1U << 0 ;

  // Field GPIO_QSPI_SCLK_LEVEL_HIGH: 
    const uint32_t IO_QSPI_PROC1_INTF_GPIO_QSPI_SCLK_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO_QSPI_SCLK_EDGE_LOW: 
    const uint32_t IO_QSPI_PROC1_INTF_GPIO_QSPI_SCLK_EDGE_LOW = 1U << 2 ;

  // Field GPIO_QSPI_SCLK_EDGE_HIGH: 
    const uint32_t IO_QSPI_PROC1_INTF_GPIO_QSPI_SCLK_EDGE_HIGH = 1U << 3 ;

  // Field GPIO_QSPI_SS_LEVEL_LOW: 
    const uint32_t IO_QSPI_PROC1_INTF_GPIO_QSPI_SS_LEVEL_LOW = 1U << 4 ;

  // Field GPIO_QSPI_SS_LEVEL_HIGH: 
    const uint32_t IO_QSPI_PROC1_INTF_GPIO_QSPI_SS_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO_QSPI_SS_EDGE_LOW: 
    const uint32_t IO_QSPI_PROC1_INTF_GPIO_QSPI_SS_EDGE_LOW = 1U << 6 ;

  // Field GPIO_QSPI_SS_EDGE_HIGH: 
    const uint32_t IO_QSPI_PROC1_INTF_GPIO_QSPI_SS_EDGE_HIGH = 1U << 7 ;

  // Field GPIO_QSPI_SD0_LEVEL_LOW: 
    const uint32_t IO_QSPI_PROC1_INTF_GPIO_QSPI_SD0_LEVEL_LOW = 1U << 8 ;

  // Field GPIO_QSPI_SD0_LEVEL_HIGH: 
    const uint32_t IO_QSPI_PROC1_INTF_GPIO_QSPI_SD0_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO_QSPI_SD0_EDGE_LOW: 
    const uint32_t IO_QSPI_PROC1_INTF_GPIO_QSPI_SD0_EDGE_LOW = 1U << 10 ;

  // Field GPIO_QSPI_SD0_EDGE_HIGH: 
    const uint32_t IO_QSPI_PROC1_INTF_GPIO_QSPI_SD0_EDGE_HIGH = 1U << 11 ;

  // Field GPIO_QSPI_SD1_LEVEL_LOW: 
    const uint32_t IO_QSPI_PROC1_INTF_GPIO_QSPI_SD1_LEVEL_LOW = 1U << 12 ;

  // Field GPIO_QSPI_SD1_LEVEL_HIGH: 
    const uint32_t IO_QSPI_PROC1_INTF_GPIO_QSPI_SD1_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO_QSPI_SD1_EDGE_LOW: 
    const uint32_t IO_QSPI_PROC1_INTF_GPIO_QSPI_SD1_EDGE_LOW = 1U << 14 ;

  // Field GPIO_QSPI_SD1_EDGE_HIGH: 
    const uint32_t IO_QSPI_PROC1_INTF_GPIO_QSPI_SD1_EDGE_HIGH = 1U << 15 ;

  // Field GPIO_QSPI_SD2_LEVEL_LOW: 
    const uint32_t IO_QSPI_PROC1_INTF_GPIO_QSPI_SD2_LEVEL_LOW = 1U << 16 ;

  // Field GPIO_QSPI_SD2_LEVEL_HIGH: 
    const uint32_t IO_QSPI_PROC1_INTF_GPIO_QSPI_SD2_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO_QSPI_SD2_EDGE_LOW: 
    const uint32_t IO_QSPI_PROC1_INTF_GPIO_QSPI_SD2_EDGE_LOW = 1U << 18 ;

  // Field GPIO_QSPI_SD2_EDGE_HIGH: 
    const uint32_t IO_QSPI_PROC1_INTF_GPIO_QSPI_SD2_EDGE_HIGH = 1U << 19 ;

  // Field GPIO_QSPI_SD3_LEVEL_LOW: 
    const uint32_t IO_QSPI_PROC1_INTF_GPIO_QSPI_SD3_LEVEL_LOW = 1U << 20 ;

  // Field GPIO_QSPI_SD3_LEVEL_HIGH: 
    const uint32_t IO_QSPI_PROC1_INTF_GPIO_QSPI_SD3_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO_QSPI_SD3_EDGE_LOW: 
    const uint32_t IO_QSPI_PROC1_INTF_GPIO_QSPI_SD3_EDGE_LOW = 1U << 22 ;

  // Field GPIO_QSPI_SD3_EDGE_HIGH: 
    const uint32_t IO_QSPI_PROC1_INTF_GPIO_QSPI_SD3_EDGE_HIGH = 1U << 23 ;

//------------------------------------------------------------------------------

//---  Register PROC1_INTS: Interrupt status after masking & forcing for proc1
  static volatile uint32_t & IO_QSPI_PROC1_INTS __attribute__((unused)) = * ((volatile uint32_t *) (0x40018000 + 72)) ;

  // Field GPIO_QSPI_SCLK_LEVEL_LOW: 
    const uint32_t IO_QSPI_PROC1_INTS_GPIO_QSPI_SCLK_LEVEL_LOW = 1U << 0 ;

  // Field GPIO_QSPI_SCLK_LEVEL_HIGH: 
    const uint32_t IO_QSPI_PROC1_INTS_GPIO_QSPI_SCLK_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO_QSPI_SCLK_EDGE_LOW: 
    const uint32_t IO_QSPI_PROC1_INTS_GPIO_QSPI_SCLK_EDGE_LOW = 1U << 2 ;

  // Field GPIO_QSPI_SCLK_EDGE_HIGH: 
    const uint32_t IO_QSPI_PROC1_INTS_GPIO_QSPI_SCLK_EDGE_HIGH = 1U << 3 ;

  // Field GPIO_QSPI_SS_LEVEL_LOW: 
    const uint32_t IO_QSPI_PROC1_INTS_GPIO_QSPI_SS_LEVEL_LOW = 1U << 4 ;

  // Field GPIO_QSPI_SS_LEVEL_HIGH: 
    const uint32_t IO_QSPI_PROC1_INTS_GPIO_QSPI_SS_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO_QSPI_SS_EDGE_LOW: 
    const uint32_t IO_QSPI_PROC1_INTS_GPIO_QSPI_SS_EDGE_LOW = 1U << 6 ;

  // Field GPIO_QSPI_SS_EDGE_HIGH: 
    const uint32_t IO_QSPI_PROC1_INTS_GPIO_QSPI_SS_EDGE_HIGH = 1U << 7 ;

  // Field GPIO_QSPI_SD0_LEVEL_LOW: 
    const uint32_t IO_QSPI_PROC1_INTS_GPIO_QSPI_SD0_LEVEL_LOW = 1U << 8 ;

  // Field GPIO_QSPI_SD0_LEVEL_HIGH: 
    const uint32_t IO_QSPI_PROC1_INTS_GPIO_QSPI_SD0_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO_QSPI_SD0_EDGE_LOW: 
    const uint32_t IO_QSPI_PROC1_INTS_GPIO_QSPI_SD0_EDGE_LOW = 1U << 10 ;

  // Field GPIO_QSPI_SD0_EDGE_HIGH: 
    const uint32_t IO_QSPI_PROC1_INTS_GPIO_QSPI_SD0_EDGE_HIGH = 1U << 11 ;

  // Field GPIO_QSPI_SD1_LEVEL_LOW: 
    const uint32_t IO_QSPI_PROC1_INTS_GPIO_QSPI_SD1_LEVEL_LOW = 1U << 12 ;

  // Field GPIO_QSPI_SD1_LEVEL_HIGH: 
    const uint32_t IO_QSPI_PROC1_INTS_GPIO_QSPI_SD1_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO_QSPI_SD1_EDGE_LOW: 
    const uint32_t IO_QSPI_PROC1_INTS_GPIO_QSPI_SD1_EDGE_LOW = 1U << 14 ;

  // Field GPIO_QSPI_SD1_EDGE_HIGH: 
    const uint32_t IO_QSPI_PROC1_INTS_GPIO_QSPI_SD1_EDGE_HIGH = 1U << 15 ;

  // Field GPIO_QSPI_SD2_LEVEL_LOW: 
    const uint32_t IO_QSPI_PROC1_INTS_GPIO_QSPI_SD2_LEVEL_LOW = 1U << 16 ;

  // Field GPIO_QSPI_SD2_LEVEL_HIGH: 
    const uint32_t IO_QSPI_PROC1_INTS_GPIO_QSPI_SD2_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO_QSPI_SD2_EDGE_LOW: 
    const uint32_t IO_QSPI_PROC1_INTS_GPIO_QSPI_SD2_EDGE_LOW = 1U << 18 ;

  // Field GPIO_QSPI_SD2_EDGE_HIGH: 
    const uint32_t IO_QSPI_PROC1_INTS_GPIO_QSPI_SD2_EDGE_HIGH = 1U << 19 ;

  // Field GPIO_QSPI_SD3_LEVEL_LOW: 
    const uint32_t IO_QSPI_PROC1_INTS_GPIO_QSPI_SD3_LEVEL_LOW = 1U << 20 ;

  // Field GPIO_QSPI_SD3_LEVEL_HIGH: 
    const uint32_t IO_QSPI_PROC1_INTS_GPIO_QSPI_SD3_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO_QSPI_SD3_EDGE_LOW: 
    const uint32_t IO_QSPI_PROC1_INTS_GPIO_QSPI_SD3_EDGE_LOW = 1U << 22 ;

  // Field GPIO_QSPI_SD3_EDGE_HIGH: 
    const uint32_t IO_QSPI_PROC1_INTS_GPIO_QSPI_SD3_EDGE_HIGH = 1U << 23 ;

//------------------------------------------------------------------------------

//---  Register DORMANT_WAKE_INTE: Interrupt Enable for dormant_wake
  static volatile uint32_t & IO_QSPI_DORMANT_WAKE_INTE __attribute__((unused)) = * ((volatile uint32_t *) (0x40018000 + 76)) ;

  // Field GPIO_QSPI_SCLK_LEVEL_LOW: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SCLK_LEVEL_LOW = 1U << 0 ;

  // Field GPIO_QSPI_SCLK_LEVEL_HIGH: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SCLK_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO_QSPI_SCLK_EDGE_LOW: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SCLK_EDGE_LOW = 1U << 2 ;

  // Field GPIO_QSPI_SCLK_EDGE_HIGH: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SCLK_EDGE_HIGH = 1U << 3 ;

  // Field GPIO_QSPI_SS_LEVEL_LOW: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SS_LEVEL_LOW = 1U << 4 ;

  // Field GPIO_QSPI_SS_LEVEL_HIGH: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SS_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO_QSPI_SS_EDGE_LOW: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SS_EDGE_LOW = 1U << 6 ;

  // Field GPIO_QSPI_SS_EDGE_HIGH: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SS_EDGE_HIGH = 1U << 7 ;

  // Field GPIO_QSPI_SD0_LEVEL_LOW: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD0_LEVEL_LOW = 1U << 8 ;

  // Field GPIO_QSPI_SD0_LEVEL_HIGH: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD0_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO_QSPI_SD0_EDGE_LOW: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD0_EDGE_LOW = 1U << 10 ;

  // Field GPIO_QSPI_SD0_EDGE_HIGH: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD0_EDGE_HIGH = 1U << 11 ;

  // Field GPIO_QSPI_SD1_LEVEL_LOW: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD1_LEVEL_LOW = 1U << 12 ;

  // Field GPIO_QSPI_SD1_LEVEL_HIGH: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD1_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO_QSPI_SD1_EDGE_LOW: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD1_EDGE_LOW = 1U << 14 ;

  // Field GPIO_QSPI_SD1_EDGE_HIGH: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD1_EDGE_HIGH = 1U << 15 ;

  // Field GPIO_QSPI_SD2_LEVEL_LOW: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD2_LEVEL_LOW = 1U << 16 ;

  // Field GPIO_QSPI_SD2_LEVEL_HIGH: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD2_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO_QSPI_SD2_EDGE_LOW: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD2_EDGE_LOW = 1U << 18 ;

  // Field GPIO_QSPI_SD2_EDGE_HIGH: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD2_EDGE_HIGH = 1U << 19 ;

  // Field GPIO_QSPI_SD3_LEVEL_LOW: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD3_LEVEL_LOW = 1U << 20 ;

  // Field GPIO_QSPI_SD3_LEVEL_HIGH: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD3_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO_QSPI_SD3_EDGE_LOW: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD3_EDGE_LOW = 1U << 22 ;

  // Field GPIO_QSPI_SD3_EDGE_HIGH: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD3_EDGE_HIGH = 1U << 23 ;

//------------------------------------------------------------------------------

//---  Register DORMANT_WAKE_INTF: Interrupt Force for dormant_wake
  static volatile uint32_t & IO_QSPI_DORMANT_WAKE_INTF __attribute__((unused)) = * ((volatile uint32_t *) (0x40018000 + 80)) ;

  // Field GPIO_QSPI_SCLK_LEVEL_LOW: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SCLK_LEVEL_LOW = 1U << 0 ;

  // Field GPIO_QSPI_SCLK_LEVEL_HIGH: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SCLK_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO_QSPI_SCLK_EDGE_LOW: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SCLK_EDGE_LOW = 1U << 2 ;

  // Field GPIO_QSPI_SCLK_EDGE_HIGH: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SCLK_EDGE_HIGH = 1U << 3 ;

  // Field GPIO_QSPI_SS_LEVEL_LOW: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SS_LEVEL_LOW = 1U << 4 ;

  // Field GPIO_QSPI_SS_LEVEL_HIGH: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SS_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO_QSPI_SS_EDGE_LOW: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SS_EDGE_LOW = 1U << 6 ;

  // Field GPIO_QSPI_SS_EDGE_HIGH: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SS_EDGE_HIGH = 1U << 7 ;

  // Field GPIO_QSPI_SD0_LEVEL_LOW: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD0_LEVEL_LOW = 1U << 8 ;

  // Field GPIO_QSPI_SD0_LEVEL_HIGH: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD0_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO_QSPI_SD0_EDGE_LOW: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD0_EDGE_LOW = 1U << 10 ;

  // Field GPIO_QSPI_SD0_EDGE_HIGH: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD0_EDGE_HIGH = 1U << 11 ;

  // Field GPIO_QSPI_SD1_LEVEL_LOW: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD1_LEVEL_LOW = 1U << 12 ;

  // Field GPIO_QSPI_SD1_LEVEL_HIGH: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD1_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO_QSPI_SD1_EDGE_LOW: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD1_EDGE_LOW = 1U << 14 ;

  // Field GPIO_QSPI_SD1_EDGE_HIGH: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD1_EDGE_HIGH = 1U << 15 ;

  // Field GPIO_QSPI_SD2_LEVEL_LOW: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD2_LEVEL_LOW = 1U << 16 ;

  // Field GPIO_QSPI_SD2_LEVEL_HIGH: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD2_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO_QSPI_SD2_EDGE_LOW: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD2_EDGE_LOW = 1U << 18 ;

  // Field GPIO_QSPI_SD2_EDGE_HIGH: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD2_EDGE_HIGH = 1U << 19 ;

  // Field GPIO_QSPI_SD3_LEVEL_LOW: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD3_LEVEL_LOW = 1U << 20 ;

  // Field GPIO_QSPI_SD3_LEVEL_HIGH: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD3_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO_QSPI_SD3_EDGE_LOW: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD3_EDGE_LOW = 1U << 22 ;

  // Field GPIO_QSPI_SD3_EDGE_HIGH: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD3_EDGE_HIGH = 1U << 23 ;

//------------------------------------------------------------------------------

//---  Register DORMANT_WAKE_INTS: Interrupt status after masking & forcing for dormant_wake
  static volatile uint32_t & IO_QSPI_DORMANT_WAKE_INTS __attribute__((unused)) = * ((volatile uint32_t *) (0x40018000 + 84)) ;

  // Field GPIO_QSPI_SCLK_LEVEL_LOW: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SCLK_LEVEL_LOW = 1U << 0 ;

  // Field GPIO_QSPI_SCLK_LEVEL_HIGH: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SCLK_LEVEL_HIGH = 1U << 1 ;

  // Field GPIO_QSPI_SCLK_EDGE_LOW: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SCLK_EDGE_LOW = 1U << 2 ;

  // Field GPIO_QSPI_SCLK_EDGE_HIGH: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SCLK_EDGE_HIGH = 1U << 3 ;

  // Field GPIO_QSPI_SS_LEVEL_LOW: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SS_LEVEL_LOW = 1U << 4 ;

  // Field GPIO_QSPI_SS_LEVEL_HIGH: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SS_LEVEL_HIGH = 1U << 5 ;

  // Field GPIO_QSPI_SS_EDGE_LOW: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SS_EDGE_LOW = 1U << 6 ;

  // Field GPIO_QSPI_SS_EDGE_HIGH: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SS_EDGE_HIGH = 1U << 7 ;

  // Field GPIO_QSPI_SD0_LEVEL_LOW: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD0_LEVEL_LOW = 1U << 8 ;

  // Field GPIO_QSPI_SD0_LEVEL_HIGH: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD0_LEVEL_HIGH = 1U << 9 ;

  // Field GPIO_QSPI_SD0_EDGE_LOW: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD0_EDGE_LOW = 1U << 10 ;

  // Field GPIO_QSPI_SD0_EDGE_HIGH: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD0_EDGE_HIGH = 1U << 11 ;

  // Field GPIO_QSPI_SD1_LEVEL_LOW: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD1_LEVEL_LOW = 1U << 12 ;

  // Field GPIO_QSPI_SD1_LEVEL_HIGH: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD1_LEVEL_HIGH = 1U << 13 ;

  // Field GPIO_QSPI_SD1_EDGE_LOW: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD1_EDGE_LOW = 1U << 14 ;

  // Field GPIO_QSPI_SD1_EDGE_HIGH: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD1_EDGE_HIGH = 1U << 15 ;

  // Field GPIO_QSPI_SD2_LEVEL_LOW: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD2_LEVEL_LOW = 1U << 16 ;

  // Field GPIO_QSPI_SD2_LEVEL_HIGH: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD2_LEVEL_HIGH = 1U << 17 ;

  // Field GPIO_QSPI_SD2_EDGE_LOW: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD2_EDGE_LOW = 1U << 18 ;

  // Field GPIO_QSPI_SD2_EDGE_HIGH: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD2_EDGE_HIGH = 1U << 19 ;

  // Field GPIO_QSPI_SD3_LEVEL_LOW: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD3_LEVEL_LOW = 1U << 20 ;

  // Field GPIO_QSPI_SD3_LEVEL_HIGH: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD3_LEVEL_HIGH = 1U << 21 ;

  // Field GPIO_QSPI_SD3_EDGE_LOW: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD3_EDGE_LOW = 1U << 22 ;

  // Field GPIO_QSPI_SD3_EDGE_HIGH: 
    const uint32_t IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD3_EDGE_HIGH = 1U << 23 ;

//------------------------------------------------------------------------------
// Peripheral PADS_BANK0: 
//------------------------------------------------------------------------------

//---  Register VOLTAGE_SELECT: Voltage select. Per bank control
  static volatile uint32_t & PADS_BANK0_VOLTAGE_SELECT __attribute__((unused)) = * ((volatile uint32_t *) (0x4001C000 + 0)) ;

  // Field VOLTAGE_SELECT: 
    const uint32_t PADS_BANK0_VOLTAGE_SELECT_VOLTAGE_SELECT = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register GPIO0: Pad control register
  static volatile uint32_t & PADS_BANK0_GPIO0 __attribute__((unused)) = * ((volatile uint32_t *) (0x4001C000 + 4)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_BANK0_GPIO0_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_BANK0_GPIO0_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_BANK0_GPIO0_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_BANK0_GPIO0_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_BANK0_GPIO0_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_BANK0_GPIO0_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_BANK0_GPIO0_OD = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register GPIO1: Pad control register
  static volatile uint32_t & PADS_BANK0_GPIO1 __attribute__((unused)) = * ((volatile uint32_t *) (0x4001C000 + 8)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_BANK0_GPIO1_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_BANK0_GPIO1_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_BANK0_GPIO1_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_BANK0_GPIO1_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_BANK0_GPIO1_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_BANK0_GPIO1_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_BANK0_GPIO1_OD = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register GPIO2: Pad control register
  static volatile uint32_t & PADS_BANK0_GPIO2 __attribute__((unused)) = * ((volatile uint32_t *) (0x4001C000 + 12)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_BANK0_GPIO2_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_BANK0_GPIO2_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_BANK0_GPIO2_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_BANK0_GPIO2_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_BANK0_GPIO2_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_BANK0_GPIO2_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_BANK0_GPIO2_OD = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register GPIO3: Pad control register
  static volatile uint32_t & PADS_BANK0_GPIO3 __attribute__((unused)) = * ((volatile uint32_t *) (0x4001C000 + 16)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_BANK0_GPIO3_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_BANK0_GPIO3_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_BANK0_GPIO3_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_BANK0_GPIO3_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_BANK0_GPIO3_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_BANK0_GPIO3_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_BANK0_GPIO3_OD = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register GPIO4: Pad control register
  static volatile uint32_t & PADS_BANK0_GPIO4 __attribute__((unused)) = * ((volatile uint32_t *) (0x4001C000 + 20)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_BANK0_GPIO4_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_BANK0_GPIO4_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_BANK0_GPIO4_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_BANK0_GPIO4_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_BANK0_GPIO4_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_BANK0_GPIO4_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_BANK0_GPIO4_OD = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register GPIO5: Pad control register
  static volatile uint32_t & PADS_BANK0_GPIO5 __attribute__((unused)) = * ((volatile uint32_t *) (0x4001C000 + 24)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_BANK0_GPIO5_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_BANK0_GPIO5_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_BANK0_GPIO5_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_BANK0_GPIO5_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_BANK0_GPIO5_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_BANK0_GPIO5_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_BANK0_GPIO5_OD = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register GPIO6: Pad control register
  static volatile uint32_t & PADS_BANK0_GPIO6 __attribute__((unused)) = * ((volatile uint32_t *) (0x4001C000 + 28)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_BANK0_GPIO6_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_BANK0_GPIO6_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_BANK0_GPIO6_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_BANK0_GPIO6_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_BANK0_GPIO6_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_BANK0_GPIO6_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_BANK0_GPIO6_OD = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register GPIO7: Pad control register
  static volatile uint32_t & PADS_BANK0_GPIO7 __attribute__((unused)) = * ((volatile uint32_t *) (0x4001C000 + 32)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_BANK0_GPIO7_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_BANK0_GPIO7_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_BANK0_GPIO7_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_BANK0_GPIO7_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_BANK0_GPIO7_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_BANK0_GPIO7_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_BANK0_GPIO7_OD = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register GPIO8: Pad control register
  static volatile uint32_t & PADS_BANK0_GPIO8 __attribute__((unused)) = * ((volatile uint32_t *) (0x4001C000 + 36)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_BANK0_GPIO8_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_BANK0_GPIO8_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_BANK0_GPIO8_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_BANK0_GPIO8_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_BANK0_GPIO8_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_BANK0_GPIO8_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_BANK0_GPIO8_OD = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register GPIO9: Pad control register
  static volatile uint32_t & PADS_BANK0_GPIO9 __attribute__((unused)) = * ((volatile uint32_t *) (0x4001C000 + 40)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_BANK0_GPIO9_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_BANK0_GPIO9_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_BANK0_GPIO9_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_BANK0_GPIO9_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_BANK0_GPIO9_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_BANK0_GPIO9_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_BANK0_GPIO9_OD = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register GPIO10: Pad control register
  static volatile uint32_t & PADS_BANK0_GPIO10 __attribute__((unused)) = * ((volatile uint32_t *) (0x4001C000 + 44)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_BANK0_GPIO10_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_BANK0_GPIO10_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_BANK0_GPIO10_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_BANK0_GPIO10_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_BANK0_GPIO10_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_BANK0_GPIO10_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_BANK0_GPIO10_OD = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register GPIO11: Pad control register
  static volatile uint32_t & PADS_BANK0_GPIO11 __attribute__((unused)) = * ((volatile uint32_t *) (0x4001C000 + 48)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_BANK0_GPIO11_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_BANK0_GPIO11_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_BANK0_GPIO11_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_BANK0_GPIO11_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_BANK0_GPIO11_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_BANK0_GPIO11_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_BANK0_GPIO11_OD = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register GPIO12: Pad control register
  static volatile uint32_t & PADS_BANK0_GPIO12 __attribute__((unused)) = * ((volatile uint32_t *) (0x4001C000 + 52)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_BANK0_GPIO12_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_BANK0_GPIO12_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_BANK0_GPIO12_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_BANK0_GPIO12_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_BANK0_GPIO12_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_BANK0_GPIO12_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_BANK0_GPIO12_OD = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register GPIO13: Pad control register
  static volatile uint32_t & PADS_BANK0_GPIO13 __attribute__((unused)) = * ((volatile uint32_t *) (0x4001C000 + 56)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_BANK0_GPIO13_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_BANK0_GPIO13_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_BANK0_GPIO13_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_BANK0_GPIO13_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_BANK0_GPIO13_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_BANK0_GPIO13_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_BANK0_GPIO13_OD = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register GPIO14: Pad control register
  static volatile uint32_t & PADS_BANK0_GPIO14 __attribute__((unused)) = * ((volatile uint32_t *) (0x4001C000 + 60)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_BANK0_GPIO14_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_BANK0_GPIO14_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_BANK0_GPIO14_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_BANK0_GPIO14_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_BANK0_GPIO14_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_BANK0_GPIO14_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_BANK0_GPIO14_OD = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register GPIO15: Pad control register
  static volatile uint32_t & PADS_BANK0_GPIO15 __attribute__((unused)) = * ((volatile uint32_t *) (0x4001C000 + 64)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_BANK0_GPIO15_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_BANK0_GPIO15_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_BANK0_GPIO15_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_BANK0_GPIO15_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_BANK0_GPIO15_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_BANK0_GPIO15_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_BANK0_GPIO15_OD = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register GPIO16: Pad control register
  static volatile uint32_t & PADS_BANK0_GPIO16 __attribute__((unused)) = * ((volatile uint32_t *) (0x4001C000 + 68)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_BANK0_GPIO16_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_BANK0_GPIO16_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_BANK0_GPIO16_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_BANK0_GPIO16_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_BANK0_GPIO16_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_BANK0_GPIO16_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_BANK0_GPIO16_OD = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register GPIO17: Pad control register
  static volatile uint32_t & PADS_BANK0_GPIO17 __attribute__((unused)) = * ((volatile uint32_t *) (0x4001C000 + 72)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_BANK0_GPIO17_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_BANK0_GPIO17_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_BANK0_GPIO17_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_BANK0_GPIO17_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_BANK0_GPIO17_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_BANK0_GPIO17_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_BANK0_GPIO17_OD = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register GPIO18: Pad control register
  static volatile uint32_t & PADS_BANK0_GPIO18 __attribute__((unused)) = * ((volatile uint32_t *) (0x4001C000 + 76)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_BANK0_GPIO18_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_BANK0_GPIO18_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_BANK0_GPIO18_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_BANK0_GPIO18_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_BANK0_GPIO18_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_BANK0_GPIO18_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_BANK0_GPIO18_OD = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register GPIO19: Pad control register
  static volatile uint32_t & PADS_BANK0_GPIO19 __attribute__((unused)) = * ((volatile uint32_t *) (0x4001C000 + 80)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_BANK0_GPIO19_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_BANK0_GPIO19_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_BANK0_GPIO19_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_BANK0_GPIO19_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_BANK0_GPIO19_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_BANK0_GPIO19_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_BANK0_GPIO19_OD = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register GPIO20: Pad control register
  static volatile uint32_t & PADS_BANK0_GPIO20 __attribute__((unused)) = * ((volatile uint32_t *) (0x4001C000 + 84)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_BANK0_GPIO20_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_BANK0_GPIO20_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_BANK0_GPIO20_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_BANK0_GPIO20_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_BANK0_GPIO20_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_BANK0_GPIO20_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_BANK0_GPIO20_OD = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register GPIO21: Pad control register
  static volatile uint32_t & PADS_BANK0_GPIO21 __attribute__((unused)) = * ((volatile uint32_t *) (0x4001C000 + 88)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_BANK0_GPIO21_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_BANK0_GPIO21_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_BANK0_GPIO21_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_BANK0_GPIO21_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_BANK0_GPIO21_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_BANK0_GPIO21_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_BANK0_GPIO21_OD = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register GPIO22: Pad control register
  static volatile uint32_t & PADS_BANK0_GPIO22 __attribute__((unused)) = * ((volatile uint32_t *) (0x4001C000 + 92)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_BANK0_GPIO22_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_BANK0_GPIO22_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_BANK0_GPIO22_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_BANK0_GPIO22_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_BANK0_GPIO22_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_BANK0_GPIO22_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_BANK0_GPIO22_OD = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register GPIO23: Pad control register
  static volatile uint32_t & PADS_BANK0_GPIO23 __attribute__((unused)) = * ((volatile uint32_t *) (0x4001C000 + 96)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_BANK0_GPIO23_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_BANK0_GPIO23_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_BANK0_GPIO23_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_BANK0_GPIO23_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_BANK0_GPIO23_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_BANK0_GPIO23_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_BANK0_GPIO23_OD = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register GPIO24: Pad control register
  static volatile uint32_t & PADS_BANK0_GPIO24 __attribute__((unused)) = * ((volatile uint32_t *) (0x4001C000 + 100)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_BANK0_GPIO24_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_BANK0_GPIO24_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_BANK0_GPIO24_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_BANK0_GPIO24_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_BANK0_GPIO24_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_BANK0_GPIO24_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_BANK0_GPIO24_OD = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register GPIO25: Pad control register
  static volatile uint32_t & PADS_BANK0_GPIO25 __attribute__((unused)) = * ((volatile uint32_t *) (0x4001C000 + 104)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_BANK0_GPIO25_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_BANK0_GPIO25_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_BANK0_GPIO25_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_BANK0_GPIO25_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_BANK0_GPIO25_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_BANK0_GPIO25_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_BANK0_GPIO25_OD = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register GPIO26: Pad control register
  static volatile uint32_t & PADS_BANK0_GPIO26 __attribute__((unused)) = * ((volatile uint32_t *) (0x4001C000 + 108)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_BANK0_GPIO26_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_BANK0_GPIO26_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_BANK0_GPIO26_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_BANK0_GPIO26_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_BANK0_GPIO26_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_BANK0_GPIO26_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_BANK0_GPIO26_OD = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register GPIO27: Pad control register
  static volatile uint32_t & PADS_BANK0_GPIO27 __attribute__((unused)) = * ((volatile uint32_t *) (0x4001C000 + 112)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_BANK0_GPIO27_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_BANK0_GPIO27_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_BANK0_GPIO27_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_BANK0_GPIO27_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_BANK0_GPIO27_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_BANK0_GPIO27_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_BANK0_GPIO27_OD = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register GPIO28: Pad control register
  static volatile uint32_t & PADS_BANK0_GPIO28 __attribute__((unused)) = * ((volatile uint32_t *) (0x4001C000 + 116)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_BANK0_GPIO28_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_BANK0_GPIO28_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_BANK0_GPIO28_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_BANK0_GPIO28_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_BANK0_GPIO28_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_BANK0_GPIO28_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_BANK0_GPIO28_OD = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register GPIO29: Pad control register
  static volatile uint32_t & PADS_BANK0_GPIO29 __attribute__((unused)) = * ((volatile uint32_t *) (0x4001C000 + 120)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_BANK0_GPIO29_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_BANK0_GPIO29_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_BANK0_GPIO29_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_BANK0_GPIO29_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_BANK0_GPIO29_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_BANK0_GPIO29_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_BANK0_GPIO29_OD = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register SWCLK: Pad control register
  static volatile uint32_t & PADS_BANK0_SWCLK __attribute__((unused)) = * ((volatile uint32_t *) (0x4001C000 + 124)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_BANK0_SWCLK_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_BANK0_SWCLK_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_BANK0_SWCLK_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_BANK0_SWCLK_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_BANK0_SWCLK_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_BANK0_SWCLK_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_BANK0_SWCLK_OD = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register SWD: Pad control register
  static volatile uint32_t & PADS_BANK0_SWD __attribute__((unused)) = * ((volatile uint32_t *) (0x4001C000 + 128)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_BANK0_SWD_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_BANK0_SWD_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_BANK0_SWD_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_BANK0_SWD_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_BANK0_SWD_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_BANK0_SWD_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_BANK0_SWD_OD = 1U << 7 ;

//------------------------------------------------------------------------------
// Peripheral PADS_QSPI: 
//------------------------------------------------------------------------------

//---  Register VOLTAGE_SELECT: Voltage select. Per bank control
  static volatile uint32_t & PADS_QSPI_VOLTAGE_SELECT __attribute__((unused)) = * ((volatile uint32_t *) (0x40020000 + 0)) ;

  // Field VOLTAGE_SELECT: 
    const uint32_t PADS_QSPI_VOLTAGE_SELECT_VOLTAGE_SELECT = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register GPIO_QSPI_SCLK: Pad control register
  static volatile uint32_t & PADS_QSPI_GPIO_QSPI_SCLK __attribute__((unused)) = * ((volatile uint32_t *) (0x40020000 + 4)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_QSPI_GPIO_QSPI_SCLK_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_QSPI_GPIO_QSPI_SCLK_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_QSPI_GPIO_QSPI_SCLK_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_QSPI_GPIO_QSPI_SCLK_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_QSPI_GPIO_QSPI_SCLK_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_QSPI_GPIO_QSPI_SCLK_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_QSPI_GPIO_QSPI_SCLK_OD = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register GPIO_QSPI_SD0: Pad control register
  static volatile uint32_t & PADS_QSPI_GPIO_QSPI_SD0 __attribute__((unused)) = * ((volatile uint32_t *) (0x40020000 + 8)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_QSPI_GPIO_QSPI_SD0_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_QSPI_GPIO_QSPI_SD0_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_QSPI_GPIO_QSPI_SD0_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_QSPI_GPIO_QSPI_SD0_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_QSPI_GPIO_QSPI_SD0_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_QSPI_GPIO_QSPI_SD0_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_QSPI_GPIO_QSPI_SD0_OD = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register GPIO_QSPI_SD1: Pad control register
  static volatile uint32_t & PADS_QSPI_GPIO_QSPI_SD1 __attribute__((unused)) = * ((volatile uint32_t *) (0x40020000 + 12)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_QSPI_GPIO_QSPI_SD1_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_QSPI_GPIO_QSPI_SD1_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_QSPI_GPIO_QSPI_SD1_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_QSPI_GPIO_QSPI_SD1_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_QSPI_GPIO_QSPI_SD1_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_QSPI_GPIO_QSPI_SD1_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_QSPI_GPIO_QSPI_SD1_OD = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register GPIO_QSPI_SD2: Pad control register
  static volatile uint32_t & PADS_QSPI_GPIO_QSPI_SD2 __attribute__((unused)) = * ((volatile uint32_t *) (0x40020000 + 16)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_QSPI_GPIO_QSPI_SD2_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_QSPI_GPIO_QSPI_SD2_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_QSPI_GPIO_QSPI_SD2_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_QSPI_GPIO_QSPI_SD2_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_QSPI_GPIO_QSPI_SD2_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_QSPI_GPIO_QSPI_SD2_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_QSPI_GPIO_QSPI_SD2_OD = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register GPIO_QSPI_SD3: Pad control register
  static volatile uint32_t & PADS_QSPI_GPIO_QSPI_SD3 __attribute__((unused)) = * ((volatile uint32_t *) (0x40020000 + 20)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_QSPI_GPIO_QSPI_SD3_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_QSPI_GPIO_QSPI_SD3_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_QSPI_GPIO_QSPI_SD3_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_QSPI_GPIO_QSPI_SD3_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_QSPI_GPIO_QSPI_SD3_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_QSPI_GPIO_QSPI_SD3_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_QSPI_GPIO_QSPI_SD3_OD = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register GPIO_QSPI_SS: Pad control register
  static volatile uint32_t & PADS_QSPI_GPIO_QSPI_SS __attribute__((unused)) = * ((volatile uint32_t *) (0x40020000 + 24)) ;

  // Field SLEWFAST: Slew rate control. 1 = Fast, 0 = Slow
    const uint32_t PADS_QSPI_GPIO_QSPI_SS_SLEWFAST = 1U << 0 ;

  // Field SCHMITT: Enable schmitt trigger
    const uint32_t PADS_QSPI_GPIO_QSPI_SS_SCHMITT = 1U << 1 ;

  // Field PDE: Pull down enable
    const uint32_t PADS_QSPI_GPIO_QSPI_SS_PDE = 1U << 2 ;

  // Field PUE: Pull up enable
    const uint32_t PADS_QSPI_GPIO_QSPI_SS_PUE = 1U << 3 ;

  // Field DRIVE: Drive strength.
    inline uint32_t PADS_QSPI_GPIO_QSPI_SS_DRIVE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IE: Input enable
    const uint32_t PADS_QSPI_GPIO_QSPI_SS_IE = 1U << 6 ;

  // Field OD: Output disable. Has priority over output enable from peripherals
    const uint32_t PADS_QSPI_GPIO_QSPI_SS_OD = 1U << 7 ;

//------------------------------------------------------------------------------
// Peripheral PIO0: Programmable IO block
//------------------------------------------------------------------------------

//---  Register CTRL: PIO control register
  static volatile uint32_t & PIO0_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 0)) ;

  // Field SM_ENABLE: Enable state machine
    inline uint32_t PIO0_CTRL_SM_ENABLE (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field SM_RESTART: Clear internal SM state which is otherwise difficult to access\n (e.g. shift counters). Self-clearing.
    inline uint32_t PIO0_CTRL_SM_RESTART (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field CLKDIV_RESTART: Force clock dividers to restart their count and clear fractional\n accumulators. Restart multiple dividers to synchronise them.
    inline uint32_t PIO0_CTRL_CLKDIV_RESTART (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register FSTAT: FIFO status register
  static volatile uint32_t & PIO0_FSTAT __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 4)) ;

  // Field RXFULL: State machine RX FIFO is full
    inline uint32_t PIO0_FSTAT_RXFULL (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field RXEMPTY: State machine RX FIFO is empty
    inline uint32_t PIO0_FSTAT_RXEMPTY (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field TXFULL: State machine TX FIFO is full
    inline uint32_t PIO0_FSTAT_TXFULL (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field TXEMPTY: State machine TX FIFO is empty
    inline uint32_t PIO0_FSTAT_TXEMPTY (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register FDEBUG: FIFO debug register
  static volatile uint32_t & PIO0_FDEBUG __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 8)) ;

  // Field RXSTALL: State machine has stalled on full RX FIFO. Write 1 to clear.
    inline uint32_t PIO0_FDEBUG_RXSTALL (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field RXUNDER: RX FIFO underflow has occurred. Write 1 to clear.
    inline uint32_t PIO0_FDEBUG_RXUNDER (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field TXOVER: TX FIFO overflow has occurred. Write 1 to clear.
    inline uint32_t PIO0_FDEBUG_TXOVER (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field TXSTALL: State machine has stalled on empty TX FIFO. Write 1 to clear.
    inline uint32_t PIO0_FDEBUG_TXSTALL (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register FLEVEL: FIFO levels
  static volatile uint32_t & PIO0_FLEVEL __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 12)) ;

  // Field TX0: 
    inline uint32_t PIO0_FLEVEL_TX0 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field RX0: 
    inline uint32_t PIO0_FLEVEL_RX0 (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field TX1: 
    inline uint32_t PIO0_FLEVEL_TX1 (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field RX1: 
    inline uint32_t PIO0_FLEVEL_RX1 (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field TX2: 
    inline uint32_t PIO0_FLEVEL_TX2 (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field RX2: 
    inline uint32_t PIO0_FLEVEL_RX2 (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field TX3: 
    inline uint32_t PIO0_FLEVEL_TX3 (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field RX3: 
    inline uint32_t PIO0_FLEVEL_RX3 (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

//------------------------------------------------------------------------------

//---  Register TXF0: Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO.
  static volatile uint32_t & PIO0_TXF0 __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 16)) ;

//------------------------------------------------------------------------------

//---  Register TXF1: Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO.
  static volatile uint32_t & PIO0_TXF1 __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 20)) ;

//------------------------------------------------------------------------------

//---  Register TXF2: Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO.
  static volatile uint32_t & PIO0_TXF2 __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 24)) ;

//------------------------------------------------------------------------------

//---  Register TXF3: Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO.
  static volatile uint32_t & PIO0_TXF3 __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 28)) ;

//------------------------------------------------------------------------------

//---  Register RXF0: Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO.
  static volatile uint32_t const & PIO0_RXF0 __attribute__((unused)) = * ((const volatile uint32_t *) (0x50200000 + 32)) ;

//------------------------------------------------------------------------------

//---  Register RXF1: Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO.
  static volatile uint32_t const & PIO0_RXF1 __attribute__((unused)) = * ((const volatile uint32_t *) (0x50200000 + 36)) ;

//------------------------------------------------------------------------------

//---  Register RXF2: Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO.
  static volatile uint32_t const & PIO0_RXF2 __attribute__((unused)) = * ((const volatile uint32_t *) (0x50200000 + 40)) ;

//------------------------------------------------------------------------------

//---  Register RXF3: Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO.
  static volatile uint32_t const & PIO0_RXF3 __attribute__((unused)) = * ((const volatile uint32_t *) (0x50200000 + 44)) ;

//------------------------------------------------------------------------------

//---  Register IRQ: Interrupt request register. Write 1 to clear
  static volatile uint32_t & PIO0_IRQ __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 48)) ;

  // Field IRQ: 
    inline uint32_t PIO0_IRQ_IRQ (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IRQ_FORCE: Writing a 1 to each of these bits will forcibly assert the corresponding IRQ.\n Note this is different to the INTF register: writing here affects PIO internal\n state. INTF just asserts the processor-facing IRQ signal for testing ISRs,\n and is not visible to the state machines.
  static volatile uint32_t & PIO0_IRQ_FORCE __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 52)) ;

  // Field IRQ_FORCE: 
    inline uint32_t PIO0_IRQ_FORCE_IRQ_FORCE (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INPUT_SYNC_BYPASS: There is a 2-flipflop synchronizer on each GPIO input, which protects\n PIO logic from metastabilities. This increases input delay, and for fast\n synchronous IO (e.g. SPI) these synchronizers may need to be bypassed.\n Each bit in this register corresponds to one GPIO.\n 0 -> input is synchronized (default)\n 1 -> synchronizer is bypassed\n If in doubt, leave this register as all zeroes.
  static volatile uint32_t & PIO0_INPUT_SYNC_BYPASS __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 56)) ;

//------------------------------------------------------------------------------

//---  Register DBG_PADOUT: Read to sample the pad output values PIO is currently driving to the GPIOs.
  static volatile uint32_t const & PIO0_DBG_PADOUT __attribute__((unused)) = * ((const volatile uint32_t *) (0x50200000 + 60)) ;

//------------------------------------------------------------------------------

//---  Register DBG_PADOE: Read to sample the pad output enables (direction) PIO is currently driving to the GPIOs.
  static volatile uint32_t const & PIO0_DBG_PADOE __attribute__((unused)) = * ((const volatile uint32_t *) (0x50200000 + 64)) ;

//------------------------------------------------------------------------------

//---  Register DBG_CFGINFO: The PIO hardware has some free parameters that may vary between chip products.\n These should be provided in the chip datasheet, but are also exposed here.
  static volatile uint32_t & PIO0_DBG_CFGINFO __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 68)) ;

  // Field FIFO_DEPTH: The depth of the state machine TX/RX FIFOs, measured in words.\n Joining fifos via SHIFTCTRL_FJOIN gives one FIFO with double\n this depth.
    inline uint32_t PIO0_DBG_CFGINFO_FIFO_DEPTH (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

  // Field SM_COUNT: The number of state machines this PIO instance is equipped with.
    inline uint32_t PIO0_DBG_CFGINFO_SM_COUNT (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field IMEM_SIZE: The size of the instruction memory, measured in units of one instruction
    inline uint32_t PIO0_DBG_CFGINFO_IMEM_SIZE (const uint32_t inValue) {return (inValue & 0x3FU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM0: Write-only access to instruction memory location 0
  static volatile uint32_t & PIO0_INSTR_MEM0 __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 72)) ;

  // Field INSTR_MEM0: 
    inline uint32_t PIO0_INSTR_MEM0_INSTR_MEM0 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM1: Write-only access to instruction memory location 1
  static volatile uint32_t & PIO0_INSTR_MEM1 __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 76)) ;

  // Field INSTR_MEM1: 
    inline uint32_t PIO0_INSTR_MEM1_INSTR_MEM1 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM2: Write-only access to instruction memory location 2
  static volatile uint32_t & PIO0_INSTR_MEM2 __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 80)) ;

  // Field INSTR_MEM2: 
    inline uint32_t PIO0_INSTR_MEM2_INSTR_MEM2 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM3: Write-only access to instruction memory location 3
  static volatile uint32_t & PIO0_INSTR_MEM3 __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 84)) ;

  // Field INSTR_MEM3: 
    inline uint32_t PIO0_INSTR_MEM3_INSTR_MEM3 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM4: Write-only access to instruction memory location 4
  static volatile uint32_t & PIO0_INSTR_MEM4 __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 88)) ;

  // Field INSTR_MEM4: 
    inline uint32_t PIO0_INSTR_MEM4_INSTR_MEM4 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM5: Write-only access to instruction memory location 5
  static volatile uint32_t & PIO0_INSTR_MEM5 __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 92)) ;

  // Field INSTR_MEM5: 
    inline uint32_t PIO0_INSTR_MEM5_INSTR_MEM5 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM6: Write-only access to instruction memory location 6
  static volatile uint32_t & PIO0_INSTR_MEM6 __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 96)) ;

  // Field INSTR_MEM6: 
    inline uint32_t PIO0_INSTR_MEM6_INSTR_MEM6 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM7: Write-only access to instruction memory location 7
  static volatile uint32_t & PIO0_INSTR_MEM7 __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 100)) ;

  // Field INSTR_MEM7: 
    inline uint32_t PIO0_INSTR_MEM7_INSTR_MEM7 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM8: Write-only access to instruction memory location 8
  static volatile uint32_t & PIO0_INSTR_MEM8 __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 104)) ;

  // Field INSTR_MEM8: 
    inline uint32_t PIO0_INSTR_MEM8_INSTR_MEM8 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM9: Write-only access to instruction memory location 9
  static volatile uint32_t & PIO0_INSTR_MEM9 __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 108)) ;

  // Field INSTR_MEM9: 
    inline uint32_t PIO0_INSTR_MEM9_INSTR_MEM9 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM10: Write-only access to instruction memory location 10
  static volatile uint32_t & PIO0_INSTR_MEM10 __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 112)) ;

  // Field INSTR_MEM10: 
    inline uint32_t PIO0_INSTR_MEM10_INSTR_MEM10 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM11: Write-only access to instruction memory location 11
  static volatile uint32_t & PIO0_INSTR_MEM11 __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 116)) ;

  // Field INSTR_MEM11: 
    inline uint32_t PIO0_INSTR_MEM11_INSTR_MEM11 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM12: Write-only access to instruction memory location 12
  static volatile uint32_t & PIO0_INSTR_MEM12 __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 120)) ;

  // Field INSTR_MEM12: 
    inline uint32_t PIO0_INSTR_MEM12_INSTR_MEM12 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM13: Write-only access to instruction memory location 13
  static volatile uint32_t & PIO0_INSTR_MEM13 __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 124)) ;

  // Field INSTR_MEM13: 
    inline uint32_t PIO0_INSTR_MEM13_INSTR_MEM13 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM14: Write-only access to instruction memory location 14
  static volatile uint32_t & PIO0_INSTR_MEM14 __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 128)) ;

  // Field INSTR_MEM14: 
    inline uint32_t PIO0_INSTR_MEM14_INSTR_MEM14 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM15: Write-only access to instruction memory location 15
  static volatile uint32_t & PIO0_INSTR_MEM15 __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 132)) ;

  // Field INSTR_MEM15: 
    inline uint32_t PIO0_INSTR_MEM15_INSTR_MEM15 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM16: Write-only access to instruction memory location 16
  static volatile uint32_t & PIO0_INSTR_MEM16 __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 136)) ;

  // Field INSTR_MEM16: 
    inline uint32_t PIO0_INSTR_MEM16_INSTR_MEM16 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM17: Write-only access to instruction memory location 17
  static volatile uint32_t & PIO0_INSTR_MEM17 __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 140)) ;

  // Field INSTR_MEM17: 
    inline uint32_t PIO0_INSTR_MEM17_INSTR_MEM17 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM18: Write-only access to instruction memory location 18
  static volatile uint32_t & PIO0_INSTR_MEM18 __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 144)) ;

  // Field INSTR_MEM18: 
    inline uint32_t PIO0_INSTR_MEM18_INSTR_MEM18 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM19: Write-only access to instruction memory location 19
  static volatile uint32_t & PIO0_INSTR_MEM19 __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 148)) ;

  // Field INSTR_MEM19: 
    inline uint32_t PIO0_INSTR_MEM19_INSTR_MEM19 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM20: Write-only access to instruction memory location 20
  static volatile uint32_t & PIO0_INSTR_MEM20 __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 152)) ;

  // Field INSTR_MEM20: 
    inline uint32_t PIO0_INSTR_MEM20_INSTR_MEM20 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM21: Write-only access to instruction memory location 21
  static volatile uint32_t & PIO0_INSTR_MEM21 __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 156)) ;

  // Field INSTR_MEM21: 
    inline uint32_t PIO0_INSTR_MEM21_INSTR_MEM21 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM22: Write-only access to instruction memory location 22
  static volatile uint32_t & PIO0_INSTR_MEM22 __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 160)) ;

  // Field INSTR_MEM22: 
    inline uint32_t PIO0_INSTR_MEM22_INSTR_MEM22 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM23: Write-only access to instruction memory location 23
  static volatile uint32_t & PIO0_INSTR_MEM23 __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 164)) ;

  // Field INSTR_MEM23: 
    inline uint32_t PIO0_INSTR_MEM23_INSTR_MEM23 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM24: Write-only access to instruction memory location 24
  static volatile uint32_t & PIO0_INSTR_MEM24 __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 168)) ;

  // Field INSTR_MEM24: 
    inline uint32_t PIO0_INSTR_MEM24_INSTR_MEM24 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM25: Write-only access to instruction memory location 25
  static volatile uint32_t & PIO0_INSTR_MEM25 __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 172)) ;

  // Field INSTR_MEM25: 
    inline uint32_t PIO0_INSTR_MEM25_INSTR_MEM25 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM26: Write-only access to instruction memory location 26
  static volatile uint32_t & PIO0_INSTR_MEM26 __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 176)) ;

  // Field INSTR_MEM26: 
    inline uint32_t PIO0_INSTR_MEM26_INSTR_MEM26 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM27: Write-only access to instruction memory location 27
  static volatile uint32_t & PIO0_INSTR_MEM27 __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 180)) ;

  // Field INSTR_MEM27: 
    inline uint32_t PIO0_INSTR_MEM27_INSTR_MEM27 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM28: Write-only access to instruction memory location 28
  static volatile uint32_t & PIO0_INSTR_MEM28 __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 184)) ;

  // Field INSTR_MEM28: 
    inline uint32_t PIO0_INSTR_MEM28_INSTR_MEM28 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM29: Write-only access to instruction memory location 29
  static volatile uint32_t & PIO0_INSTR_MEM29 __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 188)) ;

  // Field INSTR_MEM29: 
    inline uint32_t PIO0_INSTR_MEM29_INSTR_MEM29 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM30: Write-only access to instruction memory location 30
  static volatile uint32_t & PIO0_INSTR_MEM30 __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 192)) ;

  // Field INSTR_MEM30: 
    inline uint32_t PIO0_INSTR_MEM30_INSTR_MEM30 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM31: Write-only access to instruction memory location 31
  static volatile uint32_t & PIO0_INSTR_MEM31 __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 196)) ;

  // Field INSTR_MEM31: 
    inline uint32_t PIO0_INSTR_MEM31_INSTR_MEM31 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SM0_CLKDIV: Clock divider register for state machine 0\n Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
  static volatile uint32_t & PIO0_SM0_CLKDIV __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 200)) ;

  // Field FRAC: Fractional part of clock divider
    inline uint32_t PIO0_SM0_CLKDIV_FRAC (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field INT: Effective frequency is sysclk/int.\n Value of 0 is interpreted as max possible value
    inline uint32_t PIO0_SM0_CLKDIV_INT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register SM0_EXECCTRL: Execution/behavioural settings for state machine 0
  static volatile uint32_t & PIO0_SM0_EXECCTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 204)) ;

  // Field STATUS_N: Comparison level for the MOV x, STATUS instruction
    inline uint32_t PIO0_SM0_EXECCTRL_STATUS_N (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field STATUS_SEL: Comparison used for the MOV x, STATUS instruction.
    const uint32_t PIO0_SM0_EXECCTRL_STATUS_SEL = 1U << 4 ;

  // Field WRAP_BOTTOM: After reaching wrap_top, execution is wrapped to this address.
    inline uint32_t PIO0_SM0_EXECCTRL_WRAP_BOTTOM (const uint32_t inValue) {return (inValue & 0x1FU) << 7 ; }

  // Field WRAP_TOP: After reaching this address, execution is wrapped to wrap_bottom.\n If the instruction is a jump, and the jump condition is true, the jump takes priority.
    inline uint32_t PIO0_SM0_EXECCTRL_WRAP_TOP (const uint32_t inValue) {return (inValue & 0x1FU) << 12 ; }

  // Field OUT_STICKY: Continuously assert the most recent OUT/SET to the pins
    const uint32_t PIO0_SM0_EXECCTRL_OUT_STICKY = 1U << 17 ;

  // Field INLINE_OUT_EN: If 1, use a bit of OUT data as an auxiliary write enable\n When used in conjunction with OUT_STICKY, writes with an enable of 0 will\n deassert the latest pin write. This can create useful masking/override behaviour\n due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)
    const uint32_t PIO0_SM0_EXECCTRL_INLINE_OUT_EN = 1U << 18 ;

  // Field OUT_EN_SEL: Which data bit to use for inline OUT enable
    inline uint32_t PIO0_SM0_EXECCTRL_OUT_EN_SEL (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

  // Field JMP_PIN: The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
    inline uint32_t PIO0_SM0_EXECCTRL_JMP_PIN (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

  // Field SIDE_PINDIR: Side-set data is asserted to pin OEs instead of pin values
    const uint32_t PIO0_SM0_EXECCTRL_SIDE_PINDIR = 1U << 29 ;

  // Field SIDE_EN: If 1, the delay MSB is used as side-set enable, rather than a\n side-set data bit. This allows instructions to perform side-set optionally,\n rather than on every instruction.
    const uint32_t PIO0_SM0_EXECCTRL_SIDE_EN = 1U << 30 ;

  // Field EXEC_STALLED: An instruction written to SMx_INSTR is stalled, and latched by the\n state machine. Will clear once the instruction completes.
    const uint32_t PIO0_SM0_EXECCTRL_EXEC_STALLED = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register SM0_SHIFTCTRL: Control behaviour of the input/output shift registers for state machine 0
  static volatile uint32_t & PIO0_SM0_SHIFTCTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 208)) ;

  // Field AUTOPUSH: Push automatically when the input shift register is filled
    const uint32_t PIO0_SM0_SHIFTCTRL_AUTOPUSH = 1U << 16 ;

  // Field AUTOPULL: Pull automatically when the output shift register is emptied
    const uint32_t PIO0_SM0_SHIFTCTRL_AUTOPULL = 1U << 17 ;

  // Field IN_SHIFTDIR: 1 = shift input shift register to right (data enters from left). 0 = to left.
    const uint32_t PIO0_SM0_SHIFTCTRL_IN_SHIFTDIR = 1U << 18 ;

  // Field OUT_SHIFTDIR: 1 = shift out of output shift register to right. 0 = to left.
    const uint32_t PIO0_SM0_SHIFTCTRL_OUT_SHIFTDIR = 1U << 19 ;

  // Field PUSH_THRESH: Number of bits shifted into RXSR before autopush or conditional push.\n Write 0 for value of 32.
    inline uint32_t PIO0_SM0_SHIFTCTRL_PUSH_THRESH (const uint32_t inValue) {return (inValue & 0x1FU) << 20 ; }

  // Field PULL_THRESH: Number of bits shifted out of TXSR before autopull or conditional pull.\n Write 0 for value of 32.
    inline uint32_t PIO0_SM0_SHIFTCTRL_PULL_THRESH (const uint32_t inValue) {return (inValue & 0x1FU) << 25 ; }

  // Field FJOIN_TX: When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep.\n RX FIFO is disabled as a result (always reads as both full and empty).\n FIFOs are flushed when this bit is changed.
    const uint32_t PIO0_SM0_SHIFTCTRL_FJOIN_TX = 1U << 30 ;

  // Field FJOIN_RX: When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep.\n TX FIFO is disabled as a result (always reads as both full and empty).\n FIFOs are flushed when this bit is changed.
    const uint32_t PIO0_SM0_SHIFTCTRL_FJOIN_RX = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register SM0_ADDR: Current instruction address of state machine 0
  static volatile uint32_t & PIO0_SM0_ADDR __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 212)) ;

  // Field SM0_ADDR: 
    inline uint32_t PIO0_SM0_ADDR_SM0_ADDR (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SM0_INSTR: Instruction currently being executed by state machine 0\n Write to execute an instruction immediately (including jumps) and then resume execution.
  static volatile uint32_t & PIO0_SM0_INSTR __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 216)) ;

  // Field SM0_INSTR: 
    inline uint32_t PIO0_SM0_INSTR_SM0_INSTR (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SM0_PINCTRL: State machine pin control
  static volatile uint32_t & PIO0_SM0_PINCTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 220)) ;

  // Field OUT_BASE: The virtual pin corresponding to OUT bit 0
    inline uint32_t PIO0_SM0_PINCTRL_OUT_BASE (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field SET_BASE: The virtual pin corresponding to SET bit 0
    inline uint32_t PIO0_SM0_PINCTRL_SET_BASE (const uint32_t inValue) {return (inValue & 0x1FU) << 5 ; }

  // Field SIDESET_BASE: The virtual pin corresponding to delay field bit 0
    inline uint32_t PIO0_SM0_PINCTRL_SIDESET_BASE (const uint32_t inValue) {return (inValue & 0x1FU) << 10 ; }

  // Field IN_BASE: The virtual pin corresponding to IN bit 0
    inline uint32_t PIO0_SM0_PINCTRL_IN_BASE (const uint32_t inValue) {return (inValue & 0x1FU) << 15 ; }

  // Field OUT_COUNT: The number of pins asserted by an OUT. Value of 0 -> 32 pins
    inline uint32_t PIO0_SM0_PINCTRL_OUT_COUNT (const uint32_t inValue) {return (inValue & 0x3FU) << 20 ; }

  // Field SET_COUNT: The number of pins asserted by a SET. Max of 5
    inline uint32_t PIO0_SM0_PINCTRL_SET_COUNT (const uint32_t inValue) {return (inValue & 0x7U) << 26 ; }

  // Field SIDESET_COUNT: The number of delay bits co-opted for side-set. Inclusive of the enable bit, if present.
    inline uint32_t PIO0_SM0_PINCTRL_SIDESET_COUNT (const uint32_t inValue) {return (inValue & 0x7U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register SM1_CLKDIV: Clock divider register for state machine 1\n Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
  static volatile uint32_t & PIO0_SM1_CLKDIV __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 224)) ;

  // Field FRAC: Fractional part of clock divider
    inline uint32_t PIO0_SM1_CLKDIV_FRAC (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field INT: Effective frequency is sysclk/int.\n Value of 0 is interpreted as max possible value
    inline uint32_t PIO0_SM1_CLKDIV_INT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register SM1_EXECCTRL: Execution/behavioural settings for state machine 1
  static volatile uint32_t & PIO0_SM1_EXECCTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 228)) ;

  // Field STATUS_N: Comparison level for the MOV x, STATUS instruction
    inline uint32_t PIO0_SM1_EXECCTRL_STATUS_N (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field STATUS_SEL: Comparison used for the MOV x, STATUS instruction.
    const uint32_t PIO0_SM1_EXECCTRL_STATUS_SEL = 1U << 4 ;

  // Field WRAP_BOTTOM: After reaching wrap_top, execution is wrapped to this address.
    inline uint32_t PIO0_SM1_EXECCTRL_WRAP_BOTTOM (const uint32_t inValue) {return (inValue & 0x1FU) << 7 ; }

  // Field WRAP_TOP: After reaching this address, execution is wrapped to wrap_bottom.\n If the instruction is a jump, and the jump condition is true, the jump takes priority.
    inline uint32_t PIO0_SM1_EXECCTRL_WRAP_TOP (const uint32_t inValue) {return (inValue & 0x1FU) << 12 ; }

  // Field OUT_STICKY: Continuously assert the most recent OUT/SET to the pins
    const uint32_t PIO0_SM1_EXECCTRL_OUT_STICKY = 1U << 17 ;

  // Field INLINE_OUT_EN: If 1, use a bit of OUT data as an auxiliary write enable\n When used in conjunction with OUT_STICKY, writes with an enable of 0 will\n deassert the latest pin write. This can create useful masking/override behaviour\n due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)
    const uint32_t PIO0_SM1_EXECCTRL_INLINE_OUT_EN = 1U << 18 ;

  // Field OUT_EN_SEL: Which data bit to use for inline OUT enable
    inline uint32_t PIO0_SM1_EXECCTRL_OUT_EN_SEL (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

  // Field JMP_PIN: The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
    inline uint32_t PIO0_SM1_EXECCTRL_JMP_PIN (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

  // Field SIDE_PINDIR: Side-set data is asserted to pin OEs instead of pin values
    const uint32_t PIO0_SM1_EXECCTRL_SIDE_PINDIR = 1U << 29 ;

  // Field SIDE_EN: If 1, the delay MSB is used as side-set enable, rather than a\n side-set data bit. This allows instructions to perform side-set optionally,\n rather than on every instruction.
    const uint32_t PIO0_SM1_EXECCTRL_SIDE_EN = 1U << 30 ;

  // Field EXEC_STALLED: An instruction written to SMx_INSTR is stalled, and latched by the\n state machine. Will clear once the instruction completes.
    const uint32_t PIO0_SM1_EXECCTRL_EXEC_STALLED = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register SM1_SHIFTCTRL: Control behaviour of the input/output shift registers for state machine 1
  static volatile uint32_t & PIO0_SM1_SHIFTCTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 232)) ;

  // Field AUTOPUSH: Push automatically when the input shift register is filled
    const uint32_t PIO0_SM1_SHIFTCTRL_AUTOPUSH = 1U << 16 ;

  // Field AUTOPULL: Pull automatically when the output shift register is emptied
    const uint32_t PIO0_SM1_SHIFTCTRL_AUTOPULL = 1U << 17 ;

  // Field IN_SHIFTDIR: 1 = shift input shift register to right (data enters from left). 0 = to left.
    const uint32_t PIO0_SM1_SHIFTCTRL_IN_SHIFTDIR = 1U << 18 ;

  // Field OUT_SHIFTDIR: 1 = shift out of output shift register to right. 0 = to left.
    const uint32_t PIO0_SM1_SHIFTCTRL_OUT_SHIFTDIR = 1U << 19 ;

  // Field PUSH_THRESH: Number of bits shifted into RXSR before autopush or conditional push.\n Write 0 for value of 32.
    inline uint32_t PIO0_SM1_SHIFTCTRL_PUSH_THRESH (const uint32_t inValue) {return (inValue & 0x1FU) << 20 ; }

  // Field PULL_THRESH: Number of bits shifted out of TXSR before autopull or conditional pull.\n Write 0 for value of 32.
    inline uint32_t PIO0_SM1_SHIFTCTRL_PULL_THRESH (const uint32_t inValue) {return (inValue & 0x1FU) << 25 ; }

  // Field FJOIN_TX: When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep.\n RX FIFO is disabled as a result (always reads as both full and empty).\n FIFOs are flushed when this bit is changed.
    const uint32_t PIO0_SM1_SHIFTCTRL_FJOIN_TX = 1U << 30 ;

  // Field FJOIN_RX: When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep.\n TX FIFO is disabled as a result (always reads as both full and empty).\n FIFOs are flushed when this bit is changed.
    const uint32_t PIO0_SM1_SHIFTCTRL_FJOIN_RX = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register SM1_ADDR: Current instruction address of state machine 1
  static volatile uint32_t & PIO0_SM1_ADDR __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 236)) ;

  // Field SM1_ADDR: 
    inline uint32_t PIO0_SM1_ADDR_SM1_ADDR (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SM1_INSTR: Instruction currently being executed by state machine 1\n Write to execute an instruction immediately (including jumps) and then resume execution.
  static volatile uint32_t & PIO0_SM1_INSTR __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 240)) ;

  // Field SM1_INSTR: 
    inline uint32_t PIO0_SM1_INSTR_SM1_INSTR (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SM1_PINCTRL: State machine pin control
  static volatile uint32_t & PIO0_SM1_PINCTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 244)) ;

  // Field OUT_BASE: The virtual pin corresponding to OUT bit 0
    inline uint32_t PIO0_SM1_PINCTRL_OUT_BASE (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field SET_BASE: The virtual pin corresponding to SET bit 0
    inline uint32_t PIO0_SM1_PINCTRL_SET_BASE (const uint32_t inValue) {return (inValue & 0x1FU) << 5 ; }

  // Field SIDESET_BASE: The virtual pin corresponding to delay field bit 0
    inline uint32_t PIO0_SM1_PINCTRL_SIDESET_BASE (const uint32_t inValue) {return (inValue & 0x1FU) << 10 ; }

  // Field IN_BASE: The virtual pin corresponding to IN bit 0
    inline uint32_t PIO0_SM1_PINCTRL_IN_BASE (const uint32_t inValue) {return (inValue & 0x1FU) << 15 ; }

  // Field OUT_COUNT: The number of pins asserted by an OUT. Value of 0 -> 32 pins
    inline uint32_t PIO0_SM1_PINCTRL_OUT_COUNT (const uint32_t inValue) {return (inValue & 0x3FU) << 20 ; }

  // Field SET_COUNT: The number of pins asserted by a SET. Max of 5
    inline uint32_t PIO0_SM1_PINCTRL_SET_COUNT (const uint32_t inValue) {return (inValue & 0x7U) << 26 ; }

  // Field SIDESET_COUNT: The number of delay bits co-opted for side-set. Inclusive of the enable bit, if present.
    inline uint32_t PIO0_SM1_PINCTRL_SIDESET_COUNT (const uint32_t inValue) {return (inValue & 0x7U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register SM2_CLKDIV: Clock divider register for state machine 2\n Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
  static volatile uint32_t & PIO0_SM2_CLKDIV __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 248)) ;

  // Field FRAC: Fractional part of clock divider
    inline uint32_t PIO0_SM2_CLKDIV_FRAC (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field INT: Effective frequency is sysclk/int.\n Value of 0 is interpreted as max possible value
    inline uint32_t PIO0_SM2_CLKDIV_INT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register SM2_EXECCTRL: Execution/behavioural settings for state machine 2
  static volatile uint32_t & PIO0_SM2_EXECCTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 252)) ;

  // Field STATUS_N: Comparison level for the MOV x, STATUS instruction
    inline uint32_t PIO0_SM2_EXECCTRL_STATUS_N (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field STATUS_SEL: Comparison used for the MOV x, STATUS instruction.
    const uint32_t PIO0_SM2_EXECCTRL_STATUS_SEL = 1U << 4 ;

  // Field WRAP_BOTTOM: After reaching wrap_top, execution is wrapped to this address.
    inline uint32_t PIO0_SM2_EXECCTRL_WRAP_BOTTOM (const uint32_t inValue) {return (inValue & 0x1FU) << 7 ; }

  // Field WRAP_TOP: After reaching this address, execution is wrapped to wrap_bottom.\n If the instruction is a jump, and the jump condition is true, the jump takes priority.
    inline uint32_t PIO0_SM2_EXECCTRL_WRAP_TOP (const uint32_t inValue) {return (inValue & 0x1FU) << 12 ; }

  // Field OUT_STICKY: Continuously assert the most recent OUT/SET to the pins
    const uint32_t PIO0_SM2_EXECCTRL_OUT_STICKY = 1U << 17 ;

  // Field INLINE_OUT_EN: If 1, use a bit of OUT data as an auxiliary write enable\n When used in conjunction with OUT_STICKY, writes with an enable of 0 will\n deassert the latest pin write. This can create useful masking/override behaviour\n due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)
    const uint32_t PIO0_SM2_EXECCTRL_INLINE_OUT_EN = 1U << 18 ;

  // Field OUT_EN_SEL: Which data bit to use for inline OUT enable
    inline uint32_t PIO0_SM2_EXECCTRL_OUT_EN_SEL (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

  // Field JMP_PIN: The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
    inline uint32_t PIO0_SM2_EXECCTRL_JMP_PIN (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

  // Field SIDE_PINDIR: Side-set data is asserted to pin OEs instead of pin values
    const uint32_t PIO0_SM2_EXECCTRL_SIDE_PINDIR = 1U << 29 ;

  // Field SIDE_EN: If 1, the delay MSB is used as side-set enable, rather than a\n side-set data bit. This allows instructions to perform side-set optionally,\n rather than on every instruction.
    const uint32_t PIO0_SM2_EXECCTRL_SIDE_EN = 1U << 30 ;

  // Field EXEC_STALLED: An instruction written to SMx_INSTR is stalled, and latched by the\n state machine. Will clear once the instruction completes.
    const uint32_t PIO0_SM2_EXECCTRL_EXEC_STALLED = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register SM2_SHIFTCTRL: Control behaviour of the input/output shift registers for state machine 2
  static volatile uint32_t & PIO0_SM2_SHIFTCTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 256)) ;

  // Field AUTOPUSH: Push automatically when the input shift register is filled
    const uint32_t PIO0_SM2_SHIFTCTRL_AUTOPUSH = 1U << 16 ;

  // Field AUTOPULL: Pull automatically when the output shift register is emptied
    const uint32_t PIO0_SM2_SHIFTCTRL_AUTOPULL = 1U << 17 ;

  // Field IN_SHIFTDIR: 1 = shift input shift register to right (data enters from left). 0 = to left.
    const uint32_t PIO0_SM2_SHIFTCTRL_IN_SHIFTDIR = 1U << 18 ;

  // Field OUT_SHIFTDIR: 1 = shift out of output shift register to right. 0 = to left.
    const uint32_t PIO0_SM2_SHIFTCTRL_OUT_SHIFTDIR = 1U << 19 ;

  // Field PUSH_THRESH: Number of bits shifted into RXSR before autopush or conditional push.\n Write 0 for value of 32.
    inline uint32_t PIO0_SM2_SHIFTCTRL_PUSH_THRESH (const uint32_t inValue) {return (inValue & 0x1FU) << 20 ; }

  // Field PULL_THRESH: Number of bits shifted out of TXSR before autopull or conditional pull.\n Write 0 for value of 32.
    inline uint32_t PIO0_SM2_SHIFTCTRL_PULL_THRESH (const uint32_t inValue) {return (inValue & 0x1FU) << 25 ; }

  // Field FJOIN_TX: When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep.\n RX FIFO is disabled as a result (always reads as both full and empty).\n FIFOs are flushed when this bit is changed.
    const uint32_t PIO0_SM2_SHIFTCTRL_FJOIN_TX = 1U << 30 ;

  // Field FJOIN_RX: When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep.\n TX FIFO is disabled as a result (always reads as both full and empty).\n FIFOs are flushed when this bit is changed.
    const uint32_t PIO0_SM2_SHIFTCTRL_FJOIN_RX = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register SM2_ADDR: Current instruction address of state machine 2
  static volatile uint32_t & PIO0_SM2_ADDR __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 260)) ;

  // Field SM2_ADDR: 
    inline uint32_t PIO0_SM2_ADDR_SM2_ADDR (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SM2_INSTR: Instruction currently being executed by state machine 2\n Write to execute an instruction immediately (including jumps) and then resume execution.
  static volatile uint32_t & PIO0_SM2_INSTR __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 264)) ;

  // Field SM2_INSTR: 
    inline uint32_t PIO0_SM2_INSTR_SM2_INSTR (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SM2_PINCTRL: State machine pin control
  static volatile uint32_t & PIO0_SM2_PINCTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 268)) ;

  // Field OUT_BASE: The virtual pin corresponding to OUT bit 0
    inline uint32_t PIO0_SM2_PINCTRL_OUT_BASE (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field SET_BASE: The virtual pin corresponding to SET bit 0
    inline uint32_t PIO0_SM2_PINCTRL_SET_BASE (const uint32_t inValue) {return (inValue & 0x1FU) << 5 ; }

  // Field SIDESET_BASE: The virtual pin corresponding to delay field bit 0
    inline uint32_t PIO0_SM2_PINCTRL_SIDESET_BASE (const uint32_t inValue) {return (inValue & 0x1FU) << 10 ; }

  // Field IN_BASE: The virtual pin corresponding to IN bit 0
    inline uint32_t PIO0_SM2_PINCTRL_IN_BASE (const uint32_t inValue) {return (inValue & 0x1FU) << 15 ; }

  // Field OUT_COUNT: The number of pins asserted by an OUT. Value of 0 -> 32 pins
    inline uint32_t PIO0_SM2_PINCTRL_OUT_COUNT (const uint32_t inValue) {return (inValue & 0x3FU) << 20 ; }

  // Field SET_COUNT: The number of pins asserted by a SET. Max of 5
    inline uint32_t PIO0_SM2_PINCTRL_SET_COUNT (const uint32_t inValue) {return (inValue & 0x7U) << 26 ; }

  // Field SIDESET_COUNT: The number of delay bits co-opted for side-set. Inclusive of the enable bit, if present.
    inline uint32_t PIO0_SM2_PINCTRL_SIDESET_COUNT (const uint32_t inValue) {return (inValue & 0x7U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register SM3_CLKDIV: Clock divider register for state machine 3\n Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
  static volatile uint32_t & PIO0_SM3_CLKDIV __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 272)) ;

  // Field FRAC: Fractional part of clock divider
    inline uint32_t PIO0_SM3_CLKDIV_FRAC (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field INT: Effective frequency is sysclk/int.\n Value of 0 is interpreted as max possible value
    inline uint32_t PIO0_SM3_CLKDIV_INT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register SM3_EXECCTRL: Execution/behavioural settings for state machine 3
  static volatile uint32_t & PIO0_SM3_EXECCTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 276)) ;

  // Field STATUS_N: Comparison level for the MOV x, STATUS instruction
    inline uint32_t PIO0_SM3_EXECCTRL_STATUS_N (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field STATUS_SEL: Comparison used for the MOV x, STATUS instruction.
    const uint32_t PIO0_SM3_EXECCTRL_STATUS_SEL = 1U << 4 ;

  // Field WRAP_BOTTOM: After reaching wrap_top, execution is wrapped to this address.
    inline uint32_t PIO0_SM3_EXECCTRL_WRAP_BOTTOM (const uint32_t inValue) {return (inValue & 0x1FU) << 7 ; }

  // Field WRAP_TOP: After reaching this address, execution is wrapped to wrap_bottom.\n If the instruction is a jump, and the jump condition is true, the jump takes priority.
    inline uint32_t PIO0_SM3_EXECCTRL_WRAP_TOP (const uint32_t inValue) {return (inValue & 0x1FU) << 12 ; }

  // Field OUT_STICKY: Continuously assert the most recent OUT/SET to the pins
    const uint32_t PIO0_SM3_EXECCTRL_OUT_STICKY = 1U << 17 ;

  // Field INLINE_OUT_EN: If 1, use a bit of OUT data as an auxiliary write enable\n When used in conjunction with OUT_STICKY, writes with an enable of 0 will\n deassert the latest pin write. This can create useful masking/override behaviour\n due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)
    const uint32_t PIO0_SM3_EXECCTRL_INLINE_OUT_EN = 1U << 18 ;

  // Field OUT_EN_SEL: Which data bit to use for inline OUT enable
    inline uint32_t PIO0_SM3_EXECCTRL_OUT_EN_SEL (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

  // Field JMP_PIN: The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
    inline uint32_t PIO0_SM3_EXECCTRL_JMP_PIN (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

  // Field SIDE_PINDIR: Side-set data is asserted to pin OEs instead of pin values
    const uint32_t PIO0_SM3_EXECCTRL_SIDE_PINDIR = 1U << 29 ;

  // Field SIDE_EN: If 1, the delay MSB is used as side-set enable, rather than a\n side-set data bit. This allows instructions to perform side-set optionally,\n rather than on every instruction.
    const uint32_t PIO0_SM3_EXECCTRL_SIDE_EN = 1U << 30 ;

  // Field EXEC_STALLED: An instruction written to SMx_INSTR is stalled, and latched by the\n state machine. Will clear once the instruction completes.
    const uint32_t PIO0_SM3_EXECCTRL_EXEC_STALLED = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register SM3_SHIFTCTRL: Control behaviour of the input/output shift registers for state machine 3
  static volatile uint32_t & PIO0_SM3_SHIFTCTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 280)) ;

  // Field AUTOPUSH: Push automatically when the input shift register is filled
    const uint32_t PIO0_SM3_SHIFTCTRL_AUTOPUSH = 1U << 16 ;

  // Field AUTOPULL: Pull automatically when the output shift register is emptied
    const uint32_t PIO0_SM3_SHIFTCTRL_AUTOPULL = 1U << 17 ;

  // Field IN_SHIFTDIR: 1 = shift input shift register to right (data enters from left). 0 = to left.
    const uint32_t PIO0_SM3_SHIFTCTRL_IN_SHIFTDIR = 1U << 18 ;

  // Field OUT_SHIFTDIR: 1 = shift out of output shift register to right. 0 = to left.
    const uint32_t PIO0_SM3_SHIFTCTRL_OUT_SHIFTDIR = 1U << 19 ;

  // Field PUSH_THRESH: Number of bits shifted into RXSR before autopush or conditional push.\n Write 0 for value of 32.
    inline uint32_t PIO0_SM3_SHIFTCTRL_PUSH_THRESH (const uint32_t inValue) {return (inValue & 0x1FU) << 20 ; }

  // Field PULL_THRESH: Number of bits shifted out of TXSR before autopull or conditional pull.\n Write 0 for value of 32.
    inline uint32_t PIO0_SM3_SHIFTCTRL_PULL_THRESH (const uint32_t inValue) {return (inValue & 0x1FU) << 25 ; }

  // Field FJOIN_TX: When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep.\n RX FIFO is disabled as a result (always reads as both full and empty).\n FIFOs are flushed when this bit is changed.
    const uint32_t PIO0_SM3_SHIFTCTRL_FJOIN_TX = 1U << 30 ;

  // Field FJOIN_RX: When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep.\n TX FIFO is disabled as a result (always reads as both full and empty).\n FIFOs are flushed when this bit is changed.
    const uint32_t PIO0_SM3_SHIFTCTRL_FJOIN_RX = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register SM3_ADDR: Current instruction address of state machine 3
  static volatile uint32_t & PIO0_SM3_ADDR __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 284)) ;

  // Field SM3_ADDR: 
    inline uint32_t PIO0_SM3_ADDR_SM3_ADDR (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SM3_INSTR: Instruction currently being executed by state machine 3\n Write to execute an instruction immediately (including jumps) and then resume execution.
  static volatile uint32_t & PIO0_SM3_INSTR __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 288)) ;

  // Field SM3_INSTR: 
    inline uint32_t PIO0_SM3_INSTR_SM3_INSTR (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SM3_PINCTRL: State machine pin control
  static volatile uint32_t & PIO0_SM3_PINCTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 292)) ;

  // Field OUT_BASE: The virtual pin corresponding to OUT bit 0
    inline uint32_t PIO0_SM3_PINCTRL_OUT_BASE (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field SET_BASE: The virtual pin corresponding to SET bit 0
    inline uint32_t PIO0_SM3_PINCTRL_SET_BASE (const uint32_t inValue) {return (inValue & 0x1FU) << 5 ; }

  // Field SIDESET_BASE: The virtual pin corresponding to delay field bit 0
    inline uint32_t PIO0_SM3_PINCTRL_SIDESET_BASE (const uint32_t inValue) {return (inValue & 0x1FU) << 10 ; }

  // Field IN_BASE: The virtual pin corresponding to IN bit 0
    inline uint32_t PIO0_SM3_PINCTRL_IN_BASE (const uint32_t inValue) {return (inValue & 0x1FU) << 15 ; }

  // Field OUT_COUNT: The number of pins asserted by an OUT. Value of 0 -> 32 pins
    inline uint32_t PIO0_SM3_PINCTRL_OUT_COUNT (const uint32_t inValue) {return (inValue & 0x3FU) << 20 ; }

  // Field SET_COUNT: The number of pins asserted by a SET. Max of 5
    inline uint32_t PIO0_SM3_PINCTRL_SET_COUNT (const uint32_t inValue) {return (inValue & 0x7U) << 26 ; }

  // Field SIDESET_COUNT: The number of delay bits co-opted for side-set. Inclusive of the enable bit, if present.
    inline uint32_t PIO0_SM3_PINCTRL_SIDESET_COUNT (const uint32_t inValue) {return (inValue & 0x7U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register INTR: Raw Interrupts
  static volatile uint32_t & PIO0_INTR __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 296)) ;

  // Field SM0_RXNEMPTY: 
    const uint32_t PIO0_INTR_SM0_RXNEMPTY = 1U << 0 ;

  // Field SM1_RXNEMPTY: 
    const uint32_t PIO0_INTR_SM1_RXNEMPTY = 1U << 1 ;

  // Field SM2_RXNEMPTY: 
    const uint32_t PIO0_INTR_SM2_RXNEMPTY = 1U << 2 ;

  // Field SM3_RXNEMPTY: 
    const uint32_t PIO0_INTR_SM3_RXNEMPTY = 1U << 3 ;

  // Field SM0_TXNFULL: 
    const uint32_t PIO0_INTR_SM0_TXNFULL = 1U << 4 ;

  // Field SM1_TXNFULL: 
    const uint32_t PIO0_INTR_SM1_TXNFULL = 1U << 5 ;

  // Field SM2_TXNFULL: 
    const uint32_t PIO0_INTR_SM2_TXNFULL = 1U << 6 ;

  // Field SM3_TXNFULL: 
    const uint32_t PIO0_INTR_SM3_TXNFULL = 1U << 7 ;

  // Field SM0: 
    const uint32_t PIO0_INTR_SM0 = 1U << 8 ;

  // Field SM1: 
    const uint32_t PIO0_INTR_SM1 = 1U << 9 ;

  // Field SM2: 
    const uint32_t PIO0_INTR_SM2 = 1U << 10 ;

  // Field SM3: 
    const uint32_t PIO0_INTR_SM3 = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register IRQ0_INTE: Interrupt Enable for irq0
  static volatile uint32_t & PIO0_IRQ0_INTE __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 300)) ;

  // Field SM0_RXNEMPTY: 
    const uint32_t PIO0_IRQ0_INTE_SM0_RXNEMPTY = 1U << 0 ;

  // Field SM1_RXNEMPTY: 
    const uint32_t PIO0_IRQ0_INTE_SM1_RXNEMPTY = 1U << 1 ;

  // Field SM2_RXNEMPTY: 
    const uint32_t PIO0_IRQ0_INTE_SM2_RXNEMPTY = 1U << 2 ;

  // Field SM3_RXNEMPTY: 
    const uint32_t PIO0_IRQ0_INTE_SM3_RXNEMPTY = 1U << 3 ;

  // Field SM0_TXNFULL: 
    const uint32_t PIO0_IRQ0_INTE_SM0_TXNFULL = 1U << 4 ;

  // Field SM1_TXNFULL: 
    const uint32_t PIO0_IRQ0_INTE_SM1_TXNFULL = 1U << 5 ;

  // Field SM2_TXNFULL: 
    const uint32_t PIO0_IRQ0_INTE_SM2_TXNFULL = 1U << 6 ;

  // Field SM3_TXNFULL: 
    const uint32_t PIO0_IRQ0_INTE_SM3_TXNFULL = 1U << 7 ;

  // Field SM0: 
    const uint32_t PIO0_IRQ0_INTE_SM0 = 1U << 8 ;

  // Field SM1: 
    const uint32_t PIO0_IRQ0_INTE_SM1 = 1U << 9 ;

  // Field SM2: 
    const uint32_t PIO0_IRQ0_INTE_SM2 = 1U << 10 ;

  // Field SM3: 
    const uint32_t PIO0_IRQ0_INTE_SM3 = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register IRQ0_INTF: Interrupt Force for irq0
  static volatile uint32_t & PIO0_IRQ0_INTF __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 304)) ;

  // Field SM0_RXNEMPTY: 
    const uint32_t PIO0_IRQ0_INTF_SM0_RXNEMPTY = 1U << 0 ;

  // Field SM1_RXNEMPTY: 
    const uint32_t PIO0_IRQ0_INTF_SM1_RXNEMPTY = 1U << 1 ;

  // Field SM2_RXNEMPTY: 
    const uint32_t PIO0_IRQ0_INTF_SM2_RXNEMPTY = 1U << 2 ;

  // Field SM3_RXNEMPTY: 
    const uint32_t PIO0_IRQ0_INTF_SM3_RXNEMPTY = 1U << 3 ;

  // Field SM0_TXNFULL: 
    const uint32_t PIO0_IRQ0_INTF_SM0_TXNFULL = 1U << 4 ;

  // Field SM1_TXNFULL: 
    const uint32_t PIO0_IRQ0_INTF_SM1_TXNFULL = 1U << 5 ;

  // Field SM2_TXNFULL: 
    const uint32_t PIO0_IRQ0_INTF_SM2_TXNFULL = 1U << 6 ;

  // Field SM3_TXNFULL: 
    const uint32_t PIO0_IRQ0_INTF_SM3_TXNFULL = 1U << 7 ;

  // Field SM0: 
    const uint32_t PIO0_IRQ0_INTF_SM0 = 1U << 8 ;

  // Field SM1: 
    const uint32_t PIO0_IRQ0_INTF_SM1 = 1U << 9 ;

  // Field SM2: 
    const uint32_t PIO0_IRQ0_INTF_SM2 = 1U << 10 ;

  // Field SM3: 
    const uint32_t PIO0_IRQ0_INTF_SM3 = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register IRQ0_INTS: Interrupt status after masking & forcing for irq0
  static volatile uint32_t & PIO0_IRQ0_INTS __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 308)) ;

  // Field SM0_RXNEMPTY: 
    const uint32_t PIO0_IRQ0_INTS_SM0_RXNEMPTY = 1U << 0 ;

  // Field SM1_RXNEMPTY: 
    const uint32_t PIO0_IRQ0_INTS_SM1_RXNEMPTY = 1U << 1 ;

  // Field SM2_RXNEMPTY: 
    const uint32_t PIO0_IRQ0_INTS_SM2_RXNEMPTY = 1U << 2 ;

  // Field SM3_RXNEMPTY: 
    const uint32_t PIO0_IRQ0_INTS_SM3_RXNEMPTY = 1U << 3 ;

  // Field SM0_TXNFULL: 
    const uint32_t PIO0_IRQ0_INTS_SM0_TXNFULL = 1U << 4 ;

  // Field SM1_TXNFULL: 
    const uint32_t PIO0_IRQ0_INTS_SM1_TXNFULL = 1U << 5 ;

  // Field SM2_TXNFULL: 
    const uint32_t PIO0_IRQ0_INTS_SM2_TXNFULL = 1U << 6 ;

  // Field SM3_TXNFULL: 
    const uint32_t PIO0_IRQ0_INTS_SM3_TXNFULL = 1U << 7 ;

  // Field SM0: 
    const uint32_t PIO0_IRQ0_INTS_SM0 = 1U << 8 ;

  // Field SM1: 
    const uint32_t PIO0_IRQ0_INTS_SM1 = 1U << 9 ;

  // Field SM2: 
    const uint32_t PIO0_IRQ0_INTS_SM2 = 1U << 10 ;

  // Field SM3: 
    const uint32_t PIO0_IRQ0_INTS_SM3 = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register IRQ1_INTE: Interrupt Enable for irq1
  static volatile uint32_t & PIO0_IRQ1_INTE __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 312)) ;

  // Field SM0_RXNEMPTY: 
    const uint32_t PIO0_IRQ1_INTE_SM0_RXNEMPTY = 1U << 0 ;

  // Field SM1_RXNEMPTY: 
    const uint32_t PIO0_IRQ1_INTE_SM1_RXNEMPTY = 1U << 1 ;

  // Field SM2_RXNEMPTY: 
    const uint32_t PIO0_IRQ1_INTE_SM2_RXNEMPTY = 1U << 2 ;

  // Field SM3_RXNEMPTY: 
    const uint32_t PIO0_IRQ1_INTE_SM3_RXNEMPTY = 1U << 3 ;

  // Field SM0_TXNFULL: 
    const uint32_t PIO0_IRQ1_INTE_SM0_TXNFULL = 1U << 4 ;

  // Field SM1_TXNFULL: 
    const uint32_t PIO0_IRQ1_INTE_SM1_TXNFULL = 1U << 5 ;

  // Field SM2_TXNFULL: 
    const uint32_t PIO0_IRQ1_INTE_SM2_TXNFULL = 1U << 6 ;

  // Field SM3_TXNFULL: 
    const uint32_t PIO0_IRQ1_INTE_SM3_TXNFULL = 1U << 7 ;

  // Field SM0: 
    const uint32_t PIO0_IRQ1_INTE_SM0 = 1U << 8 ;

  // Field SM1: 
    const uint32_t PIO0_IRQ1_INTE_SM1 = 1U << 9 ;

  // Field SM2: 
    const uint32_t PIO0_IRQ1_INTE_SM2 = 1U << 10 ;

  // Field SM3: 
    const uint32_t PIO0_IRQ1_INTE_SM3 = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register IRQ1_INTF: Interrupt Force for irq1
  static volatile uint32_t & PIO0_IRQ1_INTF __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 316)) ;

  // Field SM0_RXNEMPTY: 
    const uint32_t PIO0_IRQ1_INTF_SM0_RXNEMPTY = 1U << 0 ;

  // Field SM1_RXNEMPTY: 
    const uint32_t PIO0_IRQ1_INTF_SM1_RXNEMPTY = 1U << 1 ;

  // Field SM2_RXNEMPTY: 
    const uint32_t PIO0_IRQ1_INTF_SM2_RXNEMPTY = 1U << 2 ;

  // Field SM3_RXNEMPTY: 
    const uint32_t PIO0_IRQ1_INTF_SM3_RXNEMPTY = 1U << 3 ;

  // Field SM0_TXNFULL: 
    const uint32_t PIO0_IRQ1_INTF_SM0_TXNFULL = 1U << 4 ;

  // Field SM1_TXNFULL: 
    const uint32_t PIO0_IRQ1_INTF_SM1_TXNFULL = 1U << 5 ;

  // Field SM2_TXNFULL: 
    const uint32_t PIO0_IRQ1_INTF_SM2_TXNFULL = 1U << 6 ;

  // Field SM3_TXNFULL: 
    const uint32_t PIO0_IRQ1_INTF_SM3_TXNFULL = 1U << 7 ;

  // Field SM0: 
    const uint32_t PIO0_IRQ1_INTF_SM0 = 1U << 8 ;

  // Field SM1: 
    const uint32_t PIO0_IRQ1_INTF_SM1 = 1U << 9 ;

  // Field SM2: 
    const uint32_t PIO0_IRQ1_INTF_SM2 = 1U << 10 ;

  // Field SM3: 
    const uint32_t PIO0_IRQ1_INTF_SM3 = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register IRQ1_INTS: Interrupt status after masking & forcing for irq1
  static volatile uint32_t & PIO0_IRQ1_INTS __attribute__((unused)) = * ((volatile uint32_t *) (0x50200000 + 320)) ;

  // Field SM0_RXNEMPTY: 
    const uint32_t PIO0_IRQ1_INTS_SM0_RXNEMPTY = 1U << 0 ;

  // Field SM1_RXNEMPTY: 
    const uint32_t PIO0_IRQ1_INTS_SM1_RXNEMPTY = 1U << 1 ;

  // Field SM2_RXNEMPTY: 
    const uint32_t PIO0_IRQ1_INTS_SM2_RXNEMPTY = 1U << 2 ;

  // Field SM3_RXNEMPTY: 
    const uint32_t PIO0_IRQ1_INTS_SM3_RXNEMPTY = 1U << 3 ;

  // Field SM0_TXNFULL: 
    const uint32_t PIO0_IRQ1_INTS_SM0_TXNFULL = 1U << 4 ;

  // Field SM1_TXNFULL: 
    const uint32_t PIO0_IRQ1_INTS_SM1_TXNFULL = 1U << 5 ;

  // Field SM2_TXNFULL: 
    const uint32_t PIO0_IRQ1_INTS_SM2_TXNFULL = 1U << 6 ;

  // Field SM3_TXNFULL: 
    const uint32_t PIO0_IRQ1_INTS_SM3_TXNFULL = 1U << 7 ;

  // Field SM0: 
    const uint32_t PIO0_IRQ1_INTS_SM0 = 1U << 8 ;

  // Field SM1: 
    const uint32_t PIO0_IRQ1_INTS_SM1 = 1U << 9 ;

  // Field SM2: 
    const uint32_t PIO0_IRQ1_INTS_SM2 = 1U << 10 ;

  // Field SM3: 
    const uint32_t PIO0_IRQ1_INTS_SM3 = 1U << 11 ;

//------------------------------------------------------------------------------
// Peripheral PIO1: 
//------------------------------------------------------------------------------

//---  Register CTRL: PIO control register
  static volatile uint32_t & PIO1_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 0)) ;

  // Field SM_ENABLE: Enable state machine
    inline uint32_t PIO1_CTRL_SM_ENABLE (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field SM_RESTART: Clear internal SM state which is otherwise difficult to access\n (e.g. shift counters). Self-clearing.
    inline uint32_t PIO1_CTRL_SM_RESTART (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field CLKDIV_RESTART: Force clock dividers to restart their count and clear fractional\n accumulators. Restart multiple dividers to synchronise them.
    inline uint32_t PIO1_CTRL_CLKDIV_RESTART (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register FSTAT: FIFO status register
  static volatile uint32_t & PIO1_FSTAT __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 4)) ;

  // Field RXFULL: State machine RX FIFO is full
    inline uint32_t PIO1_FSTAT_RXFULL (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field RXEMPTY: State machine RX FIFO is empty
    inline uint32_t PIO1_FSTAT_RXEMPTY (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field TXFULL: State machine TX FIFO is full
    inline uint32_t PIO1_FSTAT_TXFULL (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field TXEMPTY: State machine TX FIFO is empty
    inline uint32_t PIO1_FSTAT_TXEMPTY (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register FDEBUG: FIFO debug register
  static volatile uint32_t & PIO1_FDEBUG __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 8)) ;

  // Field RXSTALL: State machine has stalled on full RX FIFO. Write 1 to clear.
    inline uint32_t PIO1_FDEBUG_RXSTALL (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field RXUNDER: RX FIFO underflow has occurred. Write 1 to clear.
    inline uint32_t PIO1_FDEBUG_RXUNDER (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field TXOVER: TX FIFO overflow has occurred. Write 1 to clear.
    inline uint32_t PIO1_FDEBUG_TXOVER (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field TXSTALL: State machine has stalled on empty TX FIFO. Write 1 to clear.
    inline uint32_t PIO1_FDEBUG_TXSTALL (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register FLEVEL: FIFO levels
  static volatile uint32_t & PIO1_FLEVEL __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 12)) ;

  // Field TX0: 
    inline uint32_t PIO1_FLEVEL_TX0 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field RX0: 
    inline uint32_t PIO1_FLEVEL_RX0 (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field TX1: 
    inline uint32_t PIO1_FLEVEL_TX1 (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field RX1: 
    inline uint32_t PIO1_FLEVEL_RX1 (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field TX2: 
    inline uint32_t PIO1_FLEVEL_TX2 (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field RX2: 
    inline uint32_t PIO1_FLEVEL_RX2 (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field TX3: 
    inline uint32_t PIO1_FLEVEL_TX3 (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field RX3: 
    inline uint32_t PIO1_FLEVEL_RX3 (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

//------------------------------------------------------------------------------

//---  Register TXF0: Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO.
  static volatile uint32_t & PIO1_TXF0 __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 16)) ;

//------------------------------------------------------------------------------

//---  Register TXF1: Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO.
  static volatile uint32_t & PIO1_TXF1 __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 20)) ;

//------------------------------------------------------------------------------

//---  Register TXF2: Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO.
  static volatile uint32_t & PIO1_TXF2 __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 24)) ;

//------------------------------------------------------------------------------

//---  Register TXF3: Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO.
  static volatile uint32_t & PIO1_TXF3 __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 28)) ;

//------------------------------------------------------------------------------

//---  Register RXF0: Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO.
  static volatile uint32_t const & PIO1_RXF0 __attribute__((unused)) = * ((const volatile uint32_t *) (0x50300000 + 32)) ;

//------------------------------------------------------------------------------

//---  Register RXF1: Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO.
  static volatile uint32_t const & PIO1_RXF1 __attribute__((unused)) = * ((const volatile uint32_t *) (0x50300000 + 36)) ;

//------------------------------------------------------------------------------

//---  Register RXF2: Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO.
  static volatile uint32_t const & PIO1_RXF2 __attribute__((unused)) = * ((const volatile uint32_t *) (0x50300000 + 40)) ;

//------------------------------------------------------------------------------

//---  Register RXF3: Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO.
  static volatile uint32_t const & PIO1_RXF3 __attribute__((unused)) = * ((const volatile uint32_t *) (0x50300000 + 44)) ;

//------------------------------------------------------------------------------

//---  Register IRQ: Interrupt request register. Write 1 to clear
  static volatile uint32_t & PIO1_IRQ __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 48)) ;

  // Field IRQ: 
    inline uint32_t PIO1_IRQ_IRQ (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IRQ_FORCE: Writing a 1 to each of these bits will forcibly assert the corresponding IRQ.\n Note this is different to the INTF register: writing here affects PIO internal\n state. INTF just asserts the processor-facing IRQ signal for testing ISRs,\n and is not visible to the state machines.
  static volatile uint32_t & PIO1_IRQ_FORCE __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 52)) ;

  // Field IRQ_FORCE: 
    inline uint32_t PIO1_IRQ_FORCE_IRQ_FORCE (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INPUT_SYNC_BYPASS: There is a 2-flipflop synchronizer on each GPIO input, which protects\n PIO logic from metastabilities. This increases input delay, and for fast\n synchronous IO (e.g. SPI) these synchronizers may need to be bypassed.\n Each bit in this register corresponds to one GPIO.\n 0 -> input is synchronized (default)\n 1 -> synchronizer is bypassed\n If in doubt, leave this register as all zeroes.
  static volatile uint32_t & PIO1_INPUT_SYNC_BYPASS __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 56)) ;

//------------------------------------------------------------------------------

//---  Register DBG_PADOUT: Read to sample the pad output values PIO is currently driving to the GPIOs.
  static volatile uint32_t const & PIO1_DBG_PADOUT __attribute__((unused)) = * ((const volatile uint32_t *) (0x50300000 + 60)) ;

//------------------------------------------------------------------------------

//---  Register DBG_PADOE: Read to sample the pad output enables (direction) PIO is currently driving to the GPIOs.
  static volatile uint32_t const & PIO1_DBG_PADOE __attribute__((unused)) = * ((const volatile uint32_t *) (0x50300000 + 64)) ;

//------------------------------------------------------------------------------

//---  Register DBG_CFGINFO: The PIO hardware has some free parameters that may vary between chip products.\n These should be provided in the chip datasheet, but are also exposed here.
  static volatile uint32_t & PIO1_DBG_CFGINFO __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 68)) ;

  // Field FIFO_DEPTH: The depth of the state machine TX/RX FIFOs, measured in words.\n Joining fifos via SHIFTCTRL_FJOIN gives one FIFO with double\n this depth.
    inline uint32_t PIO1_DBG_CFGINFO_FIFO_DEPTH (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

  // Field SM_COUNT: The number of state machines this PIO instance is equipped with.
    inline uint32_t PIO1_DBG_CFGINFO_SM_COUNT (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field IMEM_SIZE: The size of the instruction memory, measured in units of one instruction
    inline uint32_t PIO1_DBG_CFGINFO_IMEM_SIZE (const uint32_t inValue) {return (inValue & 0x3FU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM0: Write-only access to instruction memory location 0
  static volatile uint32_t & PIO1_INSTR_MEM0 __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 72)) ;

  // Field INSTR_MEM0: 
    inline uint32_t PIO1_INSTR_MEM0_INSTR_MEM0 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM1: Write-only access to instruction memory location 1
  static volatile uint32_t & PIO1_INSTR_MEM1 __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 76)) ;

  // Field INSTR_MEM1: 
    inline uint32_t PIO1_INSTR_MEM1_INSTR_MEM1 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM2: Write-only access to instruction memory location 2
  static volatile uint32_t & PIO1_INSTR_MEM2 __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 80)) ;

  // Field INSTR_MEM2: 
    inline uint32_t PIO1_INSTR_MEM2_INSTR_MEM2 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM3: Write-only access to instruction memory location 3
  static volatile uint32_t & PIO1_INSTR_MEM3 __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 84)) ;

  // Field INSTR_MEM3: 
    inline uint32_t PIO1_INSTR_MEM3_INSTR_MEM3 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM4: Write-only access to instruction memory location 4
  static volatile uint32_t & PIO1_INSTR_MEM4 __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 88)) ;

  // Field INSTR_MEM4: 
    inline uint32_t PIO1_INSTR_MEM4_INSTR_MEM4 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM5: Write-only access to instruction memory location 5
  static volatile uint32_t & PIO1_INSTR_MEM5 __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 92)) ;

  // Field INSTR_MEM5: 
    inline uint32_t PIO1_INSTR_MEM5_INSTR_MEM5 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM6: Write-only access to instruction memory location 6
  static volatile uint32_t & PIO1_INSTR_MEM6 __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 96)) ;

  // Field INSTR_MEM6: 
    inline uint32_t PIO1_INSTR_MEM6_INSTR_MEM6 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM7: Write-only access to instruction memory location 7
  static volatile uint32_t & PIO1_INSTR_MEM7 __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 100)) ;

  // Field INSTR_MEM7: 
    inline uint32_t PIO1_INSTR_MEM7_INSTR_MEM7 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM8: Write-only access to instruction memory location 8
  static volatile uint32_t & PIO1_INSTR_MEM8 __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 104)) ;

  // Field INSTR_MEM8: 
    inline uint32_t PIO1_INSTR_MEM8_INSTR_MEM8 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM9: Write-only access to instruction memory location 9
  static volatile uint32_t & PIO1_INSTR_MEM9 __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 108)) ;

  // Field INSTR_MEM9: 
    inline uint32_t PIO1_INSTR_MEM9_INSTR_MEM9 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM10: Write-only access to instruction memory location 10
  static volatile uint32_t & PIO1_INSTR_MEM10 __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 112)) ;

  // Field INSTR_MEM10: 
    inline uint32_t PIO1_INSTR_MEM10_INSTR_MEM10 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM11: Write-only access to instruction memory location 11
  static volatile uint32_t & PIO1_INSTR_MEM11 __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 116)) ;

  // Field INSTR_MEM11: 
    inline uint32_t PIO1_INSTR_MEM11_INSTR_MEM11 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM12: Write-only access to instruction memory location 12
  static volatile uint32_t & PIO1_INSTR_MEM12 __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 120)) ;

  // Field INSTR_MEM12: 
    inline uint32_t PIO1_INSTR_MEM12_INSTR_MEM12 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM13: Write-only access to instruction memory location 13
  static volatile uint32_t & PIO1_INSTR_MEM13 __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 124)) ;

  // Field INSTR_MEM13: 
    inline uint32_t PIO1_INSTR_MEM13_INSTR_MEM13 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM14: Write-only access to instruction memory location 14
  static volatile uint32_t & PIO1_INSTR_MEM14 __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 128)) ;

  // Field INSTR_MEM14: 
    inline uint32_t PIO1_INSTR_MEM14_INSTR_MEM14 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM15: Write-only access to instruction memory location 15
  static volatile uint32_t & PIO1_INSTR_MEM15 __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 132)) ;

  // Field INSTR_MEM15: 
    inline uint32_t PIO1_INSTR_MEM15_INSTR_MEM15 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM16: Write-only access to instruction memory location 16
  static volatile uint32_t & PIO1_INSTR_MEM16 __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 136)) ;

  // Field INSTR_MEM16: 
    inline uint32_t PIO1_INSTR_MEM16_INSTR_MEM16 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM17: Write-only access to instruction memory location 17
  static volatile uint32_t & PIO1_INSTR_MEM17 __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 140)) ;

  // Field INSTR_MEM17: 
    inline uint32_t PIO1_INSTR_MEM17_INSTR_MEM17 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM18: Write-only access to instruction memory location 18
  static volatile uint32_t & PIO1_INSTR_MEM18 __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 144)) ;

  // Field INSTR_MEM18: 
    inline uint32_t PIO1_INSTR_MEM18_INSTR_MEM18 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM19: Write-only access to instruction memory location 19
  static volatile uint32_t & PIO1_INSTR_MEM19 __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 148)) ;

  // Field INSTR_MEM19: 
    inline uint32_t PIO1_INSTR_MEM19_INSTR_MEM19 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM20: Write-only access to instruction memory location 20
  static volatile uint32_t & PIO1_INSTR_MEM20 __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 152)) ;

  // Field INSTR_MEM20: 
    inline uint32_t PIO1_INSTR_MEM20_INSTR_MEM20 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM21: Write-only access to instruction memory location 21
  static volatile uint32_t & PIO1_INSTR_MEM21 __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 156)) ;

  // Field INSTR_MEM21: 
    inline uint32_t PIO1_INSTR_MEM21_INSTR_MEM21 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM22: Write-only access to instruction memory location 22
  static volatile uint32_t & PIO1_INSTR_MEM22 __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 160)) ;

  // Field INSTR_MEM22: 
    inline uint32_t PIO1_INSTR_MEM22_INSTR_MEM22 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM23: Write-only access to instruction memory location 23
  static volatile uint32_t & PIO1_INSTR_MEM23 __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 164)) ;

  // Field INSTR_MEM23: 
    inline uint32_t PIO1_INSTR_MEM23_INSTR_MEM23 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM24: Write-only access to instruction memory location 24
  static volatile uint32_t & PIO1_INSTR_MEM24 __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 168)) ;

  // Field INSTR_MEM24: 
    inline uint32_t PIO1_INSTR_MEM24_INSTR_MEM24 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM25: Write-only access to instruction memory location 25
  static volatile uint32_t & PIO1_INSTR_MEM25 __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 172)) ;

  // Field INSTR_MEM25: 
    inline uint32_t PIO1_INSTR_MEM25_INSTR_MEM25 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM26: Write-only access to instruction memory location 26
  static volatile uint32_t & PIO1_INSTR_MEM26 __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 176)) ;

  // Field INSTR_MEM26: 
    inline uint32_t PIO1_INSTR_MEM26_INSTR_MEM26 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM27: Write-only access to instruction memory location 27
  static volatile uint32_t & PIO1_INSTR_MEM27 __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 180)) ;

  // Field INSTR_MEM27: 
    inline uint32_t PIO1_INSTR_MEM27_INSTR_MEM27 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM28: Write-only access to instruction memory location 28
  static volatile uint32_t & PIO1_INSTR_MEM28 __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 184)) ;

  // Field INSTR_MEM28: 
    inline uint32_t PIO1_INSTR_MEM28_INSTR_MEM28 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM29: Write-only access to instruction memory location 29
  static volatile uint32_t & PIO1_INSTR_MEM29 __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 188)) ;

  // Field INSTR_MEM29: 
    inline uint32_t PIO1_INSTR_MEM29_INSTR_MEM29 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM30: Write-only access to instruction memory location 30
  static volatile uint32_t & PIO1_INSTR_MEM30 __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 192)) ;

  // Field INSTR_MEM30: 
    inline uint32_t PIO1_INSTR_MEM30_INSTR_MEM30 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INSTR_MEM31: Write-only access to instruction memory location 31
  static volatile uint32_t & PIO1_INSTR_MEM31 __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 196)) ;

  // Field INSTR_MEM31: 
    inline uint32_t PIO1_INSTR_MEM31_INSTR_MEM31 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SM0_CLKDIV: Clock divider register for state machine 0\n Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
  static volatile uint32_t & PIO1_SM0_CLKDIV __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 200)) ;

  // Field FRAC: Fractional part of clock divider
    inline uint32_t PIO1_SM0_CLKDIV_FRAC (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field INT: Effective frequency is sysclk/int.\n Value of 0 is interpreted as max possible value
    inline uint32_t PIO1_SM0_CLKDIV_INT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register SM0_EXECCTRL: Execution/behavioural settings for state machine 0
  static volatile uint32_t & PIO1_SM0_EXECCTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 204)) ;

  // Field STATUS_N: Comparison level for the MOV x, STATUS instruction
    inline uint32_t PIO1_SM0_EXECCTRL_STATUS_N (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field STATUS_SEL: Comparison used for the MOV x, STATUS instruction.
    const uint32_t PIO1_SM0_EXECCTRL_STATUS_SEL = 1U << 4 ;

  // Field WRAP_BOTTOM: After reaching wrap_top, execution is wrapped to this address.
    inline uint32_t PIO1_SM0_EXECCTRL_WRAP_BOTTOM (const uint32_t inValue) {return (inValue & 0x1FU) << 7 ; }

  // Field WRAP_TOP: After reaching this address, execution is wrapped to wrap_bottom.\n If the instruction is a jump, and the jump condition is true, the jump takes priority.
    inline uint32_t PIO1_SM0_EXECCTRL_WRAP_TOP (const uint32_t inValue) {return (inValue & 0x1FU) << 12 ; }

  // Field OUT_STICKY: Continuously assert the most recent OUT/SET to the pins
    const uint32_t PIO1_SM0_EXECCTRL_OUT_STICKY = 1U << 17 ;

  // Field INLINE_OUT_EN: If 1, use a bit of OUT data as an auxiliary write enable\n When used in conjunction with OUT_STICKY, writes with an enable of 0 will\n deassert the latest pin write. This can create useful masking/override behaviour\n due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)
    const uint32_t PIO1_SM0_EXECCTRL_INLINE_OUT_EN = 1U << 18 ;

  // Field OUT_EN_SEL: Which data bit to use for inline OUT enable
    inline uint32_t PIO1_SM0_EXECCTRL_OUT_EN_SEL (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

  // Field JMP_PIN: The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
    inline uint32_t PIO1_SM0_EXECCTRL_JMP_PIN (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

  // Field SIDE_PINDIR: Side-set data is asserted to pin OEs instead of pin values
    const uint32_t PIO1_SM0_EXECCTRL_SIDE_PINDIR = 1U << 29 ;

  // Field SIDE_EN: If 1, the delay MSB is used as side-set enable, rather than a\n side-set data bit. This allows instructions to perform side-set optionally,\n rather than on every instruction.
    const uint32_t PIO1_SM0_EXECCTRL_SIDE_EN = 1U << 30 ;

  // Field EXEC_STALLED: An instruction written to SMx_INSTR is stalled, and latched by the\n state machine. Will clear once the instruction completes.
    const uint32_t PIO1_SM0_EXECCTRL_EXEC_STALLED = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register SM0_SHIFTCTRL: Control behaviour of the input/output shift registers for state machine 0
  static volatile uint32_t & PIO1_SM0_SHIFTCTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 208)) ;

  // Field AUTOPUSH: Push automatically when the input shift register is filled
    const uint32_t PIO1_SM0_SHIFTCTRL_AUTOPUSH = 1U << 16 ;

  // Field AUTOPULL: Pull automatically when the output shift register is emptied
    const uint32_t PIO1_SM0_SHIFTCTRL_AUTOPULL = 1U << 17 ;

  // Field IN_SHIFTDIR: 1 = shift input shift register to right (data enters from left). 0 = to left.
    const uint32_t PIO1_SM0_SHIFTCTRL_IN_SHIFTDIR = 1U << 18 ;

  // Field OUT_SHIFTDIR: 1 = shift out of output shift register to right. 0 = to left.
    const uint32_t PIO1_SM0_SHIFTCTRL_OUT_SHIFTDIR = 1U << 19 ;

  // Field PUSH_THRESH: Number of bits shifted into RXSR before autopush or conditional push.\n Write 0 for value of 32.
    inline uint32_t PIO1_SM0_SHIFTCTRL_PUSH_THRESH (const uint32_t inValue) {return (inValue & 0x1FU) << 20 ; }

  // Field PULL_THRESH: Number of bits shifted out of TXSR before autopull or conditional pull.\n Write 0 for value of 32.
    inline uint32_t PIO1_SM0_SHIFTCTRL_PULL_THRESH (const uint32_t inValue) {return (inValue & 0x1FU) << 25 ; }

  // Field FJOIN_TX: When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep.\n RX FIFO is disabled as a result (always reads as both full and empty).\n FIFOs are flushed when this bit is changed.
    const uint32_t PIO1_SM0_SHIFTCTRL_FJOIN_TX = 1U << 30 ;

  // Field FJOIN_RX: When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep.\n TX FIFO is disabled as a result (always reads as both full and empty).\n FIFOs are flushed when this bit is changed.
    const uint32_t PIO1_SM0_SHIFTCTRL_FJOIN_RX = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register SM0_ADDR: Current instruction address of state machine 0
  static volatile uint32_t & PIO1_SM0_ADDR __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 212)) ;

  // Field SM0_ADDR: 
    inline uint32_t PIO1_SM0_ADDR_SM0_ADDR (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SM0_INSTR: Instruction currently being executed by state machine 0\n Write to execute an instruction immediately (including jumps) and then resume execution.
  static volatile uint32_t & PIO1_SM0_INSTR __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 216)) ;

  // Field SM0_INSTR: 
    inline uint32_t PIO1_SM0_INSTR_SM0_INSTR (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SM0_PINCTRL: State machine pin control
  static volatile uint32_t & PIO1_SM0_PINCTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 220)) ;

  // Field OUT_BASE: The virtual pin corresponding to OUT bit 0
    inline uint32_t PIO1_SM0_PINCTRL_OUT_BASE (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field SET_BASE: The virtual pin corresponding to SET bit 0
    inline uint32_t PIO1_SM0_PINCTRL_SET_BASE (const uint32_t inValue) {return (inValue & 0x1FU) << 5 ; }

  // Field SIDESET_BASE: The virtual pin corresponding to delay field bit 0
    inline uint32_t PIO1_SM0_PINCTRL_SIDESET_BASE (const uint32_t inValue) {return (inValue & 0x1FU) << 10 ; }

  // Field IN_BASE: The virtual pin corresponding to IN bit 0
    inline uint32_t PIO1_SM0_PINCTRL_IN_BASE (const uint32_t inValue) {return (inValue & 0x1FU) << 15 ; }

  // Field OUT_COUNT: The number of pins asserted by an OUT. Value of 0 -> 32 pins
    inline uint32_t PIO1_SM0_PINCTRL_OUT_COUNT (const uint32_t inValue) {return (inValue & 0x3FU) << 20 ; }

  // Field SET_COUNT: The number of pins asserted by a SET. Max of 5
    inline uint32_t PIO1_SM0_PINCTRL_SET_COUNT (const uint32_t inValue) {return (inValue & 0x7U) << 26 ; }

  // Field SIDESET_COUNT: The number of delay bits co-opted for side-set. Inclusive of the enable bit, if present.
    inline uint32_t PIO1_SM0_PINCTRL_SIDESET_COUNT (const uint32_t inValue) {return (inValue & 0x7U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register SM1_CLKDIV: Clock divider register for state machine 1\n Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
  static volatile uint32_t & PIO1_SM1_CLKDIV __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 224)) ;

  // Field FRAC: Fractional part of clock divider
    inline uint32_t PIO1_SM1_CLKDIV_FRAC (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field INT: Effective frequency is sysclk/int.\n Value of 0 is interpreted as max possible value
    inline uint32_t PIO1_SM1_CLKDIV_INT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register SM1_EXECCTRL: Execution/behavioural settings for state machine 1
  static volatile uint32_t & PIO1_SM1_EXECCTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 228)) ;

  // Field STATUS_N: Comparison level for the MOV x, STATUS instruction
    inline uint32_t PIO1_SM1_EXECCTRL_STATUS_N (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field STATUS_SEL: Comparison used for the MOV x, STATUS instruction.
    const uint32_t PIO1_SM1_EXECCTRL_STATUS_SEL = 1U << 4 ;

  // Field WRAP_BOTTOM: After reaching wrap_top, execution is wrapped to this address.
    inline uint32_t PIO1_SM1_EXECCTRL_WRAP_BOTTOM (const uint32_t inValue) {return (inValue & 0x1FU) << 7 ; }

  // Field WRAP_TOP: After reaching this address, execution is wrapped to wrap_bottom.\n If the instruction is a jump, and the jump condition is true, the jump takes priority.
    inline uint32_t PIO1_SM1_EXECCTRL_WRAP_TOP (const uint32_t inValue) {return (inValue & 0x1FU) << 12 ; }

  // Field OUT_STICKY: Continuously assert the most recent OUT/SET to the pins
    const uint32_t PIO1_SM1_EXECCTRL_OUT_STICKY = 1U << 17 ;

  // Field INLINE_OUT_EN: If 1, use a bit of OUT data as an auxiliary write enable\n When used in conjunction with OUT_STICKY, writes with an enable of 0 will\n deassert the latest pin write. This can create useful masking/override behaviour\n due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)
    const uint32_t PIO1_SM1_EXECCTRL_INLINE_OUT_EN = 1U << 18 ;

  // Field OUT_EN_SEL: Which data bit to use for inline OUT enable
    inline uint32_t PIO1_SM1_EXECCTRL_OUT_EN_SEL (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

  // Field JMP_PIN: The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
    inline uint32_t PIO1_SM1_EXECCTRL_JMP_PIN (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

  // Field SIDE_PINDIR: Side-set data is asserted to pin OEs instead of pin values
    const uint32_t PIO1_SM1_EXECCTRL_SIDE_PINDIR = 1U << 29 ;

  // Field SIDE_EN: If 1, the delay MSB is used as side-set enable, rather than a\n side-set data bit. This allows instructions to perform side-set optionally,\n rather than on every instruction.
    const uint32_t PIO1_SM1_EXECCTRL_SIDE_EN = 1U << 30 ;

  // Field EXEC_STALLED: An instruction written to SMx_INSTR is stalled, and latched by the\n state machine. Will clear once the instruction completes.
    const uint32_t PIO1_SM1_EXECCTRL_EXEC_STALLED = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register SM1_SHIFTCTRL: Control behaviour of the input/output shift registers for state machine 1
  static volatile uint32_t & PIO1_SM1_SHIFTCTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 232)) ;

  // Field AUTOPUSH: Push automatically when the input shift register is filled
    const uint32_t PIO1_SM1_SHIFTCTRL_AUTOPUSH = 1U << 16 ;

  // Field AUTOPULL: Pull automatically when the output shift register is emptied
    const uint32_t PIO1_SM1_SHIFTCTRL_AUTOPULL = 1U << 17 ;

  // Field IN_SHIFTDIR: 1 = shift input shift register to right (data enters from left). 0 = to left.
    const uint32_t PIO1_SM1_SHIFTCTRL_IN_SHIFTDIR = 1U << 18 ;

  // Field OUT_SHIFTDIR: 1 = shift out of output shift register to right. 0 = to left.
    const uint32_t PIO1_SM1_SHIFTCTRL_OUT_SHIFTDIR = 1U << 19 ;

  // Field PUSH_THRESH: Number of bits shifted into RXSR before autopush or conditional push.\n Write 0 for value of 32.
    inline uint32_t PIO1_SM1_SHIFTCTRL_PUSH_THRESH (const uint32_t inValue) {return (inValue & 0x1FU) << 20 ; }

  // Field PULL_THRESH: Number of bits shifted out of TXSR before autopull or conditional pull.\n Write 0 for value of 32.
    inline uint32_t PIO1_SM1_SHIFTCTRL_PULL_THRESH (const uint32_t inValue) {return (inValue & 0x1FU) << 25 ; }

  // Field FJOIN_TX: When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep.\n RX FIFO is disabled as a result (always reads as both full and empty).\n FIFOs are flushed when this bit is changed.
    const uint32_t PIO1_SM1_SHIFTCTRL_FJOIN_TX = 1U << 30 ;

  // Field FJOIN_RX: When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep.\n TX FIFO is disabled as a result (always reads as both full and empty).\n FIFOs are flushed when this bit is changed.
    const uint32_t PIO1_SM1_SHIFTCTRL_FJOIN_RX = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register SM1_ADDR: Current instruction address of state machine 1
  static volatile uint32_t & PIO1_SM1_ADDR __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 236)) ;

  // Field SM1_ADDR: 
    inline uint32_t PIO1_SM1_ADDR_SM1_ADDR (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SM1_INSTR: Instruction currently being executed by state machine 1\n Write to execute an instruction immediately (including jumps) and then resume execution.
  static volatile uint32_t & PIO1_SM1_INSTR __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 240)) ;

  // Field SM1_INSTR: 
    inline uint32_t PIO1_SM1_INSTR_SM1_INSTR (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SM1_PINCTRL: State machine pin control
  static volatile uint32_t & PIO1_SM1_PINCTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 244)) ;

  // Field OUT_BASE: The virtual pin corresponding to OUT bit 0
    inline uint32_t PIO1_SM1_PINCTRL_OUT_BASE (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field SET_BASE: The virtual pin corresponding to SET bit 0
    inline uint32_t PIO1_SM1_PINCTRL_SET_BASE (const uint32_t inValue) {return (inValue & 0x1FU) << 5 ; }

  // Field SIDESET_BASE: The virtual pin corresponding to delay field bit 0
    inline uint32_t PIO1_SM1_PINCTRL_SIDESET_BASE (const uint32_t inValue) {return (inValue & 0x1FU) << 10 ; }

  // Field IN_BASE: The virtual pin corresponding to IN bit 0
    inline uint32_t PIO1_SM1_PINCTRL_IN_BASE (const uint32_t inValue) {return (inValue & 0x1FU) << 15 ; }

  // Field OUT_COUNT: The number of pins asserted by an OUT. Value of 0 -> 32 pins
    inline uint32_t PIO1_SM1_PINCTRL_OUT_COUNT (const uint32_t inValue) {return (inValue & 0x3FU) << 20 ; }

  // Field SET_COUNT: The number of pins asserted by a SET. Max of 5
    inline uint32_t PIO1_SM1_PINCTRL_SET_COUNT (const uint32_t inValue) {return (inValue & 0x7U) << 26 ; }

  // Field SIDESET_COUNT: The number of delay bits co-opted for side-set. Inclusive of the enable bit, if present.
    inline uint32_t PIO1_SM1_PINCTRL_SIDESET_COUNT (const uint32_t inValue) {return (inValue & 0x7U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register SM2_CLKDIV: Clock divider register for state machine 2\n Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
  static volatile uint32_t & PIO1_SM2_CLKDIV __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 248)) ;

  // Field FRAC: Fractional part of clock divider
    inline uint32_t PIO1_SM2_CLKDIV_FRAC (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field INT: Effective frequency is sysclk/int.\n Value of 0 is interpreted as max possible value
    inline uint32_t PIO1_SM2_CLKDIV_INT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register SM2_EXECCTRL: Execution/behavioural settings for state machine 2
  static volatile uint32_t & PIO1_SM2_EXECCTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 252)) ;

  // Field STATUS_N: Comparison level for the MOV x, STATUS instruction
    inline uint32_t PIO1_SM2_EXECCTRL_STATUS_N (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field STATUS_SEL: Comparison used for the MOV x, STATUS instruction.
    const uint32_t PIO1_SM2_EXECCTRL_STATUS_SEL = 1U << 4 ;

  // Field WRAP_BOTTOM: After reaching wrap_top, execution is wrapped to this address.
    inline uint32_t PIO1_SM2_EXECCTRL_WRAP_BOTTOM (const uint32_t inValue) {return (inValue & 0x1FU) << 7 ; }

  // Field WRAP_TOP: After reaching this address, execution is wrapped to wrap_bottom.\n If the instruction is a jump, and the jump condition is true, the jump takes priority.
    inline uint32_t PIO1_SM2_EXECCTRL_WRAP_TOP (const uint32_t inValue) {return (inValue & 0x1FU) << 12 ; }

  // Field OUT_STICKY: Continuously assert the most recent OUT/SET to the pins
    const uint32_t PIO1_SM2_EXECCTRL_OUT_STICKY = 1U << 17 ;

  // Field INLINE_OUT_EN: If 1, use a bit of OUT data as an auxiliary write enable\n When used in conjunction with OUT_STICKY, writes with an enable of 0 will\n deassert the latest pin write. This can create useful masking/override behaviour\n due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)
    const uint32_t PIO1_SM2_EXECCTRL_INLINE_OUT_EN = 1U << 18 ;

  // Field OUT_EN_SEL: Which data bit to use for inline OUT enable
    inline uint32_t PIO1_SM2_EXECCTRL_OUT_EN_SEL (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

  // Field JMP_PIN: The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
    inline uint32_t PIO1_SM2_EXECCTRL_JMP_PIN (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

  // Field SIDE_PINDIR: Side-set data is asserted to pin OEs instead of pin values
    const uint32_t PIO1_SM2_EXECCTRL_SIDE_PINDIR = 1U << 29 ;

  // Field SIDE_EN: If 1, the delay MSB is used as side-set enable, rather than a\n side-set data bit. This allows instructions to perform side-set optionally,\n rather than on every instruction.
    const uint32_t PIO1_SM2_EXECCTRL_SIDE_EN = 1U << 30 ;

  // Field EXEC_STALLED: An instruction written to SMx_INSTR is stalled, and latched by the\n state machine. Will clear once the instruction completes.
    const uint32_t PIO1_SM2_EXECCTRL_EXEC_STALLED = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register SM2_SHIFTCTRL: Control behaviour of the input/output shift registers for state machine 2
  static volatile uint32_t & PIO1_SM2_SHIFTCTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 256)) ;

  // Field AUTOPUSH: Push automatically when the input shift register is filled
    const uint32_t PIO1_SM2_SHIFTCTRL_AUTOPUSH = 1U << 16 ;

  // Field AUTOPULL: Pull automatically when the output shift register is emptied
    const uint32_t PIO1_SM2_SHIFTCTRL_AUTOPULL = 1U << 17 ;

  // Field IN_SHIFTDIR: 1 = shift input shift register to right (data enters from left). 0 = to left.
    const uint32_t PIO1_SM2_SHIFTCTRL_IN_SHIFTDIR = 1U << 18 ;

  // Field OUT_SHIFTDIR: 1 = shift out of output shift register to right. 0 = to left.
    const uint32_t PIO1_SM2_SHIFTCTRL_OUT_SHIFTDIR = 1U << 19 ;

  // Field PUSH_THRESH: Number of bits shifted into RXSR before autopush or conditional push.\n Write 0 for value of 32.
    inline uint32_t PIO1_SM2_SHIFTCTRL_PUSH_THRESH (const uint32_t inValue) {return (inValue & 0x1FU) << 20 ; }

  // Field PULL_THRESH: Number of bits shifted out of TXSR before autopull or conditional pull.\n Write 0 for value of 32.
    inline uint32_t PIO1_SM2_SHIFTCTRL_PULL_THRESH (const uint32_t inValue) {return (inValue & 0x1FU) << 25 ; }

  // Field FJOIN_TX: When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep.\n RX FIFO is disabled as a result (always reads as both full and empty).\n FIFOs are flushed when this bit is changed.
    const uint32_t PIO1_SM2_SHIFTCTRL_FJOIN_TX = 1U << 30 ;

  // Field FJOIN_RX: When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep.\n TX FIFO is disabled as a result (always reads as both full and empty).\n FIFOs are flushed when this bit is changed.
    const uint32_t PIO1_SM2_SHIFTCTRL_FJOIN_RX = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register SM2_ADDR: Current instruction address of state machine 2
  static volatile uint32_t & PIO1_SM2_ADDR __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 260)) ;

  // Field SM2_ADDR: 
    inline uint32_t PIO1_SM2_ADDR_SM2_ADDR (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SM2_INSTR: Instruction currently being executed by state machine 2\n Write to execute an instruction immediately (including jumps) and then resume execution.
  static volatile uint32_t & PIO1_SM2_INSTR __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 264)) ;

  // Field SM2_INSTR: 
    inline uint32_t PIO1_SM2_INSTR_SM2_INSTR (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SM2_PINCTRL: State machine pin control
  static volatile uint32_t & PIO1_SM2_PINCTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 268)) ;

  // Field OUT_BASE: The virtual pin corresponding to OUT bit 0
    inline uint32_t PIO1_SM2_PINCTRL_OUT_BASE (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field SET_BASE: The virtual pin corresponding to SET bit 0
    inline uint32_t PIO1_SM2_PINCTRL_SET_BASE (const uint32_t inValue) {return (inValue & 0x1FU) << 5 ; }

  // Field SIDESET_BASE: The virtual pin corresponding to delay field bit 0
    inline uint32_t PIO1_SM2_PINCTRL_SIDESET_BASE (const uint32_t inValue) {return (inValue & 0x1FU) << 10 ; }

  // Field IN_BASE: The virtual pin corresponding to IN bit 0
    inline uint32_t PIO1_SM2_PINCTRL_IN_BASE (const uint32_t inValue) {return (inValue & 0x1FU) << 15 ; }

  // Field OUT_COUNT: The number of pins asserted by an OUT. Value of 0 -> 32 pins
    inline uint32_t PIO1_SM2_PINCTRL_OUT_COUNT (const uint32_t inValue) {return (inValue & 0x3FU) << 20 ; }

  // Field SET_COUNT: The number of pins asserted by a SET. Max of 5
    inline uint32_t PIO1_SM2_PINCTRL_SET_COUNT (const uint32_t inValue) {return (inValue & 0x7U) << 26 ; }

  // Field SIDESET_COUNT: The number of delay bits co-opted for side-set. Inclusive of the enable bit, if present.
    inline uint32_t PIO1_SM2_PINCTRL_SIDESET_COUNT (const uint32_t inValue) {return (inValue & 0x7U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register SM3_CLKDIV: Clock divider register for state machine 3\n Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
  static volatile uint32_t & PIO1_SM3_CLKDIV __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 272)) ;

  // Field FRAC: Fractional part of clock divider
    inline uint32_t PIO1_SM3_CLKDIV_FRAC (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field INT: Effective frequency is sysclk/int.\n Value of 0 is interpreted as max possible value
    inline uint32_t PIO1_SM3_CLKDIV_INT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register SM3_EXECCTRL: Execution/behavioural settings for state machine 3
  static volatile uint32_t & PIO1_SM3_EXECCTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 276)) ;

  // Field STATUS_N: Comparison level for the MOV x, STATUS instruction
    inline uint32_t PIO1_SM3_EXECCTRL_STATUS_N (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field STATUS_SEL: Comparison used for the MOV x, STATUS instruction.
    const uint32_t PIO1_SM3_EXECCTRL_STATUS_SEL = 1U << 4 ;

  // Field WRAP_BOTTOM: After reaching wrap_top, execution is wrapped to this address.
    inline uint32_t PIO1_SM3_EXECCTRL_WRAP_BOTTOM (const uint32_t inValue) {return (inValue & 0x1FU) << 7 ; }

  // Field WRAP_TOP: After reaching this address, execution is wrapped to wrap_bottom.\n If the instruction is a jump, and the jump condition is true, the jump takes priority.
    inline uint32_t PIO1_SM3_EXECCTRL_WRAP_TOP (const uint32_t inValue) {return (inValue & 0x1FU) << 12 ; }

  // Field OUT_STICKY: Continuously assert the most recent OUT/SET to the pins
    const uint32_t PIO1_SM3_EXECCTRL_OUT_STICKY = 1U << 17 ;

  // Field INLINE_OUT_EN: If 1, use a bit of OUT data as an auxiliary write enable\n When used in conjunction with OUT_STICKY, writes with an enable of 0 will\n deassert the latest pin write. This can create useful masking/override behaviour\n due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)
    const uint32_t PIO1_SM3_EXECCTRL_INLINE_OUT_EN = 1U << 18 ;

  // Field OUT_EN_SEL: Which data bit to use for inline OUT enable
    inline uint32_t PIO1_SM3_EXECCTRL_OUT_EN_SEL (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

  // Field JMP_PIN: The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
    inline uint32_t PIO1_SM3_EXECCTRL_JMP_PIN (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

  // Field SIDE_PINDIR: Side-set data is asserted to pin OEs instead of pin values
    const uint32_t PIO1_SM3_EXECCTRL_SIDE_PINDIR = 1U << 29 ;

  // Field SIDE_EN: If 1, the delay MSB is used as side-set enable, rather than a\n side-set data bit. This allows instructions to perform side-set optionally,\n rather than on every instruction.
    const uint32_t PIO1_SM3_EXECCTRL_SIDE_EN = 1U << 30 ;

  // Field EXEC_STALLED: An instruction written to SMx_INSTR is stalled, and latched by the\n state machine. Will clear once the instruction completes.
    const uint32_t PIO1_SM3_EXECCTRL_EXEC_STALLED = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register SM3_SHIFTCTRL: Control behaviour of the input/output shift registers for state machine 3
  static volatile uint32_t & PIO1_SM3_SHIFTCTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 280)) ;

  // Field AUTOPUSH: Push automatically when the input shift register is filled
    const uint32_t PIO1_SM3_SHIFTCTRL_AUTOPUSH = 1U << 16 ;

  // Field AUTOPULL: Pull automatically when the output shift register is emptied
    const uint32_t PIO1_SM3_SHIFTCTRL_AUTOPULL = 1U << 17 ;

  // Field IN_SHIFTDIR: 1 = shift input shift register to right (data enters from left). 0 = to left.
    const uint32_t PIO1_SM3_SHIFTCTRL_IN_SHIFTDIR = 1U << 18 ;

  // Field OUT_SHIFTDIR: 1 = shift out of output shift register to right. 0 = to left.
    const uint32_t PIO1_SM3_SHIFTCTRL_OUT_SHIFTDIR = 1U << 19 ;

  // Field PUSH_THRESH: Number of bits shifted into RXSR before autopush or conditional push.\n Write 0 for value of 32.
    inline uint32_t PIO1_SM3_SHIFTCTRL_PUSH_THRESH (const uint32_t inValue) {return (inValue & 0x1FU) << 20 ; }

  // Field PULL_THRESH: Number of bits shifted out of TXSR before autopull or conditional pull.\n Write 0 for value of 32.
    inline uint32_t PIO1_SM3_SHIFTCTRL_PULL_THRESH (const uint32_t inValue) {return (inValue & 0x1FU) << 25 ; }

  // Field FJOIN_TX: When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep.\n RX FIFO is disabled as a result (always reads as both full and empty).\n FIFOs are flushed when this bit is changed.
    const uint32_t PIO1_SM3_SHIFTCTRL_FJOIN_TX = 1U << 30 ;

  // Field FJOIN_RX: When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep.\n TX FIFO is disabled as a result (always reads as both full and empty).\n FIFOs are flushed when this bit is changed.
    const uint32_t PIO1_SM3_SHIFTCTRL_FJOIN_RX = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register SM3_ADDR: Current instruction address of state machine 3
  static volatile uint32_t & PIO1_SM3_ADDR __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 284)) ;

  // Field SM3_ADDR: 
    inline uint32_t PIO1_SM3_ADDR_SM3_ADDR (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SM3_INSTR: Instruction currently being executed by state machine 3\n Write to execute an instruction immediately (including jumps) and then resume execution.
  static volatile uint32_t & PIO1_SM3_INSTR __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 288)) ;

  // Field SM3_INSTR: 
    inline uint32_t PIO1_SM3_INSTR_SM3_INSTR (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SM3_PINCTRL: State machine pin control
  static volatile uint32_t & PIO1_SM3_PINCTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 292)) ;

  // Field OUT_BASE: The virtual pin corresponding to OUT bit 0
    inline uint32_t PIO1_SM3_PINCTRL_OUT_BASE (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field SET_BASE: The virtual pin corresponding to SET bit 0
    inline uint32_t PIO1_SM3_PINCTRL_SET_BASE (const uint32_t inValue) {return (inValue & 0x1FU) << 5 ; }

  // Field SIDESET_BASE: The virtual pin corresponding to delay field bit 0
    inline uint32_t PIO1_SM3_PINCTRL_SIDESET_BASE (const uint32_t inValue) {return (inValue & 0x1FU) << 10 ; }

  // Field IN_BASE: The virtual pin corresponding to IN bit 0
    inline uint32_t PIO1_SM3_PINCTRL_IN_BASE (const uint32_t inValue) {return (inValue & 0x1FU) << 15 ; }

  // Field OUT_COUNT: The number of pins asserted by an OUT. Value of 0 -> 32 pins
    inline uint32_t PIO1_SM3_PINCTRL_OUT_COUNT (const uint32_t inValue) {return (inValue & 0x3FU) << 20 ; }

  // Field SET_COUNT: The number of pins asserted by a SET. Max of 5
    inline uint32_t PIO1_SM3_PINCTRL_SET_COUNT (const uint32_t inValue) {return (inValue & 0x7U) << 26 ; }

  // Field SIDESET_COUNT: The number of delay bits co-opted for side-set. Inclusive of the enable bit, if present.
    inline uint32_t PIO1_SM3_PINCTRL_SIDESET_COUNT (const uint32_t inValue) {return (inValue & 0x7U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register INTR: Raw Interrupts
  static volatile uint32_t & PIO1_INTR __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 296)) ;

  // Field SM0_RXNEMPTY: 
    const uint32_t PIO1_INTR_SM0_RXNEMPTY = 1U << 0 ;

  // Field SM1_RXNEMPTY: 
    const uint32_t PIO1_INTR_SM1_RXNEMPTY = 1U << 1 ;

  // Field SM2_RXNEMPTY: 
    const uint32_t PIO1_INTR_SM2_RXNEMPTY = 1U << 2 ;

  // Field SM3_RXNEMPTY: 
    const uint32_t PIO1_INTR_SM3_RXNEMPTY = 1U << 3 ;

  // Field SM0_TXNFULL: 
    const uint32_t PIO1_INTR_SM0_TXNFULL = 1U << 4 ;

  // Field SM1_TXNFULL: 
    const uint32_t PIO1_INTR_SM1_TXNFULL = 1U << 5 ;

  // Field SM2_TXNFULL: 
    const uint32_t PIO1_INTR_SM2_TXNFULL = 1U << 6 ;

  // Field SM3_TXNFULL: 
    const uint32_t PIO1_INTR_SM3_TXNFULL = 1U << 7 ;

  // Field SM0: 
    const uint32_t PIO1_INTR_SM0 = 1U << 8 ;

  // Field SM1: 
    const uint32_t PIO1_INTR_SM1 = 1U << 9 ;

  // Field SM2: 
    const uint32_t PIO1_INTR_SM2 = 1U << 10 ;

  // Field SM3: 
    const uint32_t PIO1_INTR_SM3 = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register IRQ0_INTE: Interrupt Enable for irq0
  static volatile uint32_t & PIO1_IRQ0_INTE __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 300)) ;

  // Field SM0_RXNEMPTY: 
    const uint32_t PIO1_IRQ0_INTE_SM0_RXNEMPTY = 1U << 0 ;

  // Field SM1_RXNEMPTY: 
    const uint32_t PIO1_IRQ0_INTE_SM1_RXNEMPTY = 1U << 1 ;

  // Field SM2_RXNEMPTY: 
    const uint32_t PIO1_IRQ0_INTE_SM2_RXNEMPTY = 1U << 2 ;

  // Field SM3_RXNEMPTY: 
    const uint32_t PIO1_IRQ0_INTE_SM3_RXNEMPTY = 1U << 3 ;

  // Field SM0_TXNFULL: 
    const uint32_t PIO1_IRQ0_INTE_SM0_TXNFULL = 1U << 4 ;

  // Field SM1_TXNFULL: 
    const uint32_t PIO1_IRQ0_INTE_SM1_TXNFULL = 1U << 5 ;

  // Field SM2_TXNFULL: 
    const uint32_t PIO1_IRQ0_INTE_SM2_TXNFULL = 1U << 6 ;

  // Field SM3_TXNFULL: 
    const uint32_t PIO1_IRQ0_INTE_SM3_TXNFULL = 1U << 7 ;

  // Field SM0: 
    const uint32_t PIO1_IRQ0_INTE_SM0 = 1U << 8 ;

  // Field SM1: 
    const uint32_t PIO1_IRQ0_INTE_SM1 = 1U << 9 ;

  // Field SM2: 
    const uint32_t PIO1_IRQ0_INTE_SM2 = 1U << 10 ;

  // Field SM3: 
    const uint32_t PIO1_IRQ0_INTE_SM3 = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register IRQ0_INTF: Interrupt Force for irq0
  static volatile uint32_t & PIO1_IRQ0_INTF __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 304)) ;

  // Field SM0_RXNEMPTY: 
    const uint32_t PIO1_IRQ0_INTF_SM0_RXNEMPTY = 1U << 0 ;

  // Field SM1_RXNEMPTY: 
    const uint32_t PIO1_IRQ0_INTF_SM1_RXNEMPTY = 1U << 1 ;

  // Field SM2_RXNEMPTY: 
    const uint32_t PIO1_IRQ0_INTF_SM2_RXNEMPTY = 1U << 2 ;

  // Field SM3_RXNEMPTY: 
    const uint32_t PIO1_IRQ0_INTF_SM3_RXNEMPTY = 1U << 3 ;

  // Field SM0_TXNFULL: 
    const uint32_t PIO1_IRQ0_INTF_SM0_TXNFULL = 1U << 4 ;

  // Field SM1_TXNFULL: 
    const uint32_t PIO1_IRQ0_INTF_SM1_TXNFULL = 1U << 5 ;

  // Field SM2_TXNFULL: 
    const uint32_t PIO1_IRQ0_INTF_SM2_TXNFULL = 1U << 6 ;

  // Field SM3_TXNFULL: 
    const uint32_t PIO1_IRQ0_INTF_SM3_TXNFULL = 1U << 7 ;

  // Field SM0: 
    const uint32_t PIO1_IRQ0_INTF_SM0 = 1U << 8 ;

  // Field SM1: 
    const uint32_t PIO1_IRQ0_INTF_SM1 = 1U << 9 ;

  // Field SM2: 
    const uint32_t PIO1_IRQ0_INTF_SM2 = 1U << 10 ;

  // Field SM3: 
    const uint32_t PIO1_IRQ0_INTF_SM3 = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register IRQ0_INTS: Interrupt status after masking & forcing for irq0
  static volatile uint32_t & PIO1_IRQ0_INTS __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 308)) ;

  // Field SM0_RXNEMPTY: 
    const uint32_t PIO1_IRQ0_INTS_SM0_RXNEMPTY = 1U << 0 ;

  // Field SM1_RXNEMPTY: 
    const uint32_t PIO1_IRQ0_INTS_SM1_RXNEMPTY = 1U << 1 ;

  // Field SM2_RXNEMPTY: 
    const uint32_t PIO1_IRQ0_INTS_SM2_RXNEMPTY = 1U << 2 ;

  // Field SM3_RXNEMPTY: 
    const uint32_t PIO1_IRQ0_INTS_SM3_RXNEMPTY = 1U << 3 ;

  // Field SM0_TXNFULL: 
    const uint32_t PIO1_IRQ0_INTS_SM0_TXNFULL = 1U << 4 ;

  // Field SM1_TXNFULL: 
    const uint32_t PIO1_IRQ0_INTS_SM1_TXNFULL = 1U << 5 ;

  // Field SM2_TXNFULL: 
    const uint32_t PIO1_IRQ0_INTS_SM2_TXNFULL = 1U << 6 ;

  // Field SM3_TXNFULL: 
    const uint32_t PIO1_IRQ0_INTS_SM3_TXNFULL = 1U << 7 ;

  // Field SM0: 
    const uint32_t PIO1_IRQ0_INTS_SM0 = 1U << 8 ;

  // Field SM1: 
    const uint32_t PIO1_IRQ0_INTS_SM1 = 1U << 9 ;

  // Field SM2: 
    const uint32_t PIO1_IRQ0_INTS_SM2 = 1U << 10 ;

  // Field SM3: 
    const uint32_t PIO1_IRQ0_INTS_SM3 = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register IRQ1_INTE: Interrupt Enable for irq1
  static volatile uint32_t & PIO1_IRQ1_INTE __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 312)) ;

  // Field SM0_RXNEMPTY: 
    const uint32_t PIO1_IRQ1_INTE_SM0_RXNEMPTY = 1U << 0 ;

  // Field SM1_RXNEMPTY: 
    const uint32_t PIO1_IRQ1_INTE_SM1_RXNEMPTY = 1U << 1 ;

  // Field SM2_RXNEMPTY: 
    const uint32_t PIO1_IRQ1_INTE_SM2_RXNEMPTY = 1U << 2 ;

  // Field SM3_RXNEMPTY: 
    const uint32_t PIO1_IRQ1_INTE_SM3_RXNEMPTY = 1U << 3 ;

  // Field SM0_TXNFULL: 
    const uint32_t PIO1_IRQ1_INTE_SM0_TXNFULL = 1U << 4 ;

  // Field SM1_TXNFULL: 
    const uint32_t PIO1_IRQ1_INTE_SM1_TXNFULL = 1U << 5 ;

  // Field SM2_TXNFULL: 
    const uint32_t PIO1_IRQ1_INTE_SM2_TXNFULL = 1U << 6 ;

  // Field SM3_TXNFULL: 
    const uint32_t PIO1_IRQ1_INTE_SM3_TXNFULL = 1U << 7 ;

  // Field SM0: 
    const uint32_t PIO1_IRQ1_INTE_SM0 = 1U << 8 ;

  // Field SM1: 
    const uint32_t PIO1_IRQ1_INTE_SM1 = 1U << 9 ;

  // Field SM2: 
    const uint32_t PIO1_IRQ1_INTE_SM2 = 1U << 10 ;

  // Field SM3: 
    const uint32_t PIO1_IRQ1_INTE_SM3 = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register IRQ1_INTF: Interrupt Force for irq1
  static volatile uint32_t & PIO1_IRQ1_INTF __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 316)) ;

  // Field SM0_RXNEMPTY: 
    const uint32_t PIO1_IRQ1_INTF_SM0_RXNEMPTY = 1U << 0 ;

  // Field SM1_RXNEMPTY: 
    const uint32_t PIO1_IRQ1_INTF_SM1_RXNEMPTY = 1U << 1 ;

  // Field SM2_RXNEMPTY: 
    const uint32_t PIO1_IRQ1_INTF_SM2_RXNEMPTY = 1U << 2 ;

  // Field SM3_RXNEMPTY: 
    const uint32_t PIO1_IRQ1_INTF_SM3_RXNEMPTY = 1U << 3 ;

  // Field SM0_TXNFULL: 
    const uint32_t PIO1_IRQ1_INTF_SM0_TXNFULL = 1U << 4 ;

  // Field SM1_TXNFULL: 
    const uint32_t PIO1_IRQ1_INTF_SM1_TXNFULL = 1U << 5 ;

  // Field SM2_TXNFULL: 
    const uint32_t PIO1_IRQ1_INTF_SM2_TXNFULL = 1U << 6 ;

  // Field SM3_TXNFULL: 
    const uint32_t PIO1_IRQ1_INTF_SM3_TXNFULL = 1U << 7 ;

  // Field SM0: 
    const uint32_t PIO1_IRQ1_INTF_SM0 = 1U << 8 ;

  // Field SM1: 
    const uint32_t PIO1_IRQ1_INTF_SM1 = 1U << 9 ;

  // Field SM2: 
    const uint32_t PIO1_IRQ1_INTF_SM2 = 1U << 10 ;

  // Field SM3: 
    const uint32_t PIO1_IRQ1_INTF_SM3 = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register IRQ1_INTS: Interrupt status after masking & forcing for irq1
  static volatile uint32_t & PIO1_IRQ1_INTS __attribute__((unused)) = * ((volatile uint32_t *) (0x50300000 + 320)) ;

  // Field SM0_RXNEMPTY: 
    const uint32_t PIO1_IRQ1_INTS_SM0_RXNEMPTY = 1U << 0 ;

  // Field SM1_RXNEMPTY: 
    const uint32_t PIO1_IRQ1_INTS_SM1_RXNEMPTY = 1U << 1 ;

  // Field SM2_RXNEMPTY: 
    const uint32_t PIO1_IRQ1_INTS_SM2_RXNEMPTY = 1U << 2 ;

  // Field SM3_RXNEMPTY: 
    const uint32_t PIO1_IRQ1_INTS_SM3_RXNEMPTY = 1U << 3 ;

  // Field SM0_TXNFULL: 
    const uint32_t PIO1_IRQ1_INTS_SM0_TXNFULL = 1U << 4 ;

  // Field SM1_TXNFULL: 
    const uint32_t PIO1_IRQ1_INTS_SM1_TXNFULL = 1U << 5 ;

  // Field SM2_TXNFULL: 
    const uint32_t PIO1_IRQ1_INTS_SM2_TXNFULL = 1U << 6 ;

  // Field SM3_TXNFULL: 
    const uint32_t PIO1_IRQ1_INTS_SM3_TXNFULL = 1U << 7 ;

  // Field SM0: 
    const uint32_t PIO1_IRQ1_INTS_SM0 = 1U << 8 ;

  // Field SM1: 
    const uint32_t PIO1_IRQ1_INTS_SM1 = 1U << 9 ;

  // Field SM2: 
    const uint32_t PIO1_IRQ1_INTS_SM2 = 1U << 10 ;

  // Field SM3: 
    const uint32_t PIO1_IRQ1_INTS_SM3 = 1U << 11 ;

//------------------------------------------------------------------------------
// Peripheral PLL_SYS: 
//------------------------------------------------------------------------------

//---  Register CS: Control and Status\n GENERAL CONSTRAINTS:\n Reference clock frequency min=5MHz, max=800MHz\n Feedback divider min=16, max=320\n VCO frequency min=400MHz, max=1600MHz
  static volatile uint32_t & PLL_SYS_CS __attribute__((unused)) = * ((volatile uint32_t *) (0x40028000 + 0)) ;

  // Field REFDIV: Divides the PLL input reference clock.\n Behaviour is undefined for div=0.\n PLL output will be unpredictable during refdiv changes, wait for lock=1 before using it.
    inline uint32_t PLL_SYS_CS_REFDIV (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

  // Field BYPASS: Passes the reference clock to the output instead of the divided VCO. The VCO continues to run so the user can switch between the reference clock and the divided VCO but the output will glitch when doing so.
    const uint32_t PLL_SYS_CS_BYPASS = 1U << 8 ;

  // Field LOCK: PLL is locked
    const uint32_t PLL_SYS_CS_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register PWR: Controls the PLL power modes.
  static volatile uint32_t & PLL_SYS_PWR __attribute__((unused)) = * ((volatile uint32_t *) (0x40028000 + 4)) ;

  // Field PD: PLL powerdown\n To save power set high when PLL output not required.
    const uint32_t PLL_SYS_PWR_PD = 1U << 0 ;

  // Field DSMPD: PLL DSM powerdown\n Nothing is achieved by setting this low.
    const uint32_t PLL_SYS_PWR_DSMPD = 1U << 2 ;

  // Field POSTDIVPD: PLL post divider powerdown\n To save power set high when PLL output not required or bypass=1.
    const uint32_t PLL_SYS_PWR_POSTDIVPD = 1U << 3 ;

  // Field VCOPD: PLL VCO powerdown\n To save power set high when PLL output not required or bypass=1.
    const uint32_t PLL_SYS_PWR_VCOPD = 1U << 5 ;

//------------------------------------------------------------------------------

//---  Register FBDIV_INT: Feedback divisor\n (note: this PLL does not support fractional division)
  static volatile uint32_t & PLL_SYS_FBDIV_INT __attribute__((unused)) = * ((volatile uint32_t *) (0x40028000 + 8)) ;

  // Field FBDIV_INT: see ctrl reg description for constraints
    inline uint32_t PLL_SYS_FBDIV_INT_FBDIV_INT (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register PRIM: Controls the PLL post dividers for the primary output\n (note: this PLL does not have a secondary output)\n the primary output is driven from VCO divided by postdiv1*postdiv2
  static volatile uint32_t & PLL_SYS_PRIM __attribute__((unused)) = * ((volatile uint32_t *) (0x40028000 + 12)) ;

  // Field POSTDIV2: divide by 1-7
    inline uint32_t PLL_SYS_PRIM_POSTDIV2 (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field POSTDIV1: divide by 1-7
    inline uint32_t PLL_SYS_PRIM_POSTDIV1 (const uint32_t inValue) {return (inValue & 0x7U) << 16 ; }

//------------------------------------------------------------------------------
// Peripheral PLL_USB: 
//------------------------------------------------------------------------------

//---  Register CS: Control and Status\n GENERAL CONSTRAINTS:\n Reference clock frequency min=5MHz, max=800MHz\n Feedback divider min=16, max=320\n VCO frequency min=400MHz, max=1600MHz
  static volatile uint32_t & PLL_USB_CS __attribute__((unused)) = * ((volatile uint32_t *) (0x4002C000 + 0)) ;

  // Field REFDIV: Divides the PLL input reference clock.\n Behaviour is undefined for div=0.\n PLL output will be unpredictable during refdiv changes, wait for lock=1 before using it.
    inline uint32_t PLL_USB_CS_REFDIV (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

  // Field BYPASS: Passes the reference clock to the output instead of the divided VCO. The VCO continues to run so the user can switch between the reference clock and the divided VCO but the output will glitch when doing so.
    const uint32_t PLL_USB_CS_BYPASS = 1U << 8 ;

  // Field LOCK: PLL is locked
    const uint32_t PLL_USB_CS_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register PWR: Controls the PLL power modes.
  static volatile uint32_t & PLL_USB_PWR __attribute__((unused)) = * ((volatile uint32_t *) (0x4002C000 + 4)) ;

  // Field PD: PLL powerdown\n To save power set high when PLL output not required.
    const uint32_t PLL_USB_PWR_PD = 1U << 0 ;

  // Field DSMPD: PLL DSM powerdown\n Nothing is achieved by setting this low.
    const uint32_t PLL_USB_PWR_DSMPD = 1U << 2 ;

  // Field POSTDIVPD: PLL post divider powerdown\n To save power set high when PLL output not required or bypass=1.
    const uint32_t PLL_USB_PWR_POSTDIVPD = 1U << 3 ;

  // Field VCOPD: PLL VCO powerdown\n To save power set high when PLL output not required or bypass=1.
    const uint32_t PLL_USB_PWR_VCOPD = 1U << 5 ;

//------------------------------------------------------------------------------

//---  Register FBDIV_INT: Feedback divisor\n (note: this PLL does not support fractional division)
  static volatile uint32_t & PLL_USB_FBDIV_INT __attribute__((unused)) = * ((volatile uint32_t *) (0x4002C000 + 8)) ;

  // Field FBDIV_INT: see ctrl reg description for constraints
    inline uint32_t PLL_USB_FBDIV_INT_FBDIV_INT (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register PRIM: Controls the PLL post dividers for the primary output\n (note: this PLL does not have a secondary output)\n the primary output is driven from VCO divided by postdiv1*postdiv2
  static volatile uint32_t & PLL_USB_PRIM __attribute__((unused)) = * ((volatile uint32_t *) (0x4002C000 + 12)) ;

  // Field POSTDIV2: divide by 1-7
    inline uint32_t PLL_USB_PRIM_POSTDIV2 (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field POSTDIV1: divide by 1-7
    inline uint32_t PLL_USB_PRIM_POSTDIV1 (const uint32_t inValue) {return (inValue & 0x7U) << 16 ; }

//------------------------------------------------------------------------------
// Peripheral PPB: 
//------------------------------------------------------------------------------

//---  Register SYST_CSR: Use the SysTick Control and Status Register to enable the SysTick features.
  static volatile uint32_t & PPB_SYST_CSR __attribute__((unused)) = * ((volatile uint32_t *) (0xE0000000 + 57360)) ;

  // Field ENABLE: Enable SysTick counter:\n 0 = Counter disabled.\n 1 = Counter enabled.
    const uint32_t PPB_SYST_CSR_ENABLE = 1U << 0 ;

  // Field TICKINT: Enables SysTick exception request:\n 0 = Counting down to zero does not assert the SysTick exception request.\n 1 = Counting down to zero to asserts the SysTick exception request.
    const uint32_t PPB_SYST_CSR_TICKINT = 1U << 1 ;

  // Field CLKSOURCE: SysTick clock source. Always reads as one if SYST_CALIB reports NOREF.\n Selects the SysTick timer clock source:\n 0 = External reference clock.\n 1 = Processor clock.
    const uint32_t PPB_SYST_CSR_CLKSOURCE = 1U << 2 ;

  // Field COUNTFLAG: Returns 1 if timer counted to 0 since last time this was read. Clears on read by application or debugger.
    const uint32_t PPB_SYST_CSR_COUNTFLAG = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register SYST_RVR: Use the SysTick Reload Value Register to specify the start value to load into the current value register when the counter reaches 0. It can be any value between 0 and 0x00FFFFFF. A start value of 0 is possible, but has no effect because the SysTick interrupt and COUNTFLAG are activated when counting from 1 to 0. The reset value of this register is UNKNOWN.\n To generate a multi-shot timer with a period of N processor clock cycles, use a RELOAD value of N-1. For example, if the SysTick interrupt is required every 100 clock pulses, set RELOAD to 99.
  static volatile uint32_t & PPB_SYST_RVR __attribute__((unused)) = * ((volatile uint32_t *) (0xE0000000 + 57364)) ;

  // Field RELOAD: Value to load into the SysTick Current Value Register when the counter reaches 0.
    inline uint32_t PPB_SYST_RVR_RELOAD (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SYST_CVR: Use the SysTick Current Value Register to find the current value in the register. The reset value of this register is UNKNOWN.
  static volatile uint32_t & PPB_SYST_CVR __attribute__((unused)) = * ((volatile uint32_t *) (0xE0000000 + 57368)) ;

  // Field CURRENT: Reads return the current value of the SysTick counter. This register is write-clear. Writing to it with any value clears the register to 0. Clearing this register also clears the COUNTFLAG bit of the SysTick Control and Status Register.
    inline uint32_t PPB_SYST_CVR_CURRENT (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SYST_CALIB: Use the SysTick Calibration Value Register to enable software to scale to any required speed using divide and multiply.
  static volatile uint32_t & PPB_SYST_CALIB __attribute__((unused)) = * ((volatile uint32_t *) (0xE0000000 + 57372)) ;

  // Field TENMS: An optional Reload value to be used for 10ms (100Hz) timing, subject to system clock skew errors. If the value reads as 0, the calibration value is not known.
    inline uint32_t PPB_SYST_CALIB_TENMS (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 0 ; }

  // Field SKEW: If reads as 1, the calibration value for 10ms is inexact (due to clock frequency).
    const uint32_t PPB_SYST_CALIB_SKEW = 1U << 30 ;

  // Field NOREF: If reads as 1, the Reference clock is not provided - the CLKSOURCE bit of the SysTick Control and Status register will be forced to 1 and cannot be cleared to 0.
    const uint32_t PPB_SYST_CALIB_NOREF = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register NVIC_ISER: Use the Interrupt Set-Enable Register to enable interrupts and determine which interrupts are currently enabled.\n If a pending interrupt is enabled, the NVIC activates the interrupt based on its priority. If an interrupt is not enabled, asserting its interrupt signal changes the interrupt state to pending, but the NVIC never activates the interrupt, regardless of its priority.
  static volatile uint32_t & PPB_NVIC_ISER __attribute__((unused)) = * ((volatile uint32_t *) (0xE0000000 + 57600)) ;

  // Field SETENA: Interrupt set-enable bits.\n Write:\n 0 = No effect.\n 1 = Enable interrupt.\n Read:\n 0 = Interrupt disabled.\n 1 = Interrupt enabled.
    inline uint32_t PPB_NVIC_ISER_SETENA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register NVIC_ICER: Use the Interrupt Clear-Enable Registers to disable interrupts and determine which interrupts are currently enabled.
  static volatile uint32_t & PPB_NVIC_ICER __attribute__((unused)) = * ((volatile uint32_t *) (0xE0000000 + 57728)) ;

  // Field CLRENA: Interrupt clear-enable bits.\n Write:\n 0 = No effect.\n 1 = Disable interrupt.\n Read:\n 0 = Interrupt disabled.\n 1 = Interrupt enabled.
    inline uint32_t PPB_NVIC_ICER_CLRENA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register NVIC_ISPR: The NVIC_ISPR forces interrupts into the pending state, and shows which interrupts are pending.
  static volatile uint32_t & PPB_NVIC_ISPR __attribute__((unused)) = * ((volatile uint32_t *) (0xE0000000 + 57856)) ;

  // Field SETPEND: Interrupt set-pending bits.\n Write:\n 0 = No effect.\n 1 = Changes interrupt state to pending.\n Read:\n 0 = Interrupt is not pending.\n 1 = Interrupt is pending.\n Note: Writing 1 to the NVIC_ISPR bit corresponding to:\n An interrupt that is pending has no effect.\n A disabled interrupt sets the state of that interrupt to pending.
    inline uint32_t PPB_NVIC_ISPR_SETPEND (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register NVIC_ICPR: Use the Interrupt Clear-Pending Register to clear pending interrupts and determine which interrupts are currently pending.
  static volatile uint32_t & PPB_NVIC_ICPR __attribute__((unused)) = * ((volatile uint32_t *) (0xE0000000 + 57984)) ;

  // Field CLRPEND: Interrupt clear-pending bits.\n Write:\n 0 = No effect.\n 1 = Removes pending state and interrupt.\n Read:\n 0 = Interrupt is not pending.\n 1 = Interrupt is pending.
    inline uint32_t PPB_NVIC_ICPR_CLRPEND (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register NVIC_IPR0: Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.\n Note: Writing 1 to an NVIC_ICPR bit does not affect the active state of the corresponding interrupt.\n These registers are only word-accessible
  static volatile uint32_t & PPB_NVIC_IPR0 __attribute__((unused)) = * ((volatile uint32_t *) (0xE0000000 + 58368)) ;

  // Field IP_0: Priority of interrupt 0
    inline uint32_t PPB_NVIC_IPR0_IP_0 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field IP_1: Priority of interrupt 1
    inline uint32_t PPB_NVIC_IPR0_IP_1 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field IP_2: Priority of interrupt 2
    inline uint32_t PPB_NVIC_IPR0_IP_2 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field IP_3: Priority of interrupt 3
    inline uint32_t PPB_NVIC_IPR0_IP_3 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register NVIC_IPR1: Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
  static volatile uint32_t & PPB_NVIC_IPR1 __attribute__((unused)) = * ((volatile uint32_t *) (0xE0000000 + 58372)) ;

  // Field IP_4: Priority of interrupt 4
    inline uint32_t PPB_NVIC_IPR1_IP_4 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field IP_5: Priority of interrupt 5
    inline uint32_t PPB_NVIC_IPR1_IP_5 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field IP_6: Priority of interrupt 6
    inline uint32_t PPB_NVIC_IPR1_IP_6 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field IP_7: Priority of interrupt 7
    inline uint32_t PPB_NVIC_IPR1_IP_7 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register NVIC_IPR2: Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
  static volatile uint32_t & PPB_NVIC_IPR2 __attribute__((unused)) = * ((volatile uint32_t *) (0xE0000000 + 58376)) ;

  // Field IP_8: Priority of interrupt 8
    inline uint32_t PPB_NVIC_IPR2_IP_8 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field IP_9: Priority of interrupt 9
    inline uint32_t PPB_NVIC_IPR2_IP_9 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field IP_10: Priority of interrupt 10
    inline uint32_t PPB_NVIC_IPR2_IP_10 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field IP_11: Priority of interrupt 11
    inline uint32_t PPB_NVIC_IPR2_IP_11 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register NVIC_IPR3: Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
  static volatile uint32_t & PPB_NVIC_IPR3 __attribute__((unused)) = * ((volatile uint32_t *) (0xE0000000 + 58380)) ;

  // Field IP_12: Priority of interrupt 12
    inline uint32_t PPB_NVIC_IPR3_IP_12 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field IP_13: Priority of interrupt 13
    inline uint32_t PPB_NVIC_IPR3_IP_13 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field IP_14: Priority of interrupt 14
    inline uint32_t PPB_NVIC_IPR3_IP_14 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field IP_15: Priority of interrupt 15
    inline uint32_t PPB_NVIC_IPR3_IP_15 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register NVIC_IPR4: Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
  static volatile uint32_t & PPB_NVIC_IPR4 __attribute__((unused)) = * ((volatile uint32_t *) (0xE0000000 + 58384)) ;

  // Field IP_16: Priority of interrupt 16
    inline uint32_t PPB_NVIC_IPR4_IP_16 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field IP_17: Priority of interrupt 17
    inline uint32_t PPB_NVIC_IPR4_IP_17 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field IP_18: Priority of interrupt 18
    inline uint32_t PPB_NVIC_IPR4_IP_18 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field IP_19: Priority of interrupt 19
    inline uint32_t PPB_NVIC_IPR4_IP_19 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register NVIC_IPR5: Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
  static volatile uint32_t & PPB_NVIC_IPR5 __attribute__((unused)) = * ((volatile uint32_t *) (0xE0000000 + 58388)) ;

  // Field IP_20: Priority of interrupt 20
    inline uint32_t PPB_NVIC_IPR5_IP_20 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field IP_21: Priority of interrupt 21
    inline uint32_t PPB_NVIC_IPR5_IP_21 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field IP_22: Priority of interrupt 22
    inline uint32_t PPB_NVIC_IPR5_IP_22 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field IP_23: Priority of interrupt 23
    inline uint32_t PPB_NVIC_IPR5_IP_23 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register NVIC_IPR6: Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
  static volatile uint32_t & PPB_NVIC_IPR6 __attribute__((unused)) = * ((volatile uint32_t *) (0xE0000000 + 58392)) ;

  // Field IP_24: Priority of interrupt 24
    inline uint32_t PPB_NVIC_IPR6_IP_24 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field IP_25: Priority of interrupt 25
    inline uint32_t PPB_NVIC_IPR6_IP_25 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field IP_26: Priority of interrupt 26
    inline uint32_t PPB_NVIC_IPR6_IP_26 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field IP_27: Priority of interrupt 27
    inline uint32_t PPB_NVIC_IPR6_IP_27 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register NVIC_IPR7: Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
  static volatile uint32_t & PPB_NVIC_IPR7 __attribute__((unused)) = * ((volatile uint32_t *) (0xE0000000 + 58396)) ;

  // Field IP_28: Priority of interrupt 28
    inline uint32_t PPB_NVIC_IPR7_IP_28 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field IP_29: Priority of interrupt 29
    inline uint32_t PPB_NVIC_IPR7_IP_29 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field IP_30: Priority of interrupt 30
    inline uint32_t PPB_NVIC_IPR7_IP_30 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field IP_31: Priority of interrupt 31
    inline uint32_t PPB_NVIC_IPR7_IP_31 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register CPUID: Read the CPU ID Base Register to determine: the ID number of the processor core, the version number of the processor core, the implementation details of the processor core.
  static volatile uint32_t & PPB_CPUID __attribute__((unused)) = * ((volatile uint32_t *) (0xE0000000 + 60672)) ;

  // Field REVISION: Minor revision number m in the rnpm revision status:\n 0x1 = Patch 1.
    inline uint32_t PPB_CPUID_REVISION (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field PARTNO: Number of processor within family: 0xC60 = Cortex-M0+
    inline uint32_t PPB_CPUID_PARTNO (const uint32_t inValue) {return (inValue & 0xFFFU) << 4 ; }

  // Field ARCHITECTURE: Constant that defines the architecture of the processor:\n 0xC = ARMv6-M architecture.
    inline uint32_t PPB_CPUID_ARCHITECTURE (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field VARIANT: Major revision number n in the rnpm revision status:\n 0x0 = Revision 0.
    inline uint32_t PPB_CPUID_VARIANT (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field IMPLEMENTER: Implementor code: 0x41 = ARM
    inline uint32_t PPB_CPUID_IMPLEMENTER (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register ICSR: Use the Interrupt Control State Register to set a pending Non-Maskable Interrupt (NMI), set or clear a pending PendSV, set or clear a pending SysTick, check for pending exceptions, check the vector number of the highest priority pended exception, check the vector number of the active exception.
  static volatile uint32_t & PPB_ICSR __attribute__((unused)) = * ((volatile uint32_t *) (0xE0000000 + 60676)) ;

  // Field VECTACTIVE: Active exception number field. Reset clears the VECTACTIVE field.
    inline uint32_t PPB_ICSR_VECTACTIVE (const uint32_t inValue) {return (inValue & 0x1FFU) << 0 ; }

  // Field VECTPENDING: Indicates the exception number for the highest priority pending exception: 0 = no pending exceptions. Non zero = The pending state includes the effect of memory-mapped enable and mask registers. It does not include the PRIMASK special-purpose register qualifier.
    inline uint32_t PPB_ICSR_VECTPENDING (const uint32_t inValue) {return (inValue & 0x1FFU) << 12 ; }

  // Field ISRPENDING: External interrupt pending flag
    const uint32_t PPB_ICSR_ISRPENDING = 1U << 22 ;

  // Field ISRPREEMPT: The system can only access this bit when the core is halted. It indicates that a pending interrupt is to be taken in the next running cycle. If C_MASKINTS is clear in the Debug Halting Control and Status Register, the interrupt is serviced.
    const uint32_t PPB_ICSR_ISRPREEMPT = 1U << 23 ;

  // Field PENDSTCLR: SysTick exception clear-pending bit.\n Write:\n 0 = No effect.\n 1 = Removes the pending state from the SysTick exception.\n This bit is WO. On a register read its value is Unknown.
    const uint32_t PPB_ICSR_PENDSTCLR = 1U << 25 ;

  // Field PENDSTSET: SysTick exception set-pending bit.\n Write:\n 0 = No effect.\n 1 = Changes SysTick exception state to pending.\n Read:\n 0 = SysTick exception is not pending.\n 1 = SysTick exception is pending.
    const uint32_t PPB_ICSR_PENDSTSET = 1U << 26 ;

  // Field PENDSVCLR: PendSV clear-pending bit.\n Write:\n 0 = No effect.\n 1 = Removes the pending state from the PendSV exception.
    const uint32_t PPB_ICSR_PENDSVCLR = 1U << 27 ;

  // Field PENDSVSET: PendSV set-pending bit.\n Write:\n 0 = No effect.\n 1 = Changes PendSV exception state to pending.\n Read:\n 0 = PendSV exception is not pending.\n 1 = PendSV exception is pending.\n Writing 1 to this bit is the only way to set the PendSV exception state to pending.
    const uint32_t PPB_ICSR_PENDSVSET = 1U << 28 ;

  // Field NMIPENDSET: Setting this bit will activate an NMI. Since NMI is the highest priority exception, it will activate as soon as it is registered.\n NMI set-pending bit.\n Write:\n 0 = No effect.\n 1 = Changes NMI exception state to pending.\n Read:\n 0 = NMI exception is not pending.\n 1 = NMI exception is pending.\n Because NMI is the highest-priority exception, normally the processor enters the NMI\n exception handler as soon as it detects a write of 1 to this bit. Entering the handler then clears\n this bit to 0. This means a read of this bit by the NMI exception handler returns 1 only if the\n NMI signal is reasserted while the processor is executing that handler.
    const uint32_t PPB_ICSR_NMIPENDSET = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register VTOR: The VTOR holds the vector table offset address.
  static volatile uint32_t & PPB_VTOR __attribute__((unused)) = * ((volatile uint32_t *) (0xE0000000 + 60680)) ;

  // Field TBLOFF: Bits [31:8] of the indicate the vector table offset address.
    inline uint32_t PPB_VTOR_TBLOFF (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register AIRCR: Use the Application Interrupt and Reset Control Register to: determine data endianness, clear all active state information from debug halt mode, request a system reset.
  static volatile uint32_t & PPB_AIRCR __attribute__((unused)) = * ((volatile uint32_t *) (0xE0000000 + 60684)) ;

  // Field VECTCLRACTIVE: Clears all active state information for fixed and configurable exceptions. This bit: is self-clearing, can only be set by the DAP when the core is halted. When set: clears all active exception status of the processor, forces a return to Thread mode, forces an IPSR of 0. A debugger must re-initialize the stack.
    const uint32_t PPB_AIRCR_VECTCLRACTIVE = 1U << 1 ;

  // Field SYSRESETREQ: Writing 1 to this bit causes the SYSRESETREQ signal to the outer system to be asserted to request a reset. The intention is to force a large system reset of all major components except for debug. The C_HALT bit in the DHCSR is cleared as a result of the system reset requested. The debugger does not lose contact with the device.
    const uint32_t PPB_AIRCR_SYSRESETREQ = 1U << 2 ;

  // Field ENDIANESS: Data endianness implemented:\n 0 = Little-endian.
    const uint32_t PPB_AIRCR_ENDIANESS = 1U << 15 ;

  // Field VECTKEY: Register key:\n Reads as Unknown\n On writes, write 0x05FA to VECTKEY, otherwise the write is ignored.
    inline uint32_t PPB_AIRCR_VECTKEY (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register SCR: System Control Register. Use the System Control Register for power-management functions: signal to the system when the processor can enter a low power state, control how the processor enters and exits low power states.
  static volatile uint32_t & PPB_SCR __attribute__((unused)) = * ((volatile uint32_t *) (0xE0000000 + 60688)) ;

  // Field SLEEPONEXIT: Indicates sleep-on-exit when returning from Handler mode to Thread mode:\n 0 = Do not sleep when returning to Thread mode.\n 1 = Enter sleep, or deep sleep, on return from an ISR to Thread mode.\n Setting this bit to 1 enables an interrupt driven application to avoid returning to an empty main application.
    const uint32_t PPB_SCR_SLEEPONEXIT = 1U << 1 ;

  // Field SLEEPDEEP: Controls whether the processor uses sleep or deep sleep as its low power mode:\n 0 = Sleep.\n 1 = Deep sleep.
    const uint32_t PPB_SCR_SLEEPDEEP = 1U << 2 ;

  // Field SEVONPEND: Send Event on Pending bit:\n 0 = Only enabled interrupts or events can wakeup the processor, disabled interrupts are excluded.\n 1 = Enabled events and all interrupts, including disabled interrupts, can wakeup the processor.\n When an event or interrupt becomes pending, the event signal wakes up the processor from WFE. If the\n processor is not waiting for an event, the event is registered and affects the next WFE.\n The processor also wakes up on execution of an SEV instruction or an external event.
    const uint32_t PPB_SCR_SEVONPEND = 1U << 4 ;

//------------------------------------------------------------------------------

//---  Register CCR: The Configuration and Control Register permanently enables stack alignment and causes unaligned accesses to result in a Hard Fault.
  static volatile uint32_t & PPB_CCR __attribute__((unused)) = * ((volatile uint32_t *) (0xE0000000 + 60692)) ;

  // Field UNALIGN_TRP: Always reads as one, indicates that all unaligned accesses generate a HardFault.
    const uint32_t PPB_CCR_UNALIGN_TRP = 1U << 3 ;

  // Field STKALIGN: Always reads as one, indicates 8-byte stack alignment on exception entry. On exception entry, the processor uses bit[9] of the stacked PSR to indicate the stack alignment. On return from the exception it uses this stacked bit to restore the correct stack alignment.
    const uint32_t PPB_CCR_STKALIGN = 1U << 9 ;

//------------------------------------------------------------------------------

//---  Register SHPR2: System handlers are a special class of exception handler that can have their priority set to any of the priority levels. Use the System Handler Priority Register 2 to set the priority of SVCall.
  static volatile uint32_t & PPB_SHPR2 __attribute__((unused)) = * ((volatile uint32_t *) (0xE0000000 + 60700)) ;

  // Field PRI_11: Priority of system handler 11, SVCall
    inline uint32_t PPB_SHPR2_PRI_11 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register SHPR3: System handlers are a special class of exception handler that can have their priority set to any of the priority levels. Use the System Handler Priority Register 3 to set the priority of PendSV and SysTick.
  static volatile uint32_t & PPB_SHPR3 __attribute__((unused)) = * ((volatile uint32_t *) (0xE0000000 + 60704)) ;

  // Field PRI_14: Priority of system handler 14, PendSV
    inline uint32_t PPB_SHPR3_PRI_14 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field PRI_15: Priority of system handler 15, SysTick
    inline uint32_t PPB_SHPR3_PRI_15 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register SHCSR: Use the System Handler Control and State Register to determine or clear the pending status of SVCall.
  static volatile uint32_t & PPB_SHCSR __attribute__((unused)) = * ((volatile uint32_t *) (0xE0000000 + 60708)) ;

  // Field SVCALLPENDED: Reads as 1 if SVCall is Pending. Write 1 to set pending SVCall, write 0 to clear pending SVCall.
    const uint32_t PPB_SHCSR_SVCALLPENDED = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register MPU_TYPE: Read the MPU Type Register to determine if the processor implements an MPU, and how many regions the MPU supports.
  static volatile uint32_t & PPB_MPU_TYPE __attribute__((unused)) = * ((volatile uint32_t *) (0xE0000000 + 60816)) ;

  // Field SEPARATE: Indicates support for separate instruction and data address maps. Reads as 0 as ARMv6-M only supports a unified MPU.
    const uint32_t PPB_MPU_TYPE_SEPARATE = 1U << 0 ;

  // Field DREGION: Number of regions supported by the MPU.
    inline uint32_t PPB_MPU_TYPE_DREGION (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IREGION: Instruction region. Reads as zero as ARMv6-M only supports a unified MPU.
    inline uint32_t PPB_MPU_TYPE_IREGION (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register MPU_CTRL: Use the MPU Control Register to enable and disable the MPU, and to control whether the default memory map is enabled as a background region for privileged accesses, and whether the MPU is enabled for HardFaults and NMIs.
  static volatile uint32_t & PPB_MPU_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0xE0000000 + 60820)) ;

  // Field ENABLE: Enables the MPU. If the MPU is disabled, privileged and unprivileged accesses use the default memory map.\n 0 = MPU disabled.\n 1 = MPU enabled.
    const uint32_t PPB_MPU_CTRL_ENABLE = 1U << 0 ;

  // Field HFNMIENA: Controls the use of the MPU for HardFaults and NMIs. Setting this bit when ENABLE is clear results in UNPREDICTABLE behaviour.\n When the MPU is enabled:\n 0 = MPU is disabled during HardFault and NMI handlers, regardless of the value of the ENABLE bit.\n 1 = the MPU is enabled during HardFault and NMI handlers.
    const uint32_t PPB_MPU_CTRL_HFNMIENA = 1U << 1 ;

  // Field PRIVDEFENA: Controls whether the default memory map is enabled as a background region for privileged accesses. This bit is ignored when ENABLE is clear.\n 0 = If the MPU is enabled, disables use of the default memory map. Any memory access to a location not\n covered by any enabled region causes a fault.\n 1 = If the MPU is enabled, enables use of the default memory map as a background region for privileged software accesses.\n When enabled, the background region acts as if it is region number -1. Any region that is defined and enabled has priority over this default map.
    const uint32_t PPB_MPU_CTRL_PRIVDEFENA = 1U << 2 ;

//------------------------------------------------------------------------------

//---  Register MPU_RNR: Use the MPU Region Number Register to select the region currently accessed by MPU_RBAR and MPU_RASR.
  static volatile uint32_t & PPB_MPU_RNR __attribute__((unused)) = * ((volatile uint32_t *) (0xE0000000 + 60824)) ;

  // Field REGION: Indicates the MPU region referenced by the MPU_RBAR and MPU_RASR registers.\n The MPU supports 8 memory regions, so the permitted values of this field are 0-7.
    inline uint32_t PPB_MPU_RNR_REGION (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MPU_RBAR: Read the MPU Region Base Address Register to determine the base address of the region identified by MPU_RNR. Write to update the base address of said region or that of a specified region, with whose number MPU_RNR will also be updated.
  static volatile uint32_t & PPB_MPU_RBAR __attribute__((unused)) = * ((volatile uint32_t *) (0xE0000000 + 60828)) ;

  // Field REGION: On writes, specifies the number of the region whose base address to update provided VALID is set written as 1. On reads, returns bits [3:0] of MPU_RNR.
    inline uint32_t PPB_MPU_RBAR_REGION (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field VALID: On writes, indicates whether the write must update the base address of the region identified by the REGION field, updating the MPU_RNR to indicate this new region.\n Write:\n 0 = MPU_RNR not changed, and the processor:\n Updates the base address for the region specified in the MPU_RNR.\n Ignores the value of the REGION field.\n 1 = The processor:\n Updates the value of the MPU_RNR to the value of the REGION field.\n Updates the base address for the region specified in the REGION field.\n Always reads as zero.
    const uint32_t PPB_MPU_RBAR_VALID = 1U << 4 ;

  // Field ADDR: Base address of the region.
    inline uint32_t PPB_MPU_RBAR_ADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register MPU_RASR: Use the MPU Region Attribute and Size Register to define the size, access behaviour and memory type of the region identified by MPU_RNR, and enable that region.
  static volatile uint32_t & PPB_MPU_RASR __attribute__((unused)) = * ((volatile uint32_t *) (0xE0000000 + 60832)) ;

  // Field ENABLE: Enables the region.
    const uint32_t PPB_MPU_RASR_ENABLE = 1U << 0 ;

  // Field SIZE: Indicates the region size. Region size in bytes = 2^(SIZE+1). The minimum permitted value is 7 (b00111) = 256Bytes
    inline uint32_t PPB_MPU_RASR_SIZE (const uint32_t inValue) {return (inValue & 0x1FU) << 1 ; }

  // Field SRD: Subregion Disable. For regions of 256 bytes or larger, each bit of this field controls whether one of the eight equal subregions is enabled.
    inline uint32_t PPB_MPU_RASR_SRD (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field ATTRS: The MPU Region Attribute field. Use to define the region attribute control.\n 28 = XN: Instruction access disable bit:\n 0 = Instruction fetches enabled.\n 1 = Instruction fetches disabled.\n 26:24 = AP: Access permission field\n 18 = S: Shareable bit\n 17 = C: Cacheable bit\n 16 = B: Bufferable bit
    inline uint32_t PPB_MPU_RASR_ATTRS (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------
// Peripheral PSM: 
//------------------------------------------------------------------------------

//---  Register FRCE_ON: Force block out of reset (i.e. power it on)
  static volatile uint32_t & PSM_FRCE_ON __attribute__((unused)) = * ((volatile uint32_t *) (0x40010000 + 0)) ;

  // Field rosc: 
    const uint32_t PSM_FRCE_ON_rosc = 1U << 0 ;

  // Field xosc: 
    const uint32_t PSM_FRCE_ON_xosc = 1U << 1 ;

  // Field clocks: 
    const uint32_t PSM_FRCE_ON_clocks = 1U << 2 ;

  // Field resets: 
    const uint32_t PSM_FRCE_ON_resets = 1U << 3 ;

  // Field busfabric: 
    const uint32_t PSM_FRCE_ON_busfabric = 1U << 4 ;

  // Field rom: 
    const uint32_t PSM_FRCE_ON_rom = 1U << 5 ;

  // Field sram0: 
    const uint32_t PSM_FRCE_ON_sram0 = 1U << 6 ;

  // Field sram1: 
    const uint32_t PSM_FRCE_ON_sram1 = 1U << 7 ;

  // Field sram2: 
    const uint32_t PSM_FRCE_ON_sram2 = 1U << 8 ;

  // Field sram3: 
    const uint32_t PSM_FRCE_ON_sram3 = 1U << 9 ;

  // Field sram4: 
    const uint32_t PSM_FRCE_ON_sram4 = 1U << 10 ;

  // Field sram5: 
    const uint32_t PSM_FRCE_ON_sram5 = 1U << 11 ;

  // Field xip: 
    const uint32_t PSM_FRCE_ON_xip = 1U << 12 ;

  // Field vreg_and_chip_reset: 
    const uint32_t PSM_FRCE_ON_vreg_and_chip_reset = 1U << 13 ;

  // Field sio: 
    const uint32_t PSM_FRCE_ON_sio = 1U << 14 ;

  // Field proc0: 
    const uint32_t PSM_FRCE_ON_proc0 = 1U << 15 ;

  // Field proc1: 
    const uint32_t PSM_FRCE_ON_proc1 = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register FRCE_OFF: Force into reset (i.e. power it off)
  static volatile uint32_t & PSM_FRCE_OFF __attribute__((unused)) = * ((volatile uint32_t *) (0x40010000 + 4)) ;

  // Field rosc: 
    const uint32_t PSM_FRCE_OFF_rosc = 1U << 0 ;

  // Field xosc: 
    const uint32_t PSM_FRCE_OFF_xosc = 1U << 1 ;

  // Field clocks: 
    const uint32_t PSM_FRCE_OFF_clocks = 1U << 2 ;

  // Field resets: 
    const uint32_t PSM_FRCE_OFF_resets = 1U << 3 ;

  // Field busfabric: 
    const uint32_t PSM_FRCE_OFF_busfabric = 1U << 4 ;

  // Field rom: 
    const uint32_t PSM_FRCE_OFF_rom = 1U << 5 ;

  // Field sram0: 
    const uint32_t PSM_FRCE_OFF_sram0 = 1U << 6 ;

  // Field sram1: 
    const uint32_t PSM_FRCE_OFF_sram1 = 1U << 7 ;

  // Field sram2: 
    const uint32_t PSM_FRCE_OFF_sram2 = 1U << 8 ;

  // Field sram3: 
    const uint32_t PSM_FRCE_OFF_sram3 = 1U << 9 ;

  // Field sram4: 
    const uint32_t PSM_FRCE_OFF_sram4 = 1U << 10 ;

  // Field sram5: 
    const uint32_t PSM_FRCE_OFF_sram5 = 1U << 11 ;

  // Field xip: 
    const uint32_t PSM_FRCE_OFF_xip = 1U << 12 ;

  // Field vreg_and_chip_reset: 
    const uint32_t PSM_FRCE_OFF_vreg_and_chip_reset = 1U << 13 ;

  // Field sio: 
    const uint32_t PSM_FRCE_OFF_sio = 1U << 14 ;

  // Field proc0: 
    const uint32_t PSM_FRCE_OFF_proc0 = 1U << 15 ;

  // Field proc1: 
    const uint32_t PSM_FRCE_OFF_proc1 = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register WDSEL: Set to 1 if this peripheral should be reset when the watchdog fires.
  static volatile uint32_t & PSM_WDSEL __attribute__((unused)) = * ((volatile uint32_t *) (0x40010000 + 8)) ;

  // Field rosc: 
    const uint32_t PSM_WDSEL_rosc = 1U << 0 ;

  // Field xosc: 
    const uint32_t PSM_WDSEL_xosc = 1U << 1 ;

  // Field clocks: 
    const uint32_t PSM_WDSEL_clocks = 1U << 2 ;

  // Field resets: 
    const uint32_t PSM_WDSEL_resets = 1U << 3 ;

  // Field busfabric: 
    const uint32_t PSM_WDSEL_busfabric = 1U << 4 ;

  // Field rom: 
    const uint32_t PSM_WDSEL_rom = 1U << 5 ;

  // Field sram0: 
    const uint32_t PSM_WDSEL_sram0 = 1U << 6 ;

  // Field sram1: 
    const uint32_t PSM_WDSEL_sram1 = 1U << 7 ;

  // Field sram2: 
    const uint32_t PSM_WDSEL_sram2 = 1U << 8 ;

  // Field sram3: 
    const uint32_t PSM_WDSEL_sram3 = 1U << 9 ;

  // Field sram4: 
    const uint32_t PSM_WDSEL_sram4 = 1U << 10 ;

  // Field sram5: 
    const uint32_t PSM_WDSEL_sram5 = 1U << 11 ;

  // Field xip: 
    const uint32_t PSM_WDSEL_xip = 1U << 12 ;

  // Field vreg_and_chip_reset: 
    const uint32_t PSM_WDSEL_vreg_and_chip_reset = 1U << 13 ;

  // Field sio: 
    const uint32_t PSM_WDSEL_sio = 1U << 14 ;

  // Field proc0: 
    const uint32_t PSM_WDSEL_proc0 = 1U << 15 ;

  // Field proc1: 
    const uint32_t PSM_WDSEL_proc1 = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register DONE: Indicates the peripheral's registers are ready to access.
  static volatile uint32_t & PSM_DONE __attribute__((unused)) = * ((volatile uint32_t *) (0x40010000 + 12)) ;

  // Field rosc: 
    const uint32_t PSM_DONE_rosc = 1U << 0 ;

  // Field xosc: 
    const uint32_t PSM_DONE_xosc = 1U << 1 ;

  // Field clocks: 
    const uint32_t PSM_DONE_clocks = 1U << 2 ;

  // Field resets: 
    const uint32_t PSM_DONE_resets = 1U << 3 ;

  // Field busfabric: 
    const uint32_t PSM_DONE_busfabric = 1U << 4 ;

  // Field rom: 
    const uint32_t PSM_DONE_rom = 1U << 5 ;

  // Field sram0: 
    const uint32_t PSM_DONE_sram0 = 1U << 6 ;

  // Field sram1: 
    const uint32_t PSM_DONE_sram1 = 1U << 7 ;

  // Field sram2: 
    const uint32_t PSM_DONE_sram2 = 1U << 8 ;

  // Field sram3: 
    const uint32_t PSM_DONE_sram3 = 1U << 9 ;

  // Field sram4: 
    const uint32_t PSM_DONE_sram4 = 1U << 10 ;

  // Field sram5: 
    const uint32_t PSM_DONE_sram5 = 1U << 11 ;

  // Field xip: 
    const uint32_t PSM_DONE_xip = 1U << 12 ;

  // Field vreg_and_chip_reset: 
    const uint32_t PSM_DONE_vreg_and_chip_reset = 1U << 13 ;

  // Field sio: 
    const uint32_t PSM_DONE_sio = 1U << 14 ;

  // Field proc0: 
    const uint32_t PSM_DONE_proc0 = 1U << 15 ;

  // Field proc1: 
    const uint32_t PSM_DONE_proc1 = 1U << 16 ;

//------------------------------------------------------------------------------
// Peripheral PWM: Simple PWM
//------------------------------------------------------------------------------

//---  Register CH0_CSR: Control and status register
  static volatile uint32_t & PWM_CH0_CSR __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 0)) ;

  // Field EN: Enable the PWM channel.
    const uint32_t PWM_CH0_CSR_EN = 1U << 0 ;

  // Field PH_CORRECT: 1: Enable phase-correct modulation. 0: Trailing-edge
    const uint32_t PWM_CH0_CSR_PH_CORRECT = 1U << 1 ;

  // Field A_INV: Invert output A
    const uint32_t PWM_CH0_CSR_A_INV = 1U << 2 ;

  // Field B_INV: Invert output B
    const uint32_t PWM_CH0_CSR_B_INV = 1U << 3 ;

  // Field DIVMODE: 
    inline uint32_t PWM_CH0_CSR_DIVMODE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field PH_RET: Retard the phase of the counter by 1 count, while it is running.\n Self-clearing. Write a 1, and poll until low. Counter must be running.
    const uint32_t PWM_CH0_CSR_PH_RET = 1U << 6 ;

  // Field PH_ADV: Advance the phase of the counter by 1 count, while it is running.\n Self-clearing. Write a 1, and poll until low. Counter must be running\n at less than full speed (div_int + div_frac / 16 > 1)
    const uint32_t PWM_CH0_CSR_PH_ADV = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register CH0_DIV: INT and FRAC form a fixed-point fractional number.\n Counting rate is system clock frequency divided by this number.\n Fractional division uses simple 1st-order sigma-delta.
  static volatile uint32_t & PWM_CH0_DIV __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 4)) ;

  // Field FRAC: 
    inline uint32_t PWM_CH0_DIV_FRAC (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field INT: 
    inline uint32_t PWM_CH0_DIV_INT (const uint32_t inValue) {return (inValue & 0xFFU) << 4 ; }

//------------------------------------------------------------------------------

//---  Register CH0_CTR: Direct access to the PWM counter
  static volatile uint32_t & PWM_CH0_CTR __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 8)) ;

  // Field CH0_CTR: 
    inline uint32_t PWM_CH0_CTR_CH0_CTR (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CH0_CC: Counter compare values
  static volatile uint32_t & PWM_CH0_CC __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 12)) ;

  // Field A: 
    inline uint32_t PWM_CH0_CC_A (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field B: 
    inline uint32_t PWM_CH0_CC_B (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register CH0_TOP: Counter wrap value
  static volatile uint32_t & PWM_CH0_TOP __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 16)) ;

  // Field CH0_TOP: 
    inline uint32_t PWM_CH0_TOP_CH0_TOP (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CH1_CSR: Control and status register
  static volatile uint32_t & PWM_CH1_CSR __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 20)) ;

  // Field EN: Enable the PWM channel.
    const uint32_t PWM_CH1_CSR_EN = 1U << 0 ;

  // Field PH_CORRECT: 1: Enable phase-correct modulation. 0: Trailing-edge
    const uint32_t PWM_CH1_CSR_PH_CORRECT = 1U << 1 ;

  // Field A_INV: Invert output A
    const uint32_t PWM_CH1_CSR_A_INV = 1U << 2 ;

  // Field B_INV: Invert output B
    const uint32_t PWM_CH1_CSR_B_INV = 1U << 3 ;

  // Field DIVMODE: 
    inline uint32_t PWM_CH1_CSR_DIVMODE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field PH_RET: Retard the phase of the counter by 1 count, while it is running.\n Self-clearing. Write a 1, and poll until low. Counter must be running.
    const uint32_t PWM_CH1_CSR_PH_RET = 1U << 6 ;

  // Field PH_ADV: Advance the phase of the counter by 1 count, while it is running.\n Self-clearing. Write a 1, and poll until low. Counter must be running\n at less than full speed (div_int + div_frac / 16 > 1)
    const uint32_t PWM_CH1_CSR_PH_ADV = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register CH1_DIV: INT and FRAC form a fixed-point fractional number.\n Counting rate is system clock frequency divided by this number.\n Fractional division uses simple 1st-order sigma-delta.
  static volatile uint32_t & PWM_CH1_DIV __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 24)) ;

  // Field FRAC: 
    inline uint32_t PWM_CH1_DIV_FRAC (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field INT: 
    inline uint32_t PWM_CH1_DIV_INT (const uint32_t inValue) {return (inValue & 0xFFU) << 4 ; }

//------------------------------------------------------------------------------

//---  Register CH1_CTR: Direct access to the PWM counter
  static volatile uint32_t & PWM_CH1_CTR __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 28)) ;

  // Field CH1_CTR: 
    inline uint32_t PWM_CH1_CTR_CH1_CTR (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CH1_CC: Counter compare values
  static volatile uint32_t & PWM_CH1_CC __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 32)) ;

  // Field A: 
    inline uint32_t PWM_CH1_CC_A (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field B: 
    inline uint32_t PWM_CH1_CC_B (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register CH1_TOP: Counter wrap value
  static volatile uint32_t & PWM_CH1_TOP __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 36)) ;

  // Field CH1_TOP: 
    inline uint32_t PWM_CH1_TOP_CH1_TOP (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CH2_CSR: Control and status register
  static volatile uint32_t & PWM_CH2_CSR __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 40)) ;

  // Field EN: Enable the PWM channel.
    const uint32_t PWM_CH2_CSR_EN = 1U << 0 ;

  // Field PH_CORRECT: 1: Enable phase-correct modulation. 0: Trailing-edge
    const uint32_t PWM_CH2_CSR_PH_CORRECT = 1U << 1 ;

  // Field A_INV: Invert output A
    const uint32_t PWM_CH2_CSR_A_INV = 1U << 2 ;

  // Field B_INV: Invert output B
    const uint32_t PWM_CH2_CSR_B_INV = 1U << 3 ;

  // Field DIVMODE: 
    inline uint32_t PWM_CH2_CSR_DIVMODE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field PH_RET: Retard the phase of the counter by 1 count, while it is running.\n Self-clearing. Write a 1, and poll until low. Counter must be running.
    const uint32_t PWM_CH2_CSR_PH_RET = 1U << 6 ;

  // Field PH_ADV: Advance the phase of the counter by 1 count, while it is running.\n Self-clearing. Write a 1, and poll until low. Counter must be running\n at less than full speed (div_int + div_frac / 16 > 1)
    const uint32_t PWM_CH2_CSR_PH_ADV = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register CH2_DIV: INT and FRAC form a fixed-point fractional number.\n Counting rate is system clock frequency divided by this number.\n Fractional division uses simple 1st-order sigma-delta.
  static volatile uint32_t & PWM_CH2_DIV __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 44)) ;

  // Field FRAC: 
    inline uint32_t PWM_CH2_DIV_FRAC (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field INT: 
    inline uint32_t PWM_CH2_DIV_INT (const uint32_t inValue) {return (inValue & 0xFFU) << 4 ; }

//------------------------------------------------------------------------------

//---  Register CH2_CTR: Direct access to the PWM counter
  static volatile uint32_t & PWM_CH2_CTR __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 48)) ;

  // Field CH2_CTR: 
    inline uint32_t PWM_CH2_CTR_CH2_CTR (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CH2_CC: Counter compare values
  static volatile uint32_t & PWM_CH2_CC __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 52)) ;

  // Field A: 
    inline uint32_t PWM_CH2_CC_A (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field B: 
    inline uint32_t PWM_CH2_CC_B (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register CH2_TOP: Counter wrap value
  static volatile uint32_t & PWM_CH2_TOP __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 56)) ;

  // Field CH2_TOP: 
    inline uint32_t PWM_CH2_TOP_CH2_TOP (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CH3_CSR: Control and status register
  static volatile uint32_t & PWM_CH3_CSR __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 60)) ;

  // Field EN: Enable the PWM channel.
    const uint32_t PWM_CH3_CSR_EN = 1U << 0 ;

  // Field PH_CORRECT: 1: Enable phase-correct modulation. 0: Trailing-edge
    const uint32_t PWM_CH3_CSR_PH_CORRECT = 1U << 1 ;

  // Field A_INV: Invert output A
    const uint32_t PWM_CH3_CSR_A_INV = 1U << 2 ;

  // Field B_INV: Invert output B
    const uint32_t PWM_CH3_CSR_B_INV = 1U << 3 ;

  // Field DIVMODE: 
    inline uint32_t PWM_CH3_CSR_DIVMODE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field PH_RET: Retard the phase of the counter by 1 count, while it is running.\n Self-clearing. Write a 1, and poll until low. Counter must be running.
    const uint32_t PWM_CH3_CSR_PH_RET = 1U << 6 ;

  // Field PH_ADV: Advance the phase of the counter by 1 count, while it is running.\n Self-clearing. Write a 1, and poll until low. Counter must be running\n at less than full speed (div_int + div_frac / 16 > 1)
    const uint32_t PWM_CH3_CSR_PH_ADV = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register CH3_DIV: INT and FRAC form a fixed-point fractional number.\n Counting rate is system clock frequency divided by this number.\n Fractional division uses simple 1st-order sigma-delta.
  static volatile uint32_t & PWM_CH3_DIV __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 64)) ;

  // Field FRAC: 
    inline uint32_t PWM_CH3_DIV_FRAC (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field INT: 
    inline uint32_t PWM_CH3_DIV_INT (const uint32_t inValue) {return (inValue & 0xFFU) << 4 ; }

//------------------------------------------------------------------------------

//---  Register CH3_CTR: Direct access to the PWM counter
  static volatile uint32_t & PWM_CH3_CTR __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 68)) ;

  // Field CH3_CTR: 
    inline uint32_t PWM_CH3_CTR_CH3_CTR (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CH3_CC: Counter compare values
  static volatile uint32_t & PWM_CH3_CC __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 72)) ;

  // Field A: 
    inline uint32_t PWM_CH3_CC_A (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field B: 
    inline uint32_t PWM_CH3_CC_B (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register CH3_TOP: Counter wrap value
  static volatile uint32_t & PWM_CH3_TOP __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 76)) ;

  // Field CH3_TOP: 
    inline uint32_t PWM_CH3_TOP_CH3_TOP (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CH4_CSR: Control and status register
  static volatile uint32_t & PWM_CH4_CSR __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 80)) ;

  // Field EN: Enable the PWM channel.
    const uint32_t PWM_CH4_CSR_EN = 1U << 0 ;

  // Field PH_CORRECT: 1: Enable phase-correct modulation. 0: Trailing-edge
    const uint32_t PWM_CH4_CSR_PH_CORRECT = 1U << 1 ;

  // Field A_INV: Invert output A
    const uint32_t PWM_CH4_CSR_A_INV = 1U << 2 ;

  // Field B_INV: Invert output B
    const uint32_t PWM_CH4_CSR_B_INV = 1U << 3 ;

  // Field DIVMODE: 
    inline uint32_t PWM_CH4_CSR_DIVMODE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field PH_RET: Retard the phase of the counter by 1 count, while it is running.\n Self-clearing. Write a 1, and poll until low. Counter must be running.
    const uint32_t PWM_CH4_CSR_PH_RET = 1U << 6 ;

  // Field PH_ADV: Advance the phase of the counter by 1 count, while it is running.\n Self-clearing. Write a 1, and poll until low. Counter must be running\n at less than full speed (div_int + div_frac / 16 > 1)
    const uint32_t PWM_CH4_CSR_PH_ADV = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register CH4_DIV: INT and FRAC form a fixed-point fractional number.\n Counting rate is system clock frequency divided by this number.\n Fractional division uses simple 1st-order sigma-delta.
  static volatile uint32_t & PWM_CH4_DIV __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 84)) ;

  // Field FRAC: 
    inline uint32_t PWM_CH4_DIV_FRAC (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field INT: 
    inline uint32_t PWM_CH4_DIV_INT (const uint32_t inValue) {return (inValue & 0xFFU) << 4 ; }

//------------------------------------------------------------------------------

//---  Register CH4_CTR: Direct access to the PWM counter
  static volatile uint32_t & PWM_CH4_CTR __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 88)) ;

  // Field CH4_CTR: 
    inline uint32_t PWM_CH4_CTR_CH4_CTR (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CH4_CC: Counter compare values
  static volatile uint32_t & PWM_CH4_CC __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 92)) ;

  // Field A: 
    inline uint32_t PWM_CH4_CC_A (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field B: 
    inline uint32_t PWM_CH4_CC_B (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register CH4_TOP: Counter wrap value
  static volatile uint32_t & PWM_CH4_TOP __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 96)) ;

  // Field CH4_TOP: 
    inline uint32_t PWM_CH4_TOP_CH4_TOP (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CH5_CSR: Control and status register
  static volatile uint32_t & PWM_CH5_CSR __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 100)) ;

  // Field EN: Enable the PWM channel.
    const uint32_t PWM_CH5_CSR_EN = 1U << 0 ;

  // Field PH_CORRECT: 1: Enable phase-correct modulation. 0: Trailing-edge
    const uint32_t PWM_CH5_CSR_PH_CORRECT = 1U << 1 ;

  // Field A_INV: Invert output A
    const uint32_t PWM_CH5_CSR_A_INV = 1U << 2 ;

  // Field B_INV: Invert output B
    const uint32_t PWM_CH5_CSR_B_INV = 1U << 3 ;

  // Field DIVMODE: 
    inline uint32_t PWM_CH5_CSR_DIVMODE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field PH_RET: Retard the phase of the counter by 1 count, while it is running.\n Self-clearing. Write a 1, and poll until low. Counter must be running.
    const uint32_t PWM_CH5_CSR_PH_RET = 1U << 6 ;

  // Field PH_ADV: Advance the phase of the counter by 1 count, while it is running.\n Self-clearing. Write a 1, and poll until low. Counter must be running\n at less than full speed (div_int + div_frac / 16 > 1)
    const uint32_t PWM_CH5_CSR_PH_ADV = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register CH5_DIV: INT and FRAC form a fixed-point fractional number.\n Counting rate is system clock frequency divided by this number.\n Fractional division uses simple 1st-order sigma-delta.
  static volatile uint32_t & PWM_CH5_DIV __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 104)) ;

  // Field FRAC: 
    inline uint32_t PWM_CH5_DIV_FRAC (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field INT: 
    inline uint32_t PWM_CH5_DIV_INT (const uint32_t inValue) {return (inValue & 0xFFU) << 4 ; }

//------------------------------------------------------------------------------

//---  Register CH5_CTR: Direct access to the PWM counter
  static volatile uint32_t & PWM_CH5_CTR __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 108)) ;

  // Field CH5_CTR: 
    inline uint32_t PWM_CH5_CTR_CH5_CTR (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CH5_CC: Counter compare values
  static volatile uint32_t & PWM_CH5_CC __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 112)) ;

  // Field A: 
    inline uint32_t PWM_CH5_CC_A (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field B: 
    inline uint32_t PWM_CH5_CC_B (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register CH5_TOP: Counter wrap value
  static volatile uint32_t & PWM_CH5_TOP __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 116)) ;

  // Field CH5_TOP: 
    inline uint32_t PWM_CH5_TOP_CH5_TOP (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CH6_CSR: Control and status register
  static volatile uint32_t & PWM_CH6_CSR __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 120)) ;

  // Field EN: Enable the PWM channel.
    const uint32_t PWM_CH6_CSR_EN = 1U << 0 ;

  // Field PH_CORRECT: 1: Enable phase-correct modulation. 0: Trailing-edge
    const uint32_t PWM_CH6_CSR_PH_CORRECT = 1U << 1 ;

  // Field A_INV: Invert output A
    const uint32_t PWM_CH6_CSR_A_INV = 1U << 2 ;

  // Field B_INV: Invert output B
    const uint32_t PWM_CH6_CSR_B_INV = 1U << 3 ;

  // Field DIVMODE: 
    inline uint32_t PWM_CH6_CSR_DIVMODE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field PH_RET: Retard the phase of the counter by 1 count, while it is running.\n Self-clearing. Write a 1, and poll until low. Counter must be running.
    const uint32_t PWM_CH6_CSR_PH_RET = 1U << 6 ;

  // Field PH_ADV: Advance the phase of the counter by 1 count, while it is running.\n Self-clearing. Write a 1, and poll until low. Counter must be running\n at less than full speed (div_int + div_frac / 16 > 1)
    const uint32_t PWM_CH6_CSR_PH_ADV = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register CH6_DIV: INT and FRAC form a fixed-point fractional number.\n Counting rate is system clock frequency divided by this number.\n Fractional division uses simple 1st-order sigma-delta.
  static volatile uint32_t & PWM_CH6_DIV __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 124)) ;

  // Field FRAC: 
    inline uint32_t PWM_CH6_DIV_FRAC (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field INT: 
    inline uint32_t PWM_CH6_DIV_INT (const uint32_t inValue) {return (inValue & 0xFFU) << 4 ; }

//------------------------------------------------------------------------------

//---  Register CH6_CTR: Direct access to the PWM counter
  static volatile uint32_t & PWM_CH6_CTR __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 128)) ;

  // Field CH6_CTR: 
    inline uint32_t PWM_CH6_CTR_CH6_CTR (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CH6_CC: Counter compare values
  static volatile uint32_t & PWM_CH6_CC __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 132)) ;

  // Field A: 
    inline uint32_t PWM_CH6_CC_A (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field B: 
    inline uint32_t PWM_CH6_CC_B (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register CH6_TOP: Counter wrap value
  static volatile uint32_t & PWM_CH6_TOP __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 136)) ;

  // Field CH6_TOP: 
    inline uint32_t PWM_CH6_TOP_CH6_TOP (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CH7_CSR: Control and status register
  static volatile uint32_t & PWM_CH7_CSR __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 140)) ;

  // Field EN: Enable the PWM channel.
    const uint32_t PWM_CH7_CSR_EN = 1U << 0 ;

  // Field PH_CORRECT: 1: Enable phase-correct modulation. 0: Trailing-edge
    const uint32_t PWM_CH7_CSR_PH_CORRECT = 1U << 1 ;

  // Field A_INV: Invert output A
    const uint32_t PWM_CH7_CSR_A_INV = 1U << 2 ;

  // Field B_INV: Invert output B
    const uint32_t PWM_CH7_CSR_B_INV = 1U << 3 ;

  // Field DIVMODE: 
    inline uint32_t PWM_CH7_CSR_DIVMODE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field PH_RET: Retard the phase of the counter by 1 count, while it is running.\n Self-clearing. Write a 1, and poll until low. Counter must be running.
    const uint32_t PWM_CH7_CSR_PH_RET = 1U << 6 ;

  // Field PH_ADV: Advance the phase of the counter by 1 count, while it is running.\n Self-clearing. Write a 1, and poll until low. Counter must be running\n at less than full speed (div_int + div_frac / 16 > 1)
    const uint32_t PWM_CH7_CSR_PH_ADV = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register CH7_DIV: INT and FRAC form a fixed-point fractional number.\n Counting rate is system clock frequency divided by this number.\n Fractional division uses simple 1st-order sigma-delta.
  static volatile uint32_t & PWM_CH7_DIV __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 144)) ;

  // Field FRAC: 
    inline uint32_t PWM_CH7_DIV_FRAC (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field INT: 
    inline uint32_t PWM_CH7_DIV_INT (const uint32_t inValue) {return (inValue & 0xFFU) << 4 ; }

//------------------------------------------------------------------------------

//---  Register CH7_CTR: Direct access to the PWM counter
  static volatile uint32_t & PWM_CH7_CTR __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 148)) ;

  // Field CH7_CTR: 
    inline uint32_t PWM_CH7_CTR_CH7_CTR (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CH7_CC: Counter compare values
  static volatile uint32_t & PWM_CH7_CC __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 152)) ;

  // Field A: 
    inline uint32_t PWM_CH7_CC_A (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field B: 
    inline uint32_t PWM_CH7_CC_B (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register CH7_TOP: Counter wrap value
  static volatile uint32_t & PWM_CH7_TOP __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 156)) ;

  // Field CH7_TOP: 
    inline uint32_t PWM_CH7_TOP_CH7_TOP (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register EN: This register aliases the CSR_EN bits for all channels.\n Writing to this register allows multiple channels to be enabled\n or disabled simultaneously, so they can run in perfect sync.\n For each channel, there is only one physical EN register bit,\n which can be accessed through here or CHx_CSR.
  static volatile uint32_t & PWM_EN __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 160)) ;

  // Field CH0: 
    const uint32_t PWM_EN_CH0 = 1U << 0 ;

  // Field CH1: 
    const uint32_t PWM_EN_CH1 = 1U << 1 ;

  // Field CH2: 
    const uint32_t PWM_EN_CH2 = 1U << 2 ;

  // Field CH3: 
    const uint32_t PWM_EN_CH3 = 1U << 3 ;

  // Field CH4: 
    const uint32_t PWM_EN_CH4 = 1U << 4 ;

  // Field CH5: 
    const uint32_t PWM_EN_CH5 = 1U << 5 ;

  // Field CH6: 
    const uint32_t PWM_EN_CH6 = 1U << 6 ;

  // Field CH7: 
    const uint32_t PWM_EN_CH7 = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register INTR: Raw Interrupts
  static volatile uint32_t & PWM_INTR __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 164)) ;

  // Field CH0: 
    const uint32_t PWM_INTR_CH0 = 1U << 0 ;

  // Field CH1: 
    const uint32_t PWM_INTR_CH1 = 1U << 1 ;

  // Field CH2: 
    const uint32_t PWM_INTR_CH2 = 1U << 2 ;

  // Field CH3: 
    const uint32_t PWM_INTR_CH3 = 1U << 3 ;

  // Field CH4: 
    const uint32_t PWM_INTR_CH4 = 1U << 4 ;

  // Field CH5: 
    const uint32_t PWM_INTR_CH5 = 1U << 5 ;

  // Field CH6: 
    const uint32_t PWM_INTR_CH6 = 1U << 6 ;

  // Field CH7: 
    const uint32_t PWM_INTR_CH7 = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register INTE: Interrupt Enable
  static volatile uint32_t & PWM_INTE __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 168)) ;

  // Field CH0: 
    const uint32_t PWM_INTE_CH0 = 1U << 0 ;

  // Field CH1: 
    const uint32_t PWM_INTE_CH1 = 1U << 1 ;

  // Field CH2: 
    const uint32_t PWM_INTE_CH2 = 1U << 2 ;

  // Field CH3: 
    const uint32_t PWM_INTE_CH3 = 1U << 3 ;

  // Field CH4: 
    const uint32_t PWM_INTE_CH4 = 1U << 4 ;

  // Field CH5: 
    const uint32_t PWM_INTE_CH5 = 1U << 5 ;

  // Field CH6: 
    const uint32_t PWM_INTE_CH6 = 1U << 6 ;

  // Field CH7: 
    const uint32_t PWM_INTE_CH7 = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register INTF: Interrupt Force
  static volatile uint32_t & PWM_INTF __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 172)) ;

  // Field CH0: 
    const uint32_t PWM_INTF_CH0 = 1U << 0 ;

  // Field CH1: 
    const uint32_t PWM_INTF_CH1 = 1U << 1 ;

  // Field CH2: 
    const uint32_t PWM_INTF_CH2 = 1U << 2 ;

  // Field CH3: 
    const uint32_t PWM_INTF_CH3 = 1U << 3 ;

  // Field CH4: 
    const uint32_t PWM_INTF_CH4 = 1U << 4 ;

  // Field CH5: 
    const uint32_t PWM_INTF_CH5 = 1U << 5 ;

  // Field CH6: 
    const uint32_t PWM_INTF_CH6 = 1U << 6 ;

  // Field CH7: 
    const uint32_t PWM_INTF_CH7 = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register INTS: Interrupt status after masking & forcing
  static volatile uint32_t & PWM_INTS __attribute__((unused)) = * ((volatile uint32_t *) (0x40050000 + 176)) ;

  // Field CH0: 
    const uint32_t PWM_INTS_CH0 = 1U << 0 ;

  // Field CH1: 
    const uint32_t PWM_INTS_CH1 = 1U << 1 ;

  // Field CH2: 
    const uint32_t PWM_INTS_CH2 = 1U << 2 ;

  // Field CH3: 
    const uint32_t PWM_INTS_CH3 = 1U << 3 ;

  // Field CH4: 
    const uint32_t PWM_INTS_CH4 = 1U << 4 ;

  // Field CH5: 
    const uint32_t PWM_INTS_CH5 = 1U << 5 ;

  // Field CH6: 
    const uint32_t PWM_INTS_CH6 = 1U << 6 ;

  // Field CH7: 
    const uint32_t PWM_INTS_CH7 = 1U << 7 ;

//------------------------------------------------------------------------------
// Peripheral RESETS: 
//------------------------------------------------------------------------------

//---  Register RESET: Reset control. If a bit is set it means the peripheral is in reset. 0 means the peripheral's reset is deasserted.
  static volatile uint32_t & RESETS_RESET __attribute__((unused)) = * ((volatile uint32_t *) (0x4000C000 + 0)) ;

  // Field adc: 
    const uint32_t RESETS_RESET_adc = 1U << 0 ;

  // Field busctrl: 
    const uint32_t RESETS_RESET_busctrl = 1U << 1 ;

  // Field dma: 
    const uint32_t RESETS_RESET_dma = 1U << 2 ;

  // Field i2c0: 
    const uint32_t RESETS_RESET_i2c0 = 1U << 3 ;

  // Field i2c1: 
    const uint32_t RESETS_RESET_i2c1 = 1U << 4 ;

  // Field io_bank0: 
    const uint32_t RESETS_RESET_io_bank0 = 1U << 5 ;

  // Field io_qspi: 
    const uint32_t RESETS_RESET_io_qspi = 1U << 6 ;

  // Field jtag: 
    const uint32_t RESETS_RESET_jtag = 1U << 7 ;

  // Field pads_bank0: 
    const uint32_t RESETS_RESET_pads_bank0 = 1U << 8 ;

  // Field pads_qspi: 
    const uint32_t RESETS_RESET_pads_qspi = 1U << 9 ;

  // Field pio0: 
    const uint32_t RESETS_RESET_pio0 = 1U << 10 ;

  // Field pio1: 
    const uint32_t RESETS_RESET_pio1 = 1U << 11 ;

  // Field pll_sys: 
    const uint32_t RESETS_RESET_pll_sys = 1U << 12 ;

  // Field pll_usb: 
    const uint32_t RESETS_RESET_pll_usb = 1U << 13 ;

  // Field pwm: 
    const uint32_t RESETS_RESET_pwm = 1U << 14 ;

  // Field rtc: 
    const uint32_t RESETS_RESET_rtc = 1U << 15 ;

  // Field spi0: 
    const uint32_t RESETS_RESET_spi0 = 1U << 16 ;

  // Field spi1: 
    const uint32_t RESETS_RESET_spi1 = 1U << 17 ;

  // Field syscfg: 
    const uint32_t RESETS_RESET_syscfg = 1U << 18 ;

  // Field sysinfo: 
    const uint32_t RESETS_RESET_sysinfo = 1U << 19 ;

  // Field tbman: 
    const uint32_t RESETS_RESET_tbman = 1U << 20 ;

  // Field timer: 
    const uint32_t RESETS_RESET_timer = 1U << 21 ;

  // Field uart0: 
    const uint32_t RESETS_RESET_uart0 = 1U << 22 ;

  // Field uart1: 
    const uint32_t RESETS_RESET_uart1 = 1U << 23 ;

  // Field usbctrl: 
    const uint32_t RESETS_RESET_usbctrl = 1U << 24 ;

//------------------------------------------------------------------------------

//---  Register WDSEL: Watchdog select. If a bit is set then the watchdog will reset this peripheral when the watchdog fires.
  static volatile uint32_t & RESETS_WDSEL __attribute__((unused)) = * ((volatile uint32_t *) (0x4000C000 + 4)) ;

  // Field adc: 
    const uint32_t RESETS_WDSEL_adc = 1U << 0 ;

  // Field busctrl: 
    const uint32_t RESETS_WDSEL_busctrl = 1U << 1 ;

  // Field dma: 
    const uint32_t RESETS_WDSEL_dma = 1U << 2 ;

  // Field i2c0: 
    const uint32_t RESETS_WDSEL_i2c0 = 1U << 3 ;

  // Field i2c1: 
    const uint32_t RESETS_WDSEL_i2c1 = 1U << 4 ;

  // Field io_bank0: 
    const uint32_t RESETS_WDSEL_io_bank0 = 1U << 5 ;

  // Field io_qspi: 
    const uint32_t RESETS_WDSEL_io_qspi = 1U << 6 ;

  // Field jtag: 
    const uint32_t RESETS_WDSEL_jtag = 1U << 7 ;

  // Field pads_bank0: 
    const uint32_t RESETS_WDSEL_pads_bank0 = 1U << 8 ;

  // Field pads_qspi: 
    const uint32_t RESETS_WDSEL_pads_qspi = 1U << 9 ;

  // Field pio0: 
    const uint32_t RESETS_WDSEL_pio0 = 1U << 10 ;

  // Field pio1: 
    const uint32_t RESETS_WDSEL_pio1 = 1U << 11 ;

  // Field pll_sys: 
    const uint32_t RESETS_WDSEL_pll_sys = 1U << 12 ;

  // Field pll_usb: 
    const uint32_t RESETS_WDSEL_pll_usb = 1U << 13 ;

  // Field pwm: 
    const uint32_t RESETS_WDSEL_pwm = 1U << 14 ;

  // Field rtc: 
    const uint32_t RESETS_WDSEL_rtc = 1U << 15 ;

  // Field spi0: 
    const uint32_t RESETS_WDSEL_spi0 = 1U << 16 ;

  // Field spi1: 
    const uint32_t RESETS_WDSEL_spi1 = 1U << 17 ;

  // Field syscfg: 
    const uint32_t RESETS_WDSEL_syscfg = 1U << 18 ;

  // Field sysinfo: 
    const uint32_t RESETS_WDSEL_sysinfo = 1U << 19 ;

  // Field tbman: 
    const uint32_t RESETS_WDSEL_tbman = 1U << 20 ;

  // Field timer: 
    const uint32_t RESETS_WDSEL_timer = 1U << 21 ;

  // Field uart0: 
    const uint32_t RESETS_WDSEL_uart0 = 1U << 22 ;

  // Field uart1: 
    const uint32_t RESETS_WDSEL_uart1 = 1U << 23 ;

  // Field usbctrl: 
    const uint32_t RESETS_WDSEL_usbctrl = 1U << 24 ;

//------------------------------------------------------------------------------

//---  Register RESET_DONE: Reset done. If a bit is set then a reset done signal has been returned by the peripheral. This indicates that the peripheral's registers are ready to be accessed.
  static volatile uint32_t & RESETS_RESET_DONE __attribute__((unused)) = * ((volatile uint32_t *) (0x4000C000 + 8)) ;

  // Field adc: 
    const uint32_t RESETS_RESET_DONE_adc = 1U << 0 ;

  // Field busctrl: 
    const uint32_t RESETS_RESET_DONE_busctrl = 1U << 1 ;

  // Field dma: 
    const uint32_t RESETS_RESET_DONE_dma = 1U << 2 ;

  // Field i2c0: 
    const uint32_t RESETS_RESET_DONE_i2c0 = 1U << 3 ;

  // Field i2c1: 
    const uint32_t RESETS_RESET_DONE_i2c1 = 1U << 4 ;

  // Field io_bank0: 
    const uint32_t RESETS_RESET_DONE_io_bank0 = 1U << 5 ;

  // Field io_qspi: 
    const uint32_t RESETS_RESET_DONE_io_qspi = 1U << 6 ;

  // Field jtag: 
    const uint32_t RESETS_RESET_DONE_jtag = 1U << 7 ;

  // Field pads_bank0: 
    const uint32_t RESETS_RESET_DONE_pads_bank0 = 1U << 8 ;

  // Field pads_qspi: 
    const uint32_t RESETS_RESET_DONE_pads_qspi = 1U << 9 ;

  // Field pio0: 
    const uint32_t RESETS_RESET_DONE_pio0 = 1U << 10 ;

  // Field pio1: 
    const uint32_t RESETS_RESET_DONE_pio1 = 1U << 11 ;

  // Field pll_sys: 
    const uint32_t RESETS_RESET_DONE_pll_sys = 1U << 12 ;

  // Field pll_usb: 
    const uint32_t RESETS_RESET_DONE_pll_usb = 1U << 13 ;

  // Field pwm: 
    const uint32_t RESETS_RESET_DONE_pwm = 1U << 14 ;

  // Field rtc: 
    const uint32_t RESETS_RESET_DONE_rtc = 1U << 15 ;

  // Field spi0: 
    const uint32_t RESETS_RESET_DONE_spi0 = 1U << 16 ;

  // Field spi1: 
    const uint32_t RESETS_RESET_DONE_spi1 = 1U << 17 ;

  // Field syscfg: 
    const uint32_t RESETS_RESET_DONE_syscfg = 1U << 18 ;

  // Field sysinfo: 
    const uint32_t RESETS_RESET_DONE_sysinfo = 1U << 19 ;

  // Field tbman: 
    const uint32_t RESETS_RESET_DONE_tbman = 1U << 20 ;

  // Field timer: 
    const uint32_t RESETS_RESET_DONE_timer = 1U << 21 ;

  // Field uart0: 
    const uint32_t RESETS_RESET_DONE_uart0 = 1U << 22 ;

  // Field uart1: 
    const uint32_t RESETS_RESET_DONE_uart1 = 1U << 23 ;

  // Field usbctrl: 
    const uint32_t RESETS_RESET_DONE_usbctrl = 1U << 24 ;

//------------------------------------------------------------------------------
// Peripheral ROSC: 
//------------------------------------------------------------------------------

//---  Register CTRL: Ring Oscillator control
  static volatile uint32_t & ROSC_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40060000 + 0)) ;

  // Field FREQ_RANGE: Controls the number of delay stages in the ROSC ring\n LOW uses stages 0 to 7\n MEDIUM uses stages 0 to 5\n HIGH uses stages 0 to 3\n TOOHIGH uses stages 0 to 1 and should not be used because its frequency exceeds design specifications\n The clock output will not glitch when changing the range up one step at a time\n The clock output will glitch when changing the range down\n Note: the values here are gray coded which is why HIGH comes before TOOHIGH
    inline uint32_t ROSC_CTRL_FREQ_RANGE (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

  // Field ENABLE: On power-up this field is initialised to ENABLE\n The system clock must be switched to another source before setting this field to DISABLE otherwise the chip will lock up\n The 12-bit code is intended to give some protection against accidental writes. An invalid setting will enable the oscillator.
    inline uint32_t ROSC_CTRL_ENABLE (const uint32_t inValue) {return (inValue & 0xFFFU) << 12 ; }

//------------------------------------------------------------------------------

//---  Register FREQA: The FREQA & FREQB registers control the frequency by controlling the drive strength of each stage\n The drive strength has 4 levels determined by the number of bits set\n Increasing the number of bits set increases the drive strength and increases the oscillation frequency\n 0 bits set is the default drive strength\n 1 bit set doubles the drive strength\n 2 bits set triples drive strength\n 3 bits set quadruples drive strength
  static volatile uint32_t & ROSC_FREQA __attribute__((unused)) = * ((volatile uint32_t *) (0x40060000 + 4)) ;

  // Field DS0: Stage 0 drive strength
    inline uint32_t ROSC_FREQA_DS0 (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field DS1: Stage 1 drive strength
    inline uint32_t ROSC_FREQA_DS1 (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field DS2: Stage 2 drive strength
    inline uint32_t ROSC_FREQA_DS2 (const uint32_t inValue) {return (inValue & 0x7U) << 8 ; }

  // Field DS3: Stage 3 drive strength
    inline uint32_t ROSC_FREQA_DS3 (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field PASSWD: Set to 0x9696 to apply the settings\n Any other value in this field will set all drive strengths to 0
    inline uint32_t ROSC_FREQA_PASSWD (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register FREQB: For a detailed description see freqa register
  static volatile uint32_t & ROSC_FREQB __attribute__((unused)) = * ((volatile uint32_t *) (0x40060000 + 8)) ;

  // Field DS4: Stage 4 drive strength
    inline uint32_t ROSC_FREQB_DS4 (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field DS5: Stage 5 drive strength
    inline uint32_t ROSC_FREQB_DS5 (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field DS6: Stage 6 drive strength
    inline uint32_t ROSC_FREQB_DS6 (const uint32_t inValue) {return (inValue & 0x7U) << 8 ; }

  // Field DS7: Stage 7 drive strength
    inline uint32_t ROSC_FREQB_DS7 (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field PASSWD: Set to 0x9696 to apply the settings\n Any other value in this field will set all drive strengths to 0
    inline uint32_t ROSC_FREQB_PASSWD (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register DORMANT: Ring Oscillator pause control\n This is used to save power by pausing the ROSC\n On power-up this field is initialised to WAKE\n An invalid write will also select WAKE\n Warning: setup the irq before selecting dormant mode
  static volatile uint32_t & ROSC_DORMANT __attribute__((unused)) = * ((volatile uint32_t *) (0x40060000 + 12)) ;

//------------------------------------------------------------------------------

//---  Register DIV: Controls the output divider
  static volatile uint32_t & ROSC_DIV __attribute__((unused)) = * ((volatile uint32_t *) (0x40060000 + 16)) ;

  // Field DIV: set to 0xaa0 + div where\n div = 0 divides by 32\n div = 1-31 divides by div\n any other value sets div=0 and therefore divides by 32\n this register resets to div=16
    inline uint32_t ROSC_DIV_DIV (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register PHASE: Controls the phase shifted output
  static volatile uint32_t & ROSC_PHASE __attribute__((unused)) = * ((volatile uint32_t *) (0x40060000 + 20)) ;

  // Field SHIFT: phase shift the phase-shifted output by SHIFT input clocks\n this can be changed on-the-fly\n must be set to 0 before setting div=1
    inline uint32_t ROSC_PHASE_SHIFT (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field FLIP: invert the phase-shifted output\n this is ignored when div=1
    const uint32_t ROSC_PHASE_FLIP = 1U << 2 ;

  // Field ENABLE: enable the phase-shifted output\n this can be changed on-the-fly
    const uint32_t ROSC_PHASE_ENABLE = 1U << 3 ;

  // Field PASSWD: set to 0xaa0\n any other value enables the output with shift=0
    inline uint32_t ROSC_PHASE_PASSWD (const uint32_t inValue) {return (inValue & 0xFFU) << 4 ; }

//------------------------------------------------------------------------------

//---  Register STATUS: Ring Oscillator Status
  static volatile uint32_t & ROSC_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40060000 + 24)) ;

  // Field ENABLED: Oscillator is enabled but not necessarily running and stable\n this resets to 0 but transitions to 1 during chip startup
    const uint32_t ROSC_STATUS_ENABLED = 1U << 12 ;

  // Field DIV_RUNNING: post-divider is running\n this resets to 0 but transitions to 1 during chip startup
    const uint32_t ROSC_STATUS_DIV_RUNNING = 1U << 16 ;

  // Field BADWRITE: An invalid value has been written to CTRL_ENABLE or CTRL_FREQ_RANGE or FRFEQA or FREQB or DORMANT
    const uint32_t ROSC_STATUS_BADWRITE = 1U << 24 ;

  // Field STABLE: Oscillator is running and stable
    const uint32_t ROSC_STATUS_STABLE = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register RANDOMBIT: This just reads the state of the oscillator output so randomness is compromised if the ring oscillator is stopped or run at a harmonic of the bus frequency
  static volatile uint32_t & ROSC_RANDOMBIT __attribute__((unused)) = * ((volatile uint32_t *) (0x40060000 + 28)) ;

  // Field RANDOMBIT: 
    const uint32_t ROSC_RANDOMBIT_RANDOMBIT = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register COUNT: A down counter running at the ROSC frequency which counts to zero and stops.\n To start the counter write a non-zero value.\n Can be used for short software pauses when setting up time sensitive hardware.
  static volatile uint32_t & ROSC_COUNT __attribute__((unused)) = * ((volatile uint32_t *) (0x40060000 + 32)) ;

  // Field COUNT: 
    inline uint32_t ROSC_COUNT_COUNT (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral RTC: Register block to control RTC
//------------------------------------------------------------------------------

//---  Register CLKDIV_M1: Divider minus 1 for the 1 second counter. Safe to change the value when RTC is not enabled.
  static volatile uint32_t & RTC_CLKDIV_M1 __attribute__((unused)) = * ((volatile uint32_t *) (0x4005C000 + 0)) ;

  // Field CLKDIV_M1: 
    inline uint32_t RTC_CLKDIV_M1_CLKDIV_M1 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SETUP_0: RTC setup register 0
  static volatile uint32_t & RTC_SETUP_0 __attribute__((unused)) = * ((volatile uint32_t *) (0x4005C000 + 4)) ;

  // Field DAY: Day of the month (1..31)
    inline uint32_t RTC_SETUP_0_DAY (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field MONTH: Month (1..12)
    inline uint32_t RTC_SETUP_0_MONTH (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field YEAR: Year
    inline uint32_t RTC_SETUP_0_YEAR (const uint32_t inValue) {return (inValue & 0xFFFU) << 12 ; }

//------------------------------------------------------------------------------

//---  Register SETUP_1: RTC setup register 1
  static volatile uint32_t & RTC_SETUP_1 __attribute__((unused)) = * ((volatile uint32_t *) (0x4005C000 + 8)) ;

  // Field SEC: Seconds
    inline uint32_t RTC_SETUP_1_SEC (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

  // Field MIN: Minutes
    inline uint32_t RTC_SETUP_1_MIN (const uint32_t inValue) {return (inValue & 0x3FU) << 8 ; }

  // Field HOUR: Hours
    inline uint32_t RTC_SETUP_1_HOUR (const uint32_t inValue) {return (inValue & 0x1FU) << 16 ; }

  // Field DOTW: Day of the week: 1-Monday...0-Sunday ISO 8601 mod 7
    inline uint32_t RTC_SETUP_1_DOTW (const uint32_t inValue) {return (inValue & 0x7U) << 24 ; }

//------------------------------------------------------------------------------

//---  Register CTRL: RTC Control and status
  static volatile uint32_t & RTC_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x4005C000 + 12)) ;

  // Field RTC_ENABLE: Enable RTC
    const uint32_t RTC_CTRL_RTC_ENABLE = 1U << 0 ;

  // Field RTC_ACTIVE: RTC enabled (running)
    const uint32_t RTC_CTRL_RTC_ACTIVE = 1U << 1 ;

  // Field LOAD: Load RTC
    const uint32_t RTC_CTRL_LOAD = 1U << 4 ;

  // Field FORCE_NOTLEAPYEAR: If set, leapyear is forced off.\n Useful for years divisible by 100 but not by 400
    const uint32_t RTC_CTRL_FORCE_NOTLEAPYEAR = 1U << 8 ;

//------------------------------------------------------------------------------

//---  Register IRQ_SETUP_0: Interrupt setup register 0
  static volatile uint32_t & RTC_IRQ_SETUP_0 __attribute__((unused)) = * ((volatile uint32_t *) (0x4005C000 + 16)) ;

  // Field DAY: Day of the month (1..31)
    inline uint32_t RTC_IRQ_SETUP_0_DAY (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field MONTH: Month (1..12)
    inline uint32_t RTC_IRQ_SETUP_0_MONTH (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field YEAR: Year
    inline uint32_t RTC_IRQ_SETUP_0_YEAR (const uint32_t inValue) {return (inValue & 0xFFFU) << 12 ; }

  // Field DAY_ENA: Enable day matching
    const uint32_t RTC_IRQ_SETUP_0_DAY_ENA = 1U << 24 ;

  // Field MONTH_ENA: Enable month matching
    const uint32_t RTC_IRQ_SETUP_0_MONTH_ENA = 1U << 25 ;

  // Field YEAR_ENA: Enable year matching
    const uint32_t RTC_IRQ_SETUP_0_YEAR_ENA = 1U << 26 ;

  // Field MATCH_ENA: Global match enable. Don't change any other value while this one is enabled
    const uint32_t RTC_IRQ_SETUP_0_MATCH_ENA = 1U << 28 ;

  // Field MATCH_ACTIVE: 
    const uint32_t RTC_IRQ_SETUP_0_MATCH_ACTIVE = 1U << 29 ;

//------------------------------------------------------------------------------

//---  Register IRQ_SETUP_1: Interrupt setup register 1
  static volatile uint32_t & RTC_IRQ_SETUP_1 __attribute__((unused)) = * ((volatile uint32_t *) (0x4005C000 + 20)) ;

  // Field SEC: Seconds
    inline uint32_t RTC_IRQ_SETUP_1_SEC (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

  // Field MIN: Minutes
    inline uint32_t RTC_IRQ_SETUP_1_MIN (const uint32_t inValue) {return (inValue & 0x3FU) << 8 ; }

  // Field HOUR: Hours
    inline uint32_t RTC_IRQ_SETUP_1_HOUR (const uint32_t inValue) {return (inValue & 0x1FU) << 16 ; }

  // Field DOTW: Day of the week
    inline uint32_t RTC_IRQ_SETUP_1_DOTW (const uint32_t inValue) {return (inValue & 0x7U) << 24 ; }

  // Field SEC_ENA: Enable second matching
    const uint32_t RTC_IRQ_SETUP_1_SEC_ENA = 1U << 28 ;

  // Field MIN_ENA: Enable minute matching
    const uint32_t RTC_IRQ_SETUP_1_MIN_ENA = 1U << 29 ;

  // Field HOUR_ENA: Enable hour matching
    const uint32_t RTC_IRQ_SETUP_1_HOUR_ENA = 1U << 30 ;

  // Field DOTW_ENA: Enable day of the week matching
    const uint32_t RTC_IRQ_SETUP_1_DOTW_ENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register RTC_1: RTC register 1.
  static volatile uint32_t & RTC_RTC_1 __attribute__((unused)) = * ((volatile uint32_t *) (0x4005C000 + 24)) ;

  // Field DAY: Day of the month (1..31)
    inline uint32_t RTC_RTC_1_DAY (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field MONTH: Month (1..12)
    inline uint32_t RTC_RTC_1_MONTH (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field YEAR: Year
    inline uint32_t RTC_RTC_1_YEAR (const uint32_t inValue) {return (inValue & 0xFFFU) << 12 ; }

//------------------------------------------------------------------------------

//---  Register RTC_0: RTC register 0\n Read this before RTC 1!
  static volatile uint32_t & RTC_RTC_0 __attribute__((unused)) = * ((volatile uint32_t *) (0x4005C000 + 28)) ;

  // Field SEC: Seconds
    inline uint32_t RTC_RTC_0_SEC (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

  // Field MIN: Minutes
    inline uint32_t RTC_RTC_0_MIN (const uint32_t inValue) {return (inValue & 0x3FU) << 8 ; }

  // Field HOUR: Hours
    inline uint32_t RTC_RTC_0_HOUR (const uint32_t inValue) {return (inValue & 0x1FU) << 16 ; }

  // Field DOTW: Day of the week
    inline uint32_t RTC_RTC_0_DOTW (const uint32_t inValue) {return (inValue & 0x7U) << 24 ; }

//------------------------------------------------------------------------------

//---  Register INTR: Raw Interrupts
  static volatile uint32_t & RTC_INTR __attribute__((unused)) = * ((volatile uint32_t *) (0x4005C000 + 32)) ;

  // Field RTC: 
    const uint32_t RTC_INTR_RTC = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register INTE: Interrupt Enable
  static volatile uint32_t & RTC_INTE __attribute__((unused)) = * ((volatile uint32_t *) (0x4005C000 + 36)) ;

  // Field RTC: 
    const uint32_t RTC_INTE_RTC = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register INTF: Interrupt Force
  static volatile uint32_t & RTC_INTF __attribute__((unused)) = * ((volatile uint32_t *) (0x4005C000 + 40)) ;

  // Field RTC: 
    const uint32_t RTC_INTF_RTC = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register INTS: Interrupt status after masking & forcing
  static volatile uint32_t & RTC_INTS __attribute__((unused)) = * ((volatile uint32_t *) (0x4005C000 + 44)) ;

  // Field RTC: 
    const uint32_t RTC_INTS_RTC = 1U << 0 ;

//------------------------------------------------------------------------------
// Peripheral SIO: Single-cycle IO block\n         Provides core-local and inter-core hardware for the two processors, with single-cycle access.
//------------------------------------------------------------------------------

//---  Register CPUID: Processor core identifier\n Value is 0 when read from processor core 0, and 1 when read from processor core 1.
  static volatile uint32_t const & SIO_CPUID __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 0)) ;

//------------------------------------------------------------------------------

//---  Register GPIO_IN: Input value for GPIO pins
  static volatile uint32_t & SIO_GPIO_IN __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 4)) ;

  // Field GPIO_IN: Input value for GPIO0...29
    inline uint32_t SIO_GPIO_IN_GPIO_IN (const uint32_t inValue) {return (inValue & 0x3FFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register GPIO_HI_IN: Input value for QSPI pins
  static volatile uint32_t & SIO_GPIO_HI_IN __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 8)) ;

  // Field GPIO_HI_IN: Input value on QSPI IO in order 0..5: SCLK, SSn, SD0, SD1, SD2, SD3
    inline uint32_t SIO_GPIO_HI_IN_GPIO_HI_IN (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register GPIO_OUT: GPIO output value
  static volatile uint32_t & SIO_GPIO_OUT __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 16)) ;

  // Field GPIO_OUT: Set output level (1/0 -> high/low) for GPIO0...29.\n Reading back gives the last value written, NOT the input value from the pins.\n If core 0 and core 1 both write to GPIO_OUT simultaneously (or to a SET/CLR/XOR alias),\n the result is as though the write from core 0 took place first,\n and the write from core 1 was then applied to that intermediate result.
    inline uint32_t SIO_GPIO_OUT_GPIO_OUT (const uint32_t inValue) {return (inValue & 0x3FFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register GPIO_OUT_SET: GPIO output value set
  static volatile uint32_t & SIO_GPIO_OUT_SET __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 20)) ;

  // Field GPIO_OUT_SET: Perform an atomic bit-set on GPIO_OUT, i.e. `GPIO_OUT |= wdata`
    inline uint32_t SIO_GPIO_OUT_SET_GPIO_OUT_SET (const uint32_t inValue) {return (inValue & 0x3FFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register GPIO_OUT_CLR: GPIO output value clear
  static volatile uint32_t & SIO_GPIO_OUT_CLR __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 24)) ;

  // Field GPIO_OUT_CLR: Perform an atomic bit-clear on GPIO_OUT, i.e. `GPIO_OUT &= ~wdata`
    inline uint32_t SIO_GPIO_OUT_CLR_GPIO_OUT_CLR (const uint32_t inValue) {return (inValue & 0x3FFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register GPIO_OUT_XOR: GPIO output value XOR
  static volatile uint32_t & SIO_GPIO_OUT_XOR __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 28)) ;

  // Field GPIO_OUT_XOR: Perform an atomic bitwise XOR on GPIO_OUT, i.e. `GPIO_OUT ^= wdata`
    inline uint32_t SIO_GPIO_OUT_XOR_GPIO_OUT_XOR (const uint32_t inValue) {return (inValue & 0x3FFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register GPIO_OE: GPIO output enable
  static volatile uint32_t & SIO_GPIO_OE __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 32)) ;

  // Field GPIO_OE: Set output enable (1/0 -> output/input) for GPIO0...29.\n Reading back gives the last value written.\n If core 0 and core 1 both write to GPIO_OE simultaneously (or to a SET/CLR/XOR alias),\n the result is as though the write from core 0 took place first,\n and the write from core 1 was then applied to that intermediate result.
    inline uint32_t SIO_GPIO_OE_GPIO_OE (const uint32_t inValue) {return (inValue & 0x3FFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register GPIO_OE_SET: GPIO output enable set
  static volatile uint32_t & SIO_GPIO_OE_SET __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 36)) ;

  // Field GPIO_OE_SET: Perform an atomic bit-set on GPIO_OE, i.e. `GPIO_OE |= wdata`
    inline uint32_t SIO_GPIO_OE_SET_GPIO_OE_SET (const uint32_t inValue) {return (inValue & 0x3FFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register GPIO_OE_CLR: GPIO output enable clear
  static volatile uint32_t & SIO_GPIO_OE_CLR __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 40)) ;

  // Field GPIO_OE_CLR: Perform an atomic bit-clear on GPIO_OE, i.e. `GPIO_OE &= ~wdata`
    inline uint32_t SIO_GPIO_OE_CLR_GPIO_OE_CLR (const uint32_t inValue) {return (inValue & 0x3FFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register GPIO_OE_XOR: GPIO output enable XOR
  static volatile uint32_t & SIO_GPIO_OE_XOR __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 44)) ;

  // Field GPIO_OE_XOR: Perform an atomic bitwise XOR on GPIO_OE, i.e. `GPIO_OE ^= wdata`
    inline uint32_t SIO_GPIO_OE_XOR_GPIO_OE_XOR (const uint32_t inValue) {return (inValue & 0x3FFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register GPIO_HI_OUT: QSPI output value
  static volatile uint32_t & SIO_GPIO_HI_OUT __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 48)) ;

  // Field GPIO_HI_OUT: Set output level (1/0 -> high/low) for QSPI IO0...5.\n Reading back gives the last value written, NOT the input value from the pins.\n If core 0 and core 1 both write to GPIO_HI_OUT simultaneously (or to a SET/CLR/XOR alias),\n the result is as though the write from core 0 took place first,\n and the write from core 1 was then applied to that intermediate result.
    inline uint32_t SIO_GPIO_HI_OUT_GPIO_HI_OUT (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register GPIO_HI_OUT_SET: QSPI output value set
  static volatile uint32_t & SIO_GPIO_HI_OUT_SET __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 52)) ;

  // Field GPIO_HI_OUT_SET: Perform an atomic bit-set on GPIO_HI_OUT, i.e. `GPIO_HI_OUT |= wdata`
    inline uint32_t SIO_GPIO_HI_OUT_SET_GPIO_HI_OUT_SET (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register GPIO_HI_OUT_CLR: QSPI output value clear
  static volatile uint32_t & SIO_GPIO_HI_OUT_CLR __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 56)) ;

  // Field GPIO_HI_OUT_CLR: Perform an atomic bit-clear on GPIO_HI_OUT, i.e. `GPIO_HI_OUT &= ~wdata`
    inline uint32_t SIO_GPIO_HI_OUT_CLR_GPIO_HI_OUT_CLR (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register GPIO_HI_OUT_XOR: QSPI output value XOR
  static volatile uint32_t & SIO_GPIO_HI_OUT_XOR __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 60)) ;

  // Field GPIO_HI_OUT_XOR: Perform an atomic bitwise XOR on GPIO_HI_OUT, i.e. `GPIO_HI_OUT ^= wdata`
    inline uint32_t SIO_GPIO_HI_OUT_XOR_GPIO_HI_OUT_XOR (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register GPIO_HI_OE: QSPI output enable
  static volatile uint32_t & SIO_GPIO_HI_OE __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 64)) ;

  // Field GPIO_HI_OE: Set output enable (1/0 -> output/input) for QSPI IO0...5.\n Reading back gives the last value written.\n If core 0 and core 1 both write to GPIO_HI_OE simultaneously (or to a SET/CLR/XOR alias),\n the result is as though the write from core 0 took place first,\n and the write from core 1 was then applied to that intermediate result.
    inline uint32_t SIO_GPIO_HI_OE_GPIO_HI_OE (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register GPIO_HI_OE_SET: QSPI output enable set
  static volatile uint32_t & SIO_GPIO_HI_OE_SET __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 68)) ;

  // Field GPIO_HI_OE_SET: Perform an atomic bit-set on GPIO_HI_OE, i.e. `GPIO_HI_OE |= wdata`
    inline uint32_t SIO_GPIO_HI_OE_SET_GPIO_HI_OE_SET (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register GPIO_HI_OE_CLR: QSPI output enable clear
  static volatile uint32_t & SIO_GPIO_HI_OE_CLR __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 72)) ;

  // Field GPIO_HI_OE_CLR: Perform an atomic bit-clear on GPIO_HI_OE, i.e. `GPIO_HI_OE &= ~wdata`
    inline uint32_t SIO_GPIO_HI_OE_CLR_GPIO_HI_OE_CLR (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register GPIO_HI_OE_XOR: QSPI output enable XOR
  static volatile uint32_t & SIO_GPIO_HI_OE_XOR __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 76)) ;

  // Field GPIO_HI_OE_XOR: Perform an atomic bitwise XOR on GPIO_HI_OE, i.e. `GPIO_HI_OE ^= wdata`
    inline uint32_t SIO_GPIO_HI_OE_XOR_GPIO_HI_OE_XOR (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FIFO_ST: Status register for inter-core FIFOs (mailboxes).\n There is one FIFO in the core 0 -> core 1 direction, and one core 1 -> core 0. Both are 32 bits wide and 8 words deep.\n Core 0 can see the read side of the 1->0 FIFO (RX), and the write side of 0->1 FIFO (TX).\n Core 1 can see the read side of the 0->1 FIFO (RX), and the write side of 1->0 FIFO (TX).\n The SIO IRQ for each core is the logical OR of the VLD, WOF and ROE fields of its FIFO_ST register.
  static volatile uint32_t & SIO_FIFO_ST __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 80)) ;

  // Field VLD: Value is 1 if this core's RX FIFO is not empty (i.e. if FIFO_RD is valid)
    const uint32_t SIO_FIFO_ST_VLD = 1U << 0 ;

  // Field RDY: Value is 1 if this core's TX FIFO is not full (i.e. if FIFO_WR is ready for more data)
    const uint32_t SIO_FIFO_ST_RDY = 1U << 1 ;

  // Field WOF: Sticky flag indicating the TX FIFO was written when full. This write was ignored by the FIFO.
    const uint32_t SIO_FIFO_ST_WOF = 1U << 2 ;

  // Field ROE: Sticky flag indicating the RX FIFO was read when empty. This read was ignored by the FIFO.
    const uint32_t SIO_FIFO_ST_ROE = 1U << 3 ;

//------------------------------------------------------------------------------

//---  Register FIFO_WR: Write access to this core's TX FIFO
  static volatile uint32_t & SIO_FIFO_WR __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 84)) ;

//------------------------------------------------------------------------------

//---  Register FIFO_RD: Read access to this core's RX FIFO
  static volatile uint32_t const & SIO_FIFO_RD __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 88)) ;

//------------------------------------------------------------------------------

//---  Register SPINLOCK_ST: Spinlock state\n A bitmap containing the state of all 32 spinlocks (1=locked).\n Mainly intended for debugging.
  static volatile uint32_t const & SIO_SPINLOCK_ST __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 92)) ;

//------------------------------------------------------------------------------

//---  Register DIV_UDIVIDEND: Divider unsigned dividend\n Write to the DIVIDEND operand of the divider, i.e. the p in `p / q`.\n Any operand write starts a new calculation. The results appear in QUOTIENT, REMAINDER.\n UDIVIDEND/SDIVIDEND are aliases of the same internal register. The U alias starts an\n unsigned calculation, and the S alias starts a signed calculation.
  static volatile uint32_t & SIO_DIV_UDIVIDEND __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 96)) ;

//------------------------------------------------------------------------------

//---  Register DIV_UDIVISOR: Divider unsigned divisor\n Write to the DIVISOR operand of the divider, i.e. the q in `p / q`.\n Any operand write starts a new calculation. The results appear in QUOTIENT, REMAINDER.\n UDIVIDEND/SDIVIDEND are aliases of the same internal register. The U alias starts an\n unsigned calculation, and the S alias starts a signed calculation.
  static volatile uint32_t & SIO_DIV_UDIVISOR __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 100)) ;

//------------------------------------------------------------------------------

//---  Register DIV_SDIVIDEND: Divider signed dividend\n The same as UDIVIDEND, but starts a signed calculation, rather than unsigned.
  static volatile uint32_t & SIO_DIV_SDIVIDEND __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 104)) ;

//------------------------------------------------------------------------------

//---  Register DIV_SDIVISOR: Divider signed divisor\n The same as UDIVISOR, but starts a signed calculation, rather than unsigned.
  static volatile uint32_t & SIO_DIV_SDIVISOR __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 108)) ;

//------------------------------------------------------------------------------

//---  Register DIV_QUOTIENT: Divider result quotient\n The result of `DIVIDEND / DIVISOR` (division). Contents undefined while CSR_READY is low.\n For signed calculations, QUOTIENT is negative when the signs of DIVIDEND and DIVISOR differ.\n This register can be written to directly, for context save/restore purposes. This halts any\n in-progress calculation and sets the CSR_READY and CSR_DIRTY flags.\n Reading from QUOTIENT clears the CSR_DIRTY flag, so should read results in the order\n REMAINDER, QUOTIENT if CSR_DIRTY is used.
  static volatile uint32_t & SIO_DIV_QUOTIENT __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 112)) ;

//------------------------------------------------------------------------------

//---  Register DIV_REMAINDER: Divider result remainder\n The result of `DIVIDEND % DIVISOR` (modulo). Contents undefined while CSR_READY is low.\n For signed calculations, REMAINDER is negative only when DIVIDEND is negative.\n This register can be written to directly, for context save/restore purposes. This halts any\n in-progress calculation and sets the CSR_READY and CSR_DIRTY flags.
  static volatile uint32_t & SIO_DIV_REMAINDER __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 116)) ;

//------------------------------------------------------------------------------

//---  Register DIV_CSR: Control and status register for divider.
  static volatile uint32_t & SIO_DIV_CSR __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 120)) ;

  // Field READY: Reads as 0 when a calculation is in progress, 1 otherwise.\n Writing an operand (xDIVIDEND, xDIVISOR) will immediately start a new calculation, no\n matter if one is already in progress.\n Writing to a result register will immediately terminate any in-progress calculation\n and set the READY and DIRTY flags.
    const uint32_t SIO_DIV_CSR_READY = 1U << 0 ;

  // Field DIRTY: Changes to 1 when any register is written, and back to 0 when QUOTIENT is read.\n Software can use this flag to make save/restore more efficient (skip if not DIRTY).\n If the flag is used in this way, it's recommended to either read QUOTIENT only,\n or REMAINDER and then QUOTIENT, to prevent data loss on context switch.
    const uint32_t SIO_DIV_CSR_DIRTY = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register INTERP0_ACCUM0: Read/write access to accumulator 0
  static volatile uint32_t & SIO_INTERP0_ACCUM0 __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 128)) ;

//------------------------------------------------------------------------------

//---  Register INTERP0_ACCUM1: Read/write access to accumulator 1
  static volatile uint32_t & SIO_INTERP0_ACCUM1 __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 132)) ;

//------------------------------------------------------------------------------

//---  Register INTERP0_BASE0: Read/write access to BASE0 register.
  static volatile uint32_t & SIO_INTERP0_BASE0 __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 136)) ;

//------------------------------------------------------------------------------

//---  Register INTERP0_BASE1: Read/write access to BASE1 register.
  static volatile uint32_t & SIO_INTERP0_BASE1 __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 140)) ;

//------------------------------------------------------------------------------

//---  Register INTERP0_BASE2: Read/write access to BASE2 register.
  static volatile uint32_t & SIO_INTERP0_BASE2 __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 144)) ;

//------------------------------------------------------------------------------

//---  Register INTERP0_POP_LANE0: Read LANE0 result, and simultaneously write lane results to both accumulators (POP).
  static volatile uint32_t const & SIO_INTERP0_POP_LANE0 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 148)) ;

//------------------------------------------------------------------------------

//---  Register INTERP0_POP_LANE1: Read LANE1 result, and simultaneously write lane results to both accumulators (POP).
  static volatile uint32_t const & SIO_INTERP0_POP_LANE1 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 152)) ;

//------------------------------------------------------------------------------

//---  Register INTERP0_POP_FULL: Read FULL result, and simultaneously write lane results to both accumulators (POP).
  static volatile uint32_t const & SIO_INTERP0_POP_FULL __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 156)) ;

//------------------------------------------------------------------------------

//---  Register INTERP0_PEEK_LANE0: Read LANE0 result, without altering any internal state (PEEK).
  static volatile uint32_t const & SIO_INTERP0_PEEK_LANE0 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 160)) ;

//------------------------------------------------------------------------------

//---  Register INTERP0_PEEK_LANE1: Read LANE1 result, without altering any internal state (PEEK).
  static volatile uint32_t const & SIO_INTERP0_PEEK_LANE1 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 164)) ;

//------------------------------------------------------------------------------

//---  Register INTERP0_PEEK_FULL: Read FULL result, without altering any internal state (PEEK).
  static volatile uint32_t const & SIO_INTERP0_PEEK_FULL __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 168)) ;

//------------------------------------------------------------------------------

//---  Register INTERP0_CTRL_LANE0: Control register for lane 0
  static volatile uint32_t & SIO_INTERP0_CTRL_LANE0 __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 172)) ;

  // Field SHIFT: Logical right-shift applied to accumulator before masking
    inline uint32_t SIO_INTERP0_CTRL_LANE0_SHIFT (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field MASK_LSB: The least-significant bit allowed to pass by the mask (inclusive)
    inline uint32_t SIO_INTERP0_CTRL_LANE0_MASK_LSB (const uint32_t inValue) {return (inValue & 0x1FU) << 5 ; }

  // Field MASK_MSB: The most-significant bit allowed to pass by the mask (inclusive)\n Setting MSB < LSB may cause chip to turn inside-out
    inline uint32_t SIO_INTERP0_CTRL_LANE0_MASK_MSB (const uint32_t inValue) {return (inValue & 0x1FU) << 10 ; }

  // Field SIGNED: If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits\n before adding to BASE0, and LANE0 PEEK/POP appear extended to 32 bits when read by processor.
    const uint32_t SIO_INTERP0_CTRL_LANE0_SIGNED = 1U << 15 ;

  // Field CROSS_INPUT: If 1, feed the opposite lane's accumulator into this lane's shift + mask hardware.\n Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the shift+mask bypass)
    const uint32_t SIO_INTERP0_CTRL_LANE0_CROSS_INPUT = 1U << 16 ;

  // Field CROSS_RESULT: If 1, feed the opposite lane's result into this lane's accumulator on POP.
    const uint32_t SIO_INTERP0_CTRL_LANE0_CROSS_RESULT = 1U << 17 ;

  // Field ADD_RAW: If 1, mask + shift is bypassed for LANE0 result. This does not affect FULL result.
    const uint32_t SIO_INTERP0_CTRL_LANE0_ADD_RAW = 1U << 18 ;

  // Field FORCE_MSB: ORed into bits 29:28 of the lane result presented to the processor on the bus.\n No effect on the internal 32-bit datapath. Handy for using a lane to generate sequence\n of pointers into flash or SRAM.
    inline uint32_t SIO_INTERP0_CTRL_LANE0_FORCE_MSB (const uint32_t inValue) {return (inValue & 0x3U) << 19 ; }

  // Field BLEND: Only present on INTERP0 on each core. If BLEND mode is enabled:\n - LANE1 result is a linear interpolation between BASE0 and BASE1, controlled\n by the 8 LSBs of lane 1 shift and mask value (a fractional number between\n 0 and 255/256ths)\n - LANE0 result does not have BASE0 added (yields only the 8 LSBs of lane 1 shift+mask value)\n - FULL result does not have lane 1 shift+mask value added (BASE2 + lane 0 shift+mask)\n LANE1 SIGNED flag controls whether the interpolation is signed or unsigned.
    const uint32_t SIO_INTERP0_CTRL_LANE0_BLEND = 1U << 21 ;

  // Field OVERF0: Indicates if any masked-off MSBs in ACCUM0 are set.
    const uint32_t SIO_INTERP0_CTRL_LANE0_OVERF0 = 1U << 23 ;

  // Field OVERF1: Indicates if any masked-off MSBs in ACCUM1 are set.
    const uint32_t SIO_INTERP0_CTRL_LANE0_OVERF1 = 1U << 24 ;

  // Field OVERF: Set if either OVERF0 or OVERF1 is set.
    const uint32_t SIO_INTERP0_CTRL_LANE0_OVERF = 1U << 25 ;

//------------------------------------------------------------------------------

//---  Register INTERP0_CTRL_LANE1: Control register for lane 1
  static volatile uint32_t & SIO_INTERP0_CTRL_LANE1 __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 176)) ;

  // Field SHIFT: Logical right-shift applied to accumulator before masking
    inline uint32_t SIO_INTERP0_CTRL_LANE1_SHIFT (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field MASK_LSB: The least-significant bit allowed to pass by the mask (inclusive)
    inline uint32_t SIO_INTERP0_CTRL_LANE1_MASK_LSB (const uint32_t inValue) {return (inValue & 0x1FU) << 5 ; }

  // Field MASK_MSB: The most-significant bit allowed to pass by the mask (inclusive)\n Setting MSB < LSB may cause chip to turn inside-out
    inline uint32_t SIO_INTERP0_CTRL_LANE1_MASK_MSB (const uint32_t inValue) {return (inValue & 0x1FU) << 10 ; }

  // Field SIGNED: If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits\n before adding to BASE1, and LANE1 PEEK/POP appear extended to 32 bits when read by processor.
    const uint32_t SIO_INTERP0_CTRL_LANE1_SIGNED = 1U << 15 ;

  // Field CROSS_INPUT: If 1, feed the opposite lane's accumulator into this lane's shift + mask hardware.\n Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the shift+mask bypass)
    const uint32_t SIO_INTERP0_CTRL_LANE1_CROSS_INPUT = 1U << 16 ;

  // Field CROSS_RESULT: If 1, feed the opposite lane's result into this lane's accumulator on POP.
    const uint32_t SIO_INTERP0_CTRL_LANE1_CROSS_RESULT = 1U << 17 ;

  // Field ADD_RAW: If 1, mask + shift is bypassed for LANE1 result. This does not affect FULL result.
    const uint32_t SIO_INTERP0_CTRL_LANE1_ADD_RAW = 1U << 18 ;

  // Field FORCE_MSB: ORed into bits 29:28 of the lane result presented to the processor on the bus.\n No effect on the internal 32-bit datapath. Handy for using a lane to generate sequence\n of pointers into flash or SRAM.
    inline uint32_t SIO_INTERP0_CTRL_LANE1_FORCE_MSB (const uint32_t inValue) {return (inValue & 0x3U) << 19 ; }

//------------------------------------------------------------------------------

//---  Register INTERP0_ACCUM0_ADD: Values written here are atomically added to ACCUM0\n Reading yields lane 0's raw shift and mask value (BASE0 not added).
  static volatile uint32_t & SIO_INTERP0_ACCUM0_ADD __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 180)) ;

  // Field INTERP0_ACCUM0_ADD: 
    inline uint32_t SIO_INTERP0_ACCUM0_ADD_INTERP0_ACCUM0_ADD (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INTERP0_ACCUM1_ADD: Values written here are atomically added to ACCUM1\n Reading yields lane 1's raw shift and mask value (BASE1 not added).
  static volatile uint32_t & SIO_INTERP0_ACCUM1_ADD __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 184)) ;

  // Field INTERP0_ACCUM1_ADD: 
    inline uint32_t SIO_INTERP0_ACCUM1_ADD_INTERP0_ACCUM1_ADD (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INTERP0_BASE_1AND0: On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously.\n Each half is sign-extended to 32 bits if that lane's SIGNED flag is set.
  static volatile uint32_t & SIO_INTERP0_BASE_1AND0 __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 188)) ;

//------------------------------------------------------------------------------

//---  Register INTERP1_ACCUM0: Read/write access to accumulator 0
  static volatile uint32_t & SIO_INTERP1_ACCUM0 __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 192)) ;

//------------------------------------------------------------------------------

//---  Register INTERP1_ACCUM1: Read/write access to accumulator 1
  static volatile uint32_t & SIO_INTERP1_ACCUM1 __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 196)) ;

//------------------------------------------------------------------------------

//---  Register INTERP1_BASE0: Read/write access to BASE0 register.
  static volatile uint32_t & SIO_INTERP1_BASE0 __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 200)) ;

//------------------------------------------------------------------------------

//---  Register INTERP1_BASE1: Read/write access to BASE1 register.
  static volatile uint32_t & SIO_INTERP1_BASE1 __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 204)) ;

//------------------------------------------------------------------------------

//---  Register INTERP1_BASE2: Read/write access to BASE2 register.
  static volatile uint32_t & SIO_INTERP1_BASE2 __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 208)) ;

//------------------------------------------------------------------------------

//---  Register INTERP1_POP_LANE0: Read LANE0 result, and simultaneously write lane results to both accumulators (POP).
  static volatile uint32_t const & SIO_INTERP1_POP_LANE0 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 212)) ;

//------------------------------------------------------------------------------

//---  Register INTERP1_POP_LANE1: Read LANE1 result, and simultaneously write lane results to both accumulators (POP).
  static volatile uint32_t const & SIO_INTERP1_POP_LANE1 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 216)) ;

//------------------------------------------------------------------------------

//---  Register INTERP1_POP_FULL: Read FULL result, and simultaneously write lane results to both accumulators (POP).
  static volatile uint32_t const & SIO_INTERP1_POP_FULL __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 220)) ;

//------------------------------------------------------------------------------

//---  Register INTERP1_PEEK_LANE0: Read LANE0 result, without altering any internal state (PEEK).
  static volatile uint32_t const & SIO_INTERP1_PEEK_LANE0 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 224)) ;

//------------------------------------------------------------------------------

//---  Register INTERP1_PEEK_LANE1: Read LANE1 result, without altering any internal state (PEEK).
  static volatile uint32_t const & SIO_INTERP1_PEEK_LANE1 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 228)) ;

//------------------------------------------------------------------------------

//---  Register INTERP1_PEEK_FULL: Read FULL result, without altering any internal state (PEEK).
  static volatile uint32_t const & SIO_INTERP1_PEEK_FULL __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 232)) ;

//------------------------------------------------------------------------------

//---  Register INTERP1_CTRL_LANE0: Control register for lane 0
  static volatile uint32_t & SIO_INTERP1_CTRL_LANE0 __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 236)) ;

  // Field SHIFT: Logical right-shift applied to accumulator before masking
    inline uint32_t SIO_INTERP1_CTRL_LANE0_SHIFT (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field MASK_LSB: The least-significant bit allowed to pass by the mask (inclusive)
    inline uint32_t SIO_INTERP1_CTRL_LANE0_MASK_LSB (const uint32_t inValue) {return (inValue & 0x1FU) << 5 ; }

  // Field MASK_MSB: The most-significant bit allowed to pass by the mask (inclusive)\n Setting MSB < LSB may cause chip to turn inside-out
    inline uint32_t SIO_INTERP1_CTRL_LANE0_MASK_MSB (const uint32_t inValue) {return (inValue & 0x1FU) << 10 ; }

  // Field SIGNED: If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits\n before adding to BASE0, and LANE0 PEEK/POP appear extended to 32 bits when read by processor.
    const uint32_t SIO_INTERP1_CTRL_LANE0_SIGNED = 1U << 15 ;

  // Field CROSS_INPUT: If 1, feed the opposite lane's accumulator into this lane's shift + mask hardware.\n Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the shift+mask bypass)
    const uint32_t SIO_INTERP1_CTRL_LANE0_CROSS_INPUT = 1U << 16 ;

  // Field CROSS_RESULT: If 1, feed the opposite lane's result into this lane's accumulator on POP.
    const uint32_t SIO_INTERP1_CTRL_LANE0_CROSS_RESULT = 1U << 17 ;

  // Field ADD_RAW: If 1, mask + shift is bypassed for LANE0 result. This does not affect FULL result.
    const uint32_t SIO_INTERP1_CTRL_LANE0_ADD_RAW = 1U << 18 ;

  // Field FORCE_MSB: ORed into bits 29:28 of the lane result presented to the processor on the bus.\n No effect on the internal 32-bit datapath. Handy for using a lane to generate sequence\n of pointers into flash or SRAM.
    inline uint32_t SIO_INTERP1_CTRL_LANE0_FORCE_MSB (const uint32_t inValue) {return (inValue & 0x3U) << 19 ; }

  // Field CLAMP: Only present on INTERP1 on each core. If CLAMP mode is enabled:\n - LANE0 result is shifted and masked ACCUM0, clamped by a lower bound of\n BASE0 and an upper bound of BASE1.\n - Signedness of these comparisons is determined by LANE0_CTRL_SIGNED
    const uint32_t SIO_INTERP1_CTRL_LANE0_CLAMP = 1U << 22 ;

  // Field OVERF0: Indicates if any masked-off MSBs in ACCUM0 are set.
    const uint32_t SIO_INTERP1_CTRL_LANE0_OVERF0 = 1U << 23 ;

  // Field OVERF1: Indicates if any masked-off MSBs in ACCUM1 are set.
    const uint32_t SIO_INTERP1_CTRL_LANE0_OVERF1 = 1U << 24 ;

  // Field OVERF: Set if either OVERF0 or OVERF1 is set.
    const uint32_t SIO_INTERP1_CTRL_LANE0_OVERF = 1U << 25 ;

//------------------------------------------------------------------------------

//---  Register INTERP1_CTRL_LANE1: Control register for lane 1
  static volatile uint32_t & SIO_INTERP1_CTRL_LANE1 __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 240)) ;

  // Field SHIFT: Logical right-shift applied to accumulator before masking
    inline uint32_t SIO_INTERP1_CTRL_LANE1_SHIFT (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field MASK_LSB: The least-significant bit allowed to pass by the mask (inclusive)
    inline uint32_t SIO_INTERP1_CTRL_LANE1_MASK_LSB (const uint32_t inValue) {return (inValue & 0x1FU) << 5 ; }

  // Field MASK_MSB: The most-significant bit allowed to pass by the mask (inclusive)\n Setting MSB < LSB may cause chip to turn inside-out
    inline uint32_t SIO_INTERP1_CTRL_LANE1_MASK_MSB (const uint32_t inValue) {return (inValue & 0x1FU) << 10 ; }

  // Field SIGNED: If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits\n before adding to BASE1, and LANE1 PEEK/POP appear extended to 32 bits when read by processor.
    const uint32_t SIO_INTERP1_CTRL_LANE1_SIGNED = 1U << 15 ;

  // Field CROSS_INPUT: If 1, feed the opposite lane's accumulator into this lane's shift + mask hardware.\n Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the shift+mask bypass)
    const uint32_t SIO_INTERP1_CTRL_LANE1_CROSS_INPUT = 1U << 16 ;

  // Field CROSS_RESULT: If 1, feed the opposite lane's result into this lane's accumulator on POP.
    const uint32_t SIO_INTERP1_CTRL_LANE1_CROSS_RESULT = 1U << 17 ;

  // Field ADD_RAW: If 1, mask + shift is bypassed for LANE1 result. This does not affect FULL result.
    const uint32_t SIO_INTERP1_CTRL_LANE1_ADD_RAW = 1U << 18 ;

  // Field FORCE_MSB: ORed into bits 29:28 of the lane result presented to the processor on the bus.\n No effect on the internal 32-bit datapath. Handy for using a lane to generate sequence\n of pointers into flash or SRAM.
    inline uint32_t SIO_INTERP1_CTRL_LANE1_FORCE_MSB (const uint32_t inValue) {return (inValue & 0x3U) << 19 ; }

//------------------------------------------------------------------------------

//---  Register INTERP1_ACCUM0_ADD: Values written here are atomically added to ACCUM0\n Reading yields lane 0's raw shift and mask value (BASE0 not added).
  static volatile uint32_t & SIO_INTERP1_ACCUM0_ADD __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 244)) ;

  // Field INTERP1_ACCUM0_ADD: 
    inline uint32_t SIO_INTERP1_ACCUM0_ADD_INTERP1_ACCUM0_ADD (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INTERP1_ACCUM1_ADD: Values written here are atomically added to ACCUM1\n Reading yields lane 1's raw shift and mask value (BASE1 not added).
  static volatile uint32_t & SIO_INTERP1_ACCUM1_ADD __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 248)) ;

  // Field INTERP1_ACCUM1_ADD: 
    inline uint32_t SIO_INTERP1_ACCUM1_ADD_INTERP1_ACCUM1_ADD (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register INTERP1_BASE_1AND0: On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously.\n Each half is sign-extended to 32 bits if that lane's SIGNED flag is set.
  static volatile uint32_t & SIO_INTERP1_BASE_1AND0 __attribute__((unused)) = * ((volatile uint32_t *) (0xD0000000 + 252)) ;

//------------------------------------------------------------------------------

//---  Register SPINLOCK0: Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
  static volatile uint32_t const & SIO_SPINLOCK0 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 256)) ;

//------------------------------------------------------------------------------

//---  Register SPINLOCK1: Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
  static volatile uint32_t const & SIO_SPINLOCK1 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 260)) ;

//------------------------------------------------------------------------------

//---  Register SPINLOCK2: Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
  static volatile uint32_t const & SIO_SPINLOCK2 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 264)) ;

//------------------------------------------------------------------------------

//---  Register SPINLOCK3: Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
  static volatile uint32_t const & SIO_SPINLOCK3 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 268)) ;

//------------------------------------------------------------------------------

//---  Register SPINLOCK4: Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
  static volatile uint32_t const & SIO_SPINLOCK4 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 272)) ;

//------------------------------------------------------------------------------

//---  Register SPINLOCK5: Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
  static volatile uint32_t const & SIO_SPINLOCK5 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 276)) ;

//------------------------------------------------------------------------------

//---  Register SPINLOCK6: Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
  static volatile uint32_t const & SIO_SPINLOCK6 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 280)) ;

//------------------------------------------------------------------------------

//---  Register SPINLOCK7: Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
  static volatile uint32_t const & SIO_SPINLOCK7 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 284)) ;

//------------------------------------------------------------------------------

//---  Register SPINLOCK8: Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
  static volatile uint32_t const & SIO_SPINLOCK8 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 288)) ;

//------------------------------------------------------------------------------

//---  Register SPINLOCK9: Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
  static volatile uint32_t const & SIO_SPINLOCK9 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 292)) ;

//------------------------------------------------------------------------------

//---  Register SPINLOCK10: Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
  static volatile uint32_t const & SIO_SPINLOCK10 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 296)) ;

//------------------------------------------------------------------------------

//---  Register SPINLOCK11: Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
  static volatile uint32_t const & SIO_SPINLOCK11 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 300)) ;

//------------------------------------------------------------------------------

//---  Register SPINLOCK12: Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
  static volatile uint32_t const & SIO_SPINLOCK12 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 304)) ;

//------------------------------------------------------------------------------

//---  Register SPINLOCK13: Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
  static volatile uint32_t const & SIO_SPINLOCK13 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 308)) ;

//------------------------------------------------------------------------------

//---  Register SPINLOCK14: Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
  static volatile uint32_t const & SIO_SPINLOCK14 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 312)) ;

//------------------------------------------------------------------------------

//---  Register SPINLOCK15: Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
  static volatile uint32_t const & SIO_SPINLOCK15 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 316)) ;

//------------------------------------------------------------------------------

//---  Register SPINLOCK16: Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
  static volatile uint32_t const & SIO_SPINLOCK16 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 320)) ;

//------------------------------------------------------------------------------

//---  Register SPINLOCK17: Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
  static volatile uint32_t const & SIO_SPINLOCK17 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 324)) ;

//------------------------------------------------------------------------------

//---  Register SPINLOCK18: Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
  static volatile uint32_t const & SIO_SPINLOCK18 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 328)) ;

//------------------------------------------------------------------------------

//---  Register SPINLOCK19: Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
  static volatile uint32_t const & SIO_SPINLOCK19 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 332)) ;

//------------------------------------------------------------------------------

//---  Register SPINLOCK20: Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
  static volatile uint32_t const & SIO_SPINLOCK20 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 336)) ;

//------------------------------------------------------------------------------

//---  Register SPINLOCK21: Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
  static volatile uint32_t const & SIO_SPINLOCK21 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 340)) ;

//------------------------------------------------------------------------------

//---  Register SPINLOCK22: Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
  static volatile uint32_t const & SIO_SPINLOCK22 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 344)) ;

//------------------------------------------------------------------------------

//---  Register SPINLOCK23: Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
  static volatile uint32_t const & SIO_SPINLOCK23 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 348)) ;

//------------------------------------------------------------------------------

//---  Register SPINLOCK24: Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
  static volatile uint32_t const & SIO_SPINLOCK24 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 352)) ;

//------------------------------------------------------------------------------

//---  Register SPINLOCK25: Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
  static volatile uint32_t const & SIO_SPINLOCK25 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 356)) ;

//------------------------------------------------------------------------------

//---  Register SPINLOCK26: Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
  static volatile uint32_t const & SIO_SPINLOCK26 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 360)) ;

//------------------------------------------------------------------------------

//---  Register SPINLOCK27: Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
  static volatile uint32_t const & SIO_SPINLOCK27 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 364)) ;

//------------------------------------------------------------------------------

//---  Register SPINLOCK28: Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
  static volatile uint32_t const & SIO_SPINLOCK28 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 368)) ;

//------------------------------------------------------------------------------

//---  Register SPINLOCK29: Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
  static volatile uint32_t const & SIO_SPINLOCK29 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 372)) ;

//------------------------------------------------------------------------------

//---  Register SPINLOCK30: Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
  static volatile uint32_t const & SIO_SPINLOCK30 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 376)) ;

//------------------------------------------------------------------------------

//---  Register SPINLOCK31: Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
  static volatile uint32_t const & SIO_SPINLOCK31 __attribute__((unused)) = * ((const volatile uint32_t *) (0xD0000000 + 380)) ;

//------------------------------------------------------------------------------
// Peripheral SPI0: 
//------------------------------------------------------------------------------

//---  Register SSPCR0: Control register 0, SSPCR0 on page 3-4
  static volatile uint32_t & SPI0_SSPCR0 __attribute__((unused)) = * ((volatile uint32_t *) (0x4003C000 + 0)) ;

  // Field DSS: Data Size Select: 0000 Reserved, undefined operation. 0001 Reserved, undefined operation. 0010 Reserved, undefined operation. 0011 4-bit data. 0100 5-bit data. 0101 6-bit data. 0110 7-bit data. 0111 8-bit data. 1000 9-bit data. 1001 10-bit data. 1010 11-bit data. 1011 12-bit data. 1100 13-bit data. 1101 14-bit data. 1110 15-bit data. 1111 16-bit data.
    inline uint32_t SPI0_SSPCR0_DSS (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field FRF: Frame format: 00 Motorola SPI frame format. 01 TI synchronous serial frame format. 10 National Microwire frame format. 11 Reserved, undefined operation.
    inline uint32_t SPI0_SSPCR0_FRF (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field SPO: SSPCLKOUT polarity, applicable to Motorola SPI frame format only. See Motorola SPI frame format on page 2-10.
    const uint32_t SPI0_SSPCR0_SPO = 1U << 6 ;

  // Field SPH: SSPCLKOUT phase, applicable to Motorola SPI frame format only. See Motorola SPI frame format on page 2-10.
    const uint32_t SPI0_SSPCR0_SPH = 1U << 7 ;

  // Field SCR: Serial clock rate. The value SCR is used to generate the transmit and receive bit rate of the PrimeCell SSP. The bit rate is: F SSPCLK CPSDVSR x (1+SCR) where CPSDVSR is an even value from 2-254, programmed through the SSPCPSR register and SCR is a value from 0-255.
    inline uint32_t SPI0_SSPCR0_SCR (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register SSPCR1: Control register 1, SSPCR1 on page 3-5
  static volatile uint32_t & SPI0_SSPCR1 __attribute__((unused)) = * ((volatile uint32_t *) (0x4003C000 + 4)) ;

  // Field LBM: Loop back mode: 0 Normal serial port operation enabled. 1 Output of transmit serial shifter is connected to input of receive serial shifter internally.
    const uint32_t SPI0_SSPCR1_LBM = 1U << 0 ;

  // Field SSE: Synchronous serial port enable: 0 SSP operation disabled. 1 SSP operation enabled.
    const uint32_t SPI0_SSPCR1_SSE = 1U << 1 ;

  // Field MS: Master or slave mode select. This bit can be modified only when the PrimeCell SSP is disabled, SSE=0: 0 Device configured as master, default. 1 Device configured as slave.
    const uint32_t SPI0_SSPCR1_MS = 1U << 2 ;

  // Field SOD: Slave-mode output disable. This bit is relevant only in the slave mode, MS=1. In multiple-slave systems, it is possible for an PrimeCell SSP master to broadcast a message to all slaves in the system while ensuring that only one slave drives data onto its serial output line. In such systems the RXD lines from multiple slaves could be tied together. To operate in such systems, the SOD bit can be set if the PrimeCell SSP slave is not supposed to drive the SSPTXD line: 0 SSP can drive the SSPTXD output in slave mode. 1 SSP must not drive the SSPTXD output in slave mode.
    const uint32_t SPI0_SSPCR1_SOD = 1U << 3 ;

//------------------------------------------------------------------------------

//---  Register SSPDR: Data register, SSPDR on page 3-6
  static volatile uint32_t & SPI0_SSPDR __attribute__((unused)) = * ((volatile uint32_t *) (0x4003C000 + 8)) ;

  // Field DATA: Transmit/Receive FIFO: Read Receive FIFO. Write Transmit FIFO. You must right-justify data when the PrimeCell SSP is programmed for a data size that is less than 16 bits. Unused bits at the top are ignored by transmit logic. The receive logic automatically right-justifies.
    inline uint32_t SPI0_SSPDR_DATA (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SSPSR: Status register, SSPSR on page 3-7
  static volatile uint32_t & SPI0_SSPSR __attribute__((unused)) = * ((volatile uint32_t *) (0x4003C000 + 12)) ;

  // Field TFE: Transmit FIFO empty, RO: 0 Transmit FIFO is not empty. 1 Transmit FIFO is empty.
    const uint32_t SPI0_SSPSR_TFE = 1U << 0 ;

  // Field TNF: Transmit FIFO not full, RO: 0 Transmit FIFO is full. 1 Transmit FIFO is not full.
    const uint32_t SPI0_SSPSR_TNF = 1U << 1 ;

  // Field RNE: Receive FIFO not empty, RO: 0 Receive FIFO is empty. 1 Receive FIFO is not empty.
    const uint32_t SPI0_SSPSR_RNE = 1U << 2 ;

  // Field RFF: Receive FIFO full, RO: 0 Receive FIFO is not full. 1 Receive FIFO is full.
    const uint32_t SPI0_SSPSR_RFF = 1U << 3 ;

  // Field BSY: PrimeCell SSP busy flag, RO: 0 SSP is idle. 1 SSP is currently transmitting and/or receiving a frame or the transmit FIFO is not empty.
    const uint32_t SPI0_SSPSR_BSY = 1U << 4 ;

//------------------------------------------------------------------------------

//---  Register SSPCPSR: Clock prescale register, SSPCPSR on page 3-8
  static volatile uint32_t & SPI0_SSPCPSR __attribute__((unused)) = * ((volatile uint32_t *) (0x4003C000 + 16)) ;

  // Field CPSDVSR: Clock prescale divisor. Must be an even number from 2-254, depending on the frequency of SSPCLK. The least significant bit always returns zero on reads.
    inline uint32_t SPI0_SSPCPSR_CPSDVSR (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SSPIMSC: Interrupt mask set or clear register, SSPIMSC on page 3-9
  static volatile uint32_t & SPI0_SSPIMSC __attribute__((unused)) = * ((volatile uint32_t *) (0x4003C000 + 20)) ;

  // Field RORIM: Receive overrun interrupt mask: 0 Receive FIFO written to while full condition interrupt is masked. 1 Receive FIFO written to while full condition interrupt is not masked.
    const uint32_t SPI0_SSPIMSC_RORIM = 1U << 0 ;

  // Field RTIM: Receive timeout interrupt mask: 0 Receive FIFO not empty and no read prior to timeout period interrupt is masked. 1 Receive FIFO not empty and no read prior to timeout period interrupt is not masked.
    const uint32_t SPI0_SSPIMSC_RTIM = 1U << 1 ;

  // Field RXIM: Receive FIFO interrupt mask: 0 Receive FIFO half full or less condition interrupt is masked. 1 Receive FIFO half full or less condition interrupt is not masked.
    const uint32_t SPI0_SSPIMSC_RXIM = 1U << 2 ;

  // Field TXIM: Transmit FIFO interrupt mask: 0 Transmit FIFO half empty or less condition interrupt is masked. 1 Transmit FIFO half empty or less condition interrupt is not masked.
    const uint32_t SPI0_SSPIMSC_TXIM = 1U << 3 ;

//------------------------------------------------------------------------------

//---  Register SSPRIS: Raw interrupt status register, SSPRIS on page 3-10
  static volatile uint32_t & SPI0_SSPRIS __attribute__((unused)) = * ((volatile uint32_t *) (0x4003C000 + 24)) ;

  // Field RORRIS: Gives the raw interrupt state, prior to masking, of the SSPRORINTR interrupt
    const uint32_t SPI0_SSPRIS_RORRIS = 1U << 0 ;

  // Field RTRIS: Gives the raw interrupt state, prior to masking, of the SSPRTINTR interrupt
    const uint32_t SPI0_SSPRIS_RTRIS = 1U << 1 ;

  // Field RXRIS: Gives the raw interrupt state, prior to masking, of the SSPRXINTR interrupt
    const uint32_t SPI0_SSPRIS_RXRIS = 1U << 2 ;

  // Field TXRIS: Gives the raw interrupt state, prior to masking, of the SSPTXINTR interrupt
    const uint32_t SPI0_SSPRIS_TXRIS = 1U << 3 ;

//------------------------------------------------------------------------------

//---  Register SSPMIS: Masked interrupt status register, SSPMIS on page 3-11
  static volatile uint32_t & SPI0_SSPMIS __attribute__((unused)) = * ((volatile uint32_t *) (0x4003C000 + 28)) ;

  // Field RORMIS: Gives the receive over run masked interrupt status, after masking, of the SSPRORINTR interrupt
    const uint32_t SPI0_SSPMIS_RORMIS = 1U << 0 ;

  // Field RTMIS: Gives the receive timeout masked interrupt state, after masking, of the SSPRTINTR interrupt
    const uint32_t SPI0_SSPMIS_RTMIS = 1U << 1 ;

  // Field RXMIS: Gives the receive FIFO masked interrupt state, after masking, of the SSPRXINTR interrupt
    const uint32_t SPI0_SSPMIS_RXMIS = 1U << 2 ;

  // Field TXMIS: Gives the transmit FIFO masked interrupt state, after masking, of the SSPTXINTR interrupt
    const uint32_t SPI0_SSPMIS_TXMIS = 1U << 3 ;

//------------------------------------------------------------------------------

//---  Register SSPICR: Interrupt clear register, SSPICR on page 3-11
  static volatile uint32_t & SPI0_SSPICR __attribute__((unused)) = * ((volatile uint32_t *) (0x4003C000 + 32)) ;

  // Field RORIC: Clears the SSPRORINTR interrupt
    const uint32_t SPI0_SSPICR_RORIC = 1U << 0 ;

  // Field RTIC: Clears the SSPRTINTR interrupt
    const uint32_t SPI0_SSPICR_RTIC = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register SSPDMACR: DMA control register, SSPDMACR on page 3-12
  static volatile uint32_t & SPI0_SSPDMACR __attribute__((unused)) = * ((volatile uint32_t *) (0x4003C000 + 36)) ;

  // Field RXDMAE: Receive DMA Enable. If this bit is set to 1, DMA for the receive FIFO is enabled.
    const uint32_t SPI0_SSPDMACR_RXDMAE = 1U << 0 ;

  // Field TXDMAE: Transmit DMA Enable. If this bit is set to 1, DMA for the transmit FIFO is enabled.
    const uint32_t SPI0_SSPDMACR_TXDMAE = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register SSPPERIPHID0: Peripheral identification registers, SSPPeriphID0-3 on page 3-13
  static volatile uint32_t & SPI0_SSPPERIPHID0 __attribute__((unused)) = * ((volatile uint32_t *) (0x4003C000 + 4064)) ;

  // Field PARTNUMBER0: These bits read back as 0x22
    inline uint32_t SPI0_SSPPERIPHID0_PARTNUMBER0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SSPPERIPHID1: Peripheral identification registers, SSPPeriphID0-3 on page 3-13
  static volatile uint32_t & SPI0_SSPPERIPHID1 __attribute__((unused)) = * ((volatile uint32_t *) (0x4003C000 + 4068)) ;

  // Field PARTNUMBER1: These bits read back as 0x0
    inline uint32_t SPI0_SSPPERIPHID1_PARTNUMBER1 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field DESIGNER0: These bits read back as 0x1
    inline uint32_t SPI0_SSPPERIPHID1_DESIGNER0 (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

//------------------------------------------------------------------------------

//---  Register SSPPERIPHID2: Peripheral identification registers, SSPPeriphID0-3 on page 3-13
  static volatile uint32_t & SPI0_SSPPERIPHID2 __attribute__((unused)) = * ((volatile uint32_t *) (0x4003C000 + 4072)) ;

  // Field DESIGNER1: These bits read back as 0x4
    inline uint32_t SPI0_SSPPERIPHID2_DESIGNER1 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field REVISION: These bits return the peripheral revision
    inline uint32_t SPI0_SSPPERIPHID2_REVISION (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

//------------------------------------------------------------------------------

//---  Register SSPPERIPHID3: Peripheral identification registers, SSPPeriphID0-3 on page 3-13
  static volatile uint32_t & SPI0_SSPPERIPHID3 __attribute__((unused)) = * ((volatile uint32_t *) (0x4003C000 + 4076)) ;

  // Field CONFIGURATION: These bits read back as 0x00
    inline uint32_t SPI0_SSPPERIPHID3_CONFIGURATION (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SSPPCELLID0: PrimeCell identification registers, SSPPCellID0-3 on page 3-16
  static volatile uint32_t & SPI0_SSPPCELLID0 __attribute__((unused)) = * ((volatile uint32_t *) (0x4003C000 + 4080)) ;

  // Field SSPPCELLID0: These bits read back as 0x0D
    inline uint32_t SPI0_SSPPCELLID0_SSPPCELLID0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SSPPCELLID1: PrimeCell identification registers, SSPPCellID0-3 on page 3-16
  static volatile uint32_t & SPI0_SSPPCELLID1 __attribute__((unused)) = * ((volatile uint32_t *) (0x4003C000 + 4084)) ;

  // Field SSPPCELLID1: These bits read back as 0xF0
    inline uint32_t SPI0_SSPPCELLID1_SSPPCELLID1 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SSPPCELLID2: PrimeCell identification registers, SSPPCellID0-3 on page 3-16
  static volatile uint32_t & SPI0_SSPPCELLID2 __attribute__((unused)) = * ((volatile uint32_t *) (0x4003C000 + 4088)) ;

  // Field SSPPCELLID2: These bits read back as 0x05
    inline uint32_t SPI0_SSPPCELLID2_SSPPCELLID2 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SSPPCELLID3: PrimeCell identification registers, SSPPCellID0-3 on page 3-16
  static volatile uint32_t & SPI0_SSPPCELLID3 __attribute__((unused)) = * ((volatile uint32_t *) (0x4003C000 + 4092)) ;

  // Field SSPPCELLID3: These bits read back as 0xB1
    inline uint32_t SPI0_SSPPCELLID3_SSPPCELLID3 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral SPI1: 
//------------------------------------------------------------------------------

//---  Register SSPCR0: Control register 0, SSPCR0 on page 3-4
  static volatile uint32_t & SPI1_SSPCR0 __attribute__((unused)) = * ((volatile uint32_t *) (0x40040000 + 0)) ;

  // Field DSS: Data Size Select: 0000 Reserved, undefined operation. 0001 Reserved, undefined operation. 0010 Reserved, undefined operation. 0011 4-bit data. 0100 5-bit data. 0101 6-bit data. 0110 7-bit data. 0111 8-bit data. 1000 9-bit data. 1001 10-bit data. 1010 11-bit data. 1011 12-bit data. 1100 13-bit data. 1101 14-bit data. 1110 15-bit data. 1111 16-bit data.
    inline uint32_t SPI1_SSPCR0_DSS (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field FRF: Frame format: 00 Motorola SPI frame format. 01 TI synchronous serial frame format. 10 National Microwire frame format. 11 Reserved, undefined operation.
    inline uint32_t SPI1_SSPCR0_FRF (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field SPO: SSPCLKOUT polarity, applicable to Motorola SPI frame format only. See Motorola SPI frame format on page 2-10.
    const uint32_t SPI1_SSPCR0_SPO = 1U << 6 ;

  // Field SPH: SSPCLKOUT phase, applicable to Motorola SPI frame format only. See Motorola SPI frame format on page 2-10.
    const uint32_t SPI1_SSPCR0_SPH = 1U << 7 ;

  // Field SCR: Serial clock rate. The value SCR is used to generate the transmit and receive bit rate of the PrimeCell SSP. The bit rate is: F SSPCLK CPSDVSR x (1+SCR) where CPSDVSR is an even value from 2-254, programmed through the SSPCPSR register and SCR is a value from 0-255.
    inline uint32_t SPI1_SSPCR0_SCR (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register SSPCR1: Control register 1, SSPCR1 on page 3-5
  static volatile uint32_t & SPI1_SSPCR1 __attribute__((unused)) = * ((volatile uint32_t *) (0x40040000 + 4)) ;

  // Field LBM: Loop back mode: 0 Normal serial port operation enabled. 1 Output of transmit serial shifter is connected to input of receive serial shifter internally.
    const uint32_t SPI1_SSPCR1_LBM = 1U << 0 ;

  // Field SSE: Synchronous serial port enable: 0 SSP operation disabled. 1 SSP operation enabled.
    const uint32_t SPI1_SSPCR1_SSE = 1U << 1 ;

  // Field MS: Master or slave mode select. This bit can be modified only when the PrimeCell SSP is disabled, SSE=0: 0 Device configured as master, default. 1 Device configured as slave.
    const uint32_t SPI1_SSPCR1_MS = 1U << 2 ;

  // Field SOD: Slave-mode output disable. This bit is relevant only in the slave mode, MS=1. In multiple-slave systems, it is possible for an PrimeCell SSP master to broadcast a message to all slaves in the system while ensuring that only one slave drives data onto its serial output line. In such systems the RXD lines from multiple slaves could be tied together. To operate in such systems, the SOD bit can be set if the PrimeCell SSP slave is not supposed to drive the SSPTXD line: 0 SSP can drive the SSPTXD output in slave mode. 1 SSP must not drive the SSPTXD output in slave mode.
    const uint32_t SPI1_SSPCR1_SOD = 1U << 3 ;

//------------------------------------------------------------------------------

//---  Register SSPDR: Data register, SSPDR on page 3-6
  static volatile uint32_t & SPI1_SSPDR __attribute__((unused)) = * ((volatile uint32_t *) (0x40040000 + 8)) ;

  // Field DATA: Transmit/Receive FIFO: Read Receive FIFO. Write Transmit FIFO. You must right-justify data when the PrimeCell SSP is programmed for a data size that is less than 16 bits. Unused bits at the top are ignored by transmit logic. The receive logic automatically right-justifies.
    inline uint32_t SPI1_SSPDR_DATA (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SSPSR: Status register, SSPSR on page 3-7
  static volatile uint32_t & SPI1_SSPSR __attribute__((unused)) = * ((volatile uint32_t *) (0x40040000 + 12)) ;

  // Field TFE: Transmit FIFO empty, RO: 0 Transmit FIFO is not empty. 1 Transmit FIFO is empty.
    const uint32_t SPI1_SSPSR_TFE = 1U << 0 ;

  // Field TNF: Transmit FIFO not full, RO: 0 Transmit FIFO is full. 1 Transmit FIFO is not full.
    const uint32_t SPI1_SSPSR_TNF = 1U << 1 ;

  // Field RNE: Receive FIFO not empty, RO: 0 Receive FIFO is empty. 1 Receive FIFO is not empty.
    const uint32_t SPI1_SSPSR_RNE = 1U << 2 ;

  // Field RFF: Receive FIFO full, RO: 0 Receive FIFO is not full. 1 Receive FIFO is full.
    const uint32_t SPI1_SSPSR_RFF = 1U << 3 ;

  // Field BSY: PrimeCell SSP busy flag, RO: 0 SSP is idle. 1 SSP is currently transmitting and/or receiving a frame or the transmit FIFO is not empty.
    const uint32_t SPI1_SSPSR_BSY = 1U << 4 ;

//------------------------------------------------------------------------------

//---  Register SSPCPSR: Clock prescale register, SSPCPSR on page 3-8
  static volatile uint32_t & SPI1_SSPCPSR __attribute__((unused)) = * ((volatile uint32_t *) (0x40040000 + 16)) ;

  // Field CPSDVSR: Clock prescale divisor. Must be an even number from 2-254, depending on the frequency of SSPCLK. The least significant bit always returns zero on reads.
    inline uint32_t SPI1_SSPCPSR_CPSDVSR (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SSPIMSC: Interrupt mask set or clear register, SSPIMSC on page 3-9
  static volatile uint32_t & SPI1_SSPIMSC __attribute__((unused)) = * ((volatile uint32_t *) (0x40040000 + 20)) ;

  // Field RORIM: Receive overrun interrupt mask: 0 Receive FIFO written to while full condition interrupt is masked. 1 Receive FIFO written to while full condition interrupt is not masked.
    const uint32_t SPI1_SSPIMSC_RORIM = 1U << 0 ;

  // Field RTIM: Receive timeout interrupt mask: 0 Receive FIFO not empty and no read prior to timeout period interrupt is masked. 1 Receive FIFO not empty and no read prior to timeout period interrupt is not masked.
    const uint32_t SPI1_SSPIMSC_RTIM = 1U << 1 ;

  // Field RXIM: Receive FIFO interrupt mask: 0 Receive FIFO half full or less condition interrupt is masked. 1 Receive FIFO half full or less condition interrupt is not masked.
    const uint32_t SPI1_SSPIMSC_RXIM = 1U << 2 ;

  // Field TXIM: Transmit FIFO interrupt mask: 0 Transmit FIFO half empty or less condition interrupt is masked. 1 Transmit FIFO half empty or less condition interrupt is not masked.
    const uint32_t SPI1_SSPIMSC_TXIM = 1U << 3 ;

//------------------------------------------------------------------------------

//---  Register SSPRIS: Raw interrupt status register, SSPRIS on page 3-10
  static volatile uint32_t & SPI1_SSPRIS __attribute__((unused)) = * ((volatile uint32_t *) (0x40040000 + 24)) ;

  // Field RORRIS: Gives the raw interrupt state, prior to masking, of the SSPRORINTR interrupt
    const uint32_t SPI1_SSPRIS_RORRIS = 1U << 0 ;

  // Field RTRIS: Gives the raw interrupt state, prior to masking, of the SSPRTINTR interrupt
    const uint32_t SPI1_SSPRIS_RTRIS = 1U << 1 ;

  // Field RXRIS: Gives the raw interrupt state, prior to masking, of the SSPRXINTR interrupt
    const uint32_t SPI1_SSPRIS_RXRIS = 1U << 2 ;

  // Field TXRIS: Gives the raw interrupt state, prior to masking, of the SSPTXINTR interrupt
    const uint32_t SPI1_SSPRIS_TXRIS = 1U << 3 ;

//------------------------------------------------------------------------------

//---  Register SSPMIS: Masked interrupt status register, SSPMIS on page 3-11
  static volatile uint32_t & SPI1_SSPMIS __attribute__((unused)) = * ((volatile uint32_t *) (0x40040000 + 28)) ;

  // Field RORMIS: Gives the receive over run masked interrupt status, after masking, of the SSPRORINTR interrupt
    const uint32_t SPI1_SSPMIS_RORMIS = 1U << 0 ;

  // Field RTMIS: Gives the receive timeout masked interrupt state, after masking, of the SSPRTINTR interrupt
    const uint32_t SPI1_SSPMIS_RTMIS = 1U << 1 ;

  // Field RXMIS: Gives the receive FIFO masked interrupt state, after masking, of the SSPRXINTR interrupt
    const uint32_t SPI1_SSPMIS_RXMIS = 1U << 2 ;

  // Field TXMIS: Gives the transmit FIFO masked interrupt state, after masking, of the SSPTXINTR interrupt
    const uint32_t SPI1_SSPMIS_TXMIS = 1U << 3 ;

//------------------------------------------------------------------------------

//---  Register SSPICR: Interrupt clear register, SSPICR on page 3-11
  static volatile uint32_t & SPI1_SSPICR __attribute__((unused)) = * ((volatile uint32_t *) (0x40040000 + 32)) ;

  // Field RORIC: Clears the SSPRORINTR interrupt
    const uint32_t SPI1_SSPICR_RORIC = 1U << 0 ;

  // Field RTIC: Clears the SSPRTINTR interrupt
    const uint32_t SPI1_SSPICR_RTIC = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register SSPDMACR: DMA control register, SSPDMACR on page 3-12
  static volatile uint32_t & SPI1_SSPDMACR __attribute__((unused)) = * ((volatile uint32_t *) (0x40040000 + 36)) ;

  // Field RXDMAE: Receive DMA Enable. If this bit is set to 1, DMA for the receive FIFO is enabled.
    const uint32_t SPI1_SSPDMACR_RXDMAE = 1U << 0 ;

  // Field TXDMAE: Transmit DMA Enable. If this bit is set to 1, DMA for the transmit FIFO is enabled.
    const uint32_t SPI1_SSPDMACR_TXDMAE = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register SSPPERIPHID0: Peripheral identification registers, SSPPeriphID0-3 on page 3-13
  static volatile uint32_t & SPI1_SSPPERIPHID0 __attribute__((unused)) = * ((volatile uint32_t *) (0x40040000 + 4064)) ;

  // Field PARTNUMBER0: These bits read back as 0x22
    inline uint32_t SPI1_SSPPERIPHID0_PARTNUMBER0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SSPPERIPHID1: Peripheral identification registers, SSPPeriphID0-3 on page 3-13
  static volatile uint32_t & SPI1_SSPPERIPHID1 __attribute__((unused)) = * ((volatile uint32_t *) (0x40040000 + 4068)) ;

  // Field PARTNUMBER1: These bits read back as 0x0
    inline uint32_t SPI1_SSPPERIPHID1_PARTNUMBER1 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field DESIGNER0: These bits read back as 0x1
    inline uint32_t SPI1_SSPPERIPHID1_DESIGNER0 (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

//------------------------------------------------------------------------------

//---  Register SSPPERIPHID2: Peripheral identification registers, SSPPeriphID0-3 on page 3-13
  static volatile uint32_t & SPI1_SSPPERIPHID2 __attribute__((unused)) = * ((volatile uint32_t *) (0x40040000 + 4072)) ;

  // Field DESIGNER1: These bits read back as 0x4
    inline uint32_t SPI1_SSPPERIPHID2_DESIGNER1 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field REVISION: These bits return the peripheral revision
    inline uint32_t SPI1_SSPPERIPHID2_REVISION (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

//------------------------------------------------------------------------------

//---  Register SSPPERIPHID3: Peripheral identification registers, SSPPeriphID0-3 on page 3-13
  static volatile uint32_t & SPI1_SSPPERIPHID3 __attribute__((unused)) = * ((volatile uint32_t *) (0x40040000 + 4076)) ;

  // Field CONFIGURATION: These bits read back as 0x00
    inline uint32_t SPI1_SSPPERIPHID3_CONFIGURATION (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SSPPCELLID0: PrimeCell identification registers, SSPPCellID0-3 on page 3-16
  static volatile uint32_t & SPI1_SSPPCELLID0 __attribute__((unused)) = * ((volatile uint32_t *) (0x40040000 + 4080)) ;

  // Field SSPPCELLID0: These bits read back as 0x0D
    inline uint32_t SPI1_SSPPCELLID0_SSPPCELLID0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SSPPCELLID1: PrimeCell identification registers, SSPPCellID0-3 on page 3-16
  static volatile uint32_t & SPI1_SSPPCELLID1 __attribute__((unused)) = * ((volatile uint32_t *) (0x40040000 + 4084)) ;

  // Field SSPPCELLID1: These bits read back as 0xF0
    inline uint32_t SPI1_SSPPCELLID1_SSPPCELLID1 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SSPPCELLID2: PrimeCell identification registers, SSPPCellID0-3 on page 3-16
  static volatile uint32_t & SPI1_SSPPCELLID2 __attribute__((unused)) = * ((volatile uint32_t *) (0x40040000 + 4088)) ;

  // Field SSPPCELLID2: These bits read back as 0x05
    inline uint32_t SPI1_SSPPCELLID2_SSPPCELLID2 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SSPPCELLID3: PrimeCell identification registers, SSPPCellID0-3 on page 3-16
  static volatile uint32_t & SPI1_SSPPCELLID3 __attribute__((unused)) = * ((volatile uint32_t *) (0x40040000 + 4092)) ;

  // Field SSPPCELLID3: These bits read back as 0xB1
    inline uint32_t SPI1_SSPPCELLID3_SSPPCELLID3 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral SYSCFG: Register block for various chip control signals
//------------------------------------------------------------------------------

//---  Register PROC0_NMI_MASK: Processor core 0 NMI source mask\n Set a bit high to enable NMI from that IRQ
  static volatile uint32_t & SYSCFG_PROC0_NMI_MASK __attribute__((unused)) = * ((volatile uint32_t *) (0x40004000 + 0)) ;

//------------------------------------------------------------------------------

//---  Register PROC1_NMI_MASK: Processor core 1 NMI source mask\n Set a bit high to enable NMI from that IRQ
  static volatile uint32_t & SYSCFG_PROC1_NMI_MASK __attribute__((unused)) = * ((volatile uint32_t *) (0x40004000 + 4)) ;

//------------------------------------------------------------------------------

//---  Register PROC_CONFIG: Configuration for processors
  static volatile uint32_t & SYSCFG_PROC_CONFIG __attribute__((unused)) = * ((volatile uint32_t *) (0x40004000 + 8)) ;

  // Field PROC0_HALTED: Indication that proc0 has halted
    const uint32_t SYSCFG_PROC_CONFIG_PROC0_HALTED = 1U << 0 ;

  // Field PROC1_HALTED: Indication that proc1 has halted
    const uint32_t SYSCFG_PROC_CONFIG_PROC1_HALTED = 1U << 1 ;

  // Field PROC0_DAP_INSTID: Configure proc0 DAP instance ID.\n Recommend that this is NOT changed until you require debug access in multi-chip environment\n WARNING: do not set to 15 as this is reserved for RescueDP
    inline uint32_t SYSCFG_PROC_CONFIG_PROC0_DAP_INSTID (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field PROC1_DAP_INSTID: Configure proc1 DAP instance ID.\n Recommend that this is NOT changed until you require debug access in multi-chip environment\n WARNING: do not set to 15 as this is reserved for RescueDP
    inline uint32_t SYSCFG_PROC_CONFIG_PROC1_DAP_INSTID (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

//------------------------------------------------------------------------------

//---  Register PROC_IN_SYNC_BYPASS: For each bit, if 1, bypass the input synchronizer between that GPIO\n and the GPIO input register in the SIO. The input synchronizers should\n generally be unbypassed, to avoid injecting metastabilities into processors.\n If you're feeling brave, you can bypass to save two cycles of input\n latency. This register applies to GPIO 0...29.
  static volatile uint32_t & SYSCFG_PROC_IN_SYNC_BYPASS __attribute__((unused)) = * ((volatile uint32_t *) (0x40004000 + 12)) ;

  // Field PROC_IN_SYNC_BYPASS: 
    inline uint32_t SYSCFG_PROC_IN_SYNC_BYPASS_PROC_IN_SYNC_BYPASS (const uint32_t inValue) {return (inValue & 0x3FFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register PROC_IN_SYNC_BYPASS_HI: For each bit, if 1, bypass the input synchronizer between that GPIO\n and the GPIO input register in the SIO. The input synchronizers should\n generally be unbypassed, to avoid injecting metastabilities into processors.\n If you're feeling brave, you can bypass to save two cycles of input\n latency. This register applies to GPIO 30...35 (the QSPI IOs).
  static volatile uint32_t & SYSCFG_PROC_IN_SYNC_BYPASS_HI __attribute__((unused)) = * ((volatile uint32_t *) (0x40004000 + 16)) ;

  // Field PROC_IN_SYNC_BYPASS_HI: 
    inline uint32_t SYSCFG_PROC_IN_SYNC_BYPASS_HI_PROC_IN_SYNC_BYPASS_HI (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DBGFORCE: Directly control the SWD debug port of either processor
  static volatile uint32_t & SYSCFG_DBGFORCE __attribute__((unused)) = * ((volatile uint32_t *) (0x40004000 + 20)) ;

  // Field PROC0_SWDO: Observe the value of processor 0 SWDIO output.
    const uint32_t SYSCFG_DBGFORCE_PROC0_SWDO = 1U << 0 ;

  // Field PROC0_SWDI: Directly drive processor 0 SWDIO input, if PROC0_ATTACH is set
    const uint32_t SYSCFG_DBGFORCE_PROC0_SWDI = 1U << 1 ;

  // Field PROC0_SWCLK: Directly drive processor 0 SWCLK, if PROC0_ATTACH is set
    const uint32_t SYSCFG_DBGFORCE_PROC0_SWCLK = 1U << 2 ;

  // Field PROC0_ATTACH: Attach processor 0 debug port to syscfg controls, and disconnect it from external SWD pads.
    const uint32_t SYSCFG_DBGFORCE_PROC0_ATTACH = 1U << 3 ;

  // Field PROC1_SWDO: Observe the value of processor 1 SWDIO output.
    const uint32_t SYSCFG_DBGFORCE_PROC1_SWDO = 1U << 4 ;

  // Field PROC1_SWDI: Directly drive processor 1 SWDIO input, if PROC1_ATTACH is set
    const uint32_t SYSCFG_DBGFORCE_PROC1_SWDI = 1U << 5 ;

  // Field PROC1_SWCLK: Directly drive processor 1 SWCLK, if PROC1_ATTACH is set
    const uint32_t SYSCFG_DBGFORCE_PROC1_SWCLK = 1U << 6 ;

  // Field PROC1_ATTACH: Attach processor 1 debug port to syscfg controls, and disconnect it from external SWD pads.
    const uint32_t SYSCFG_DBGFORCE_PROC1_ATTACH = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register MEMPOWERDOWN: Control power downs to memories. Set high to power down memories.\n Use with extreme caution
  static volatile uint32_t & SYSCFG_MEMPOWERDOWN __attribute__((unused)) = * ((volatile uint32_t *) (0x40004000 + 24)) ;

  // Field SRAM0: 
    const uint32_t SYSCFG_MEMPOWERDOWN_SRAM0 = 1U << 0 ;

  // Field SRAM1: 
    const uint32_t SYSCFG_MEMPOWERDOWN_SRAM1 = 1U << 1 ;

  // Field SRAM2: 
    const uint32_t SYSCFG_MEMPOWERDOWN_SRAM2 = 1U << 2 ;

  // Field SRAM3: 
    const uint32_t SYSCFG_MEMPOWERDOWN_SRAM3 = 1U << 3 ;

  // Field SRAM4: 
    const uint32_t SYSCFG_MEMPOWERDOWN_SRAM4 = 1U << 4 ;

  // Field SRAM5: 
    const uint32_t SYSCFG_MEMPOWERDOWN_SRAM5 = 1U << 5 ;

  // Field USB: 
    const uint32_t SYSCFG_MEMPOWERDOWN_USB = 1U << 6 ;

  // Field ROM: 
    const uint32_t SYSCFG_MEMPOWERDOWN_ROM = 1U << 7 ;

//------------------------------------------------------------------------------
// Peripheral SYSINFO: 
//------------------------------------------------------------------------------

//---  Register CHIP_ID: JEDEC JEP-106 compliant chip identifier.
  static volatile uint32_t & SYSINFO_CHIP_ID __attribute__((unused)) = * ((volatile uint32_t *) (0x40000000 + 0)) ;

  // Field MANUFACTURER: 
    inline uint32_t SYSINFO_CHIP_ID_MANUFACTURER (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

  // Field PART: 
    inline uint32_t SYSINFO_CHIP_ID_PART (const uint32_t inValue) {return (inValue & 0xFFFFU) << 12 ; }

  // Field REVISION: 
    inline uint32_t SYSINFO_CHIP_ID_REVISION (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

//------------------------------------------------------------------------------

//---  Register PLATFORM: Platform register. Allows software to know what environment it is running in.
  static volatile uint32_t & SYSINFO_PLATFORM __attribute__((unused)) = * ((volatile uint32_t *) (0x40000000 + 4)) ;

  // Field FPGA: 
    const uint32_t SYSINFO_PLATFORM_FPGA = 1U << 0 ;

  // Field ASIC: 
    const uint32_t SYSINFO_PLATFORM_ASIC = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register GITREF_RP2040: Git hash of the chip source. Used to identify chip version.
  static volatile uint32_t const & SYSINFO_GITREF_RP2040 __attribute__((unused)) = * ((const volatile uint32_t *) (0x40000000 + 64)) ;

//------------------------------------------------------------------------------
// Peripheral TBMAN: Testbench manager. Allows the programmer to know what platform their software is running on.
//------------------------------------------------------------------------------

//---  Register PLATFORM: Indicates the type of platform in use
  static volatile uint32_t & TBMAN_PLATFORM __attribute__((unused)) = * ((volatile uint32_t *) (0x4006C000 + 0)) ;

  // Field ASIC: Indicates the platform is an ASIC
    const uint32_t TBMAN_PLATFORM_ASIC = 1U << 0 ;

  // Field FPGA: Indicates the platform is an FPGA
    const uint32_t TBMAN_PLATFORM_FPGA = 1U << 1 ;

//------------------------------------------------------------------------------
// Peripheral TIMER: Controls time and alarms\n         time is a 64 bit value indicating the time in usec since power-on\n         timeh is the top 32 bits of time & timel is the bottom 32 bits\n         to change time write to timelw before timehw\n         to read time read from timelr before timehr\n         An alarm is set by setting alarm_enable and writing to the corresponding alarm register\n         When an alarm is pending, the corresponding alarm_running signal will be high\n         An alarm can be cancelled before it has finished by clearing the alarm_enable\n         When an alarm fires, the corresponding alarm_irq is set and alarm_running is cleared\n         To clear the interrupt write a 1 to the corresponding alarm_irq
//------------------------------------------------------------------------------

//---  Register TIMEHW: Write to bits 63:32 of time\n always write timelw before timehw
  static volatile uint32_t & TIMER_TIMEHW __attribute__((unused)) = * ((volatile uint32_t *) (0x40054000 + 0)) ;

//------------------------------------------------------------------------------

//---  Register TIMELW: Write to bits 31:0 of time\n writes do not get copied to time until timehw is written
  static volatile uint32_t & TIMER_TIMELW __attribute__((unused)) = * ((volatile uint32_t *) (0x40054000 + 4)) ;

//------------------------------------------------------------------------------

//---  Register TIMEHR: Read from bits 63:32 of time\n always read timelr before timehr
  static volatile uint32_t const & TIMER_TIMEHR __attribute__((unused)) = * ((const volatile uint32_t *) (0x40054000 + 8)) ;

//------------------------------------------------------------------------------

//---  Register TIMELR: Read from bits 31:0 of time
  static volatile uint32_t const & TIMER_TIMELR __attribute__((unused)) = * ((const volatile uint32_t *) (0x40054000 + 12)) ;

//------------------------------------------------------------------------------

//---  Register ALARM0: Arm alarm 0, and configure the time it will fire.\n Once armed, the alarm fires when TIMER_ALARM0 == TIMELR.\n The alarm will disarm itself once it fires, and can\n be disarmed early using the ARMED status register.
  static volatile uint32_t & TIMER_ALARM0 __attribute__((unused)) = * ((volatile uint32_t *) (0x40054000 + 16)) ;

//------------------------------------------------------------------------------

//---  Register ALARM1: Arm alarm 1, and configure the time it will fire.\n Once armed, the alarm fires when TIMER_ALARM1 == TIMELR.\n The alarm will disarm itself once it fires, and can\n be disarmed early using the ARMED status register.
  static volatile uint32_t & TIMER_ALARM1 __attribute__((unused)) = * ((volatile uint32_t *) (0x40054000 + 20)) ;

//------------------------------------------------------------------------------

//---  Register ALARM2: Arm alarm 2, and configure the time it will fire.\n Once armed, the alarm fires when TIMER_ALARM2 == TIMELR.\n The alarm will disarm itself once it fires, and can\n be disarmed early using the ARMED status register.
  static volatile uint32_t & TIMER_ALARM2 __attribute__((unused)) = * ((volatile uint32_t *) (0x40054000 + 24)) ;

//------------------------------------------------------------------------------

//---  Register ALARM3: Arm alarm 3, and configure the time it will fire.\n Once armed, the alarm fires when TIMER_ALARM3 == TIMELR.\n The alarm will disarm itself once it fires, and can\n be disarmed early using the ARMED status register.
  static volatile uint32_t & TIMER_ALARM3 __attribute__((unused)) = * ((volatile uint32_t *) (0x40054000 + 28)) ;

//------------------------------------------------------------------------------

//---  Register ARMED: Indicates the armed/disarmed status of each alarm.\n A write to the corresponding ALARMx register arms the alarm.\n Alarms automatically disarm upon firing, but writing ones here\n will disarm immediately without waiting to fire.
  static volatile uint32_t & TIMER_ARMED __attribute__((unused)) = * ((volatile uint32_t *) (0x40054000 + 32)) ;

  // Field ARMED: 
    inline uint32_t TIMER_ARMED_ARMED (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register TIMERAWH: Raw read from bits 63:32 of time (no side effects)
  static volatile uint32_t const & TIMER_TIMERAWH __attribute__((unused)) = * ((const volatile uint32_t *) (0x40054000 + 36)) ;

//------------------------------------------------------------------------------

//---  Register TIMERAWL: Raw read from bits 31:0 of time (no side effects)
  static volatile uint32_t const & TIMER_TIMERAWL __attribute__((unused)) = * ((const volatile uint32_t *) (0x40054000 + 40)) ;

//------------------------------------------------------------------------------

//---  Register DBGPAUSE: Set bits high to enable pause when the corresponding debug ports are active
  static volatile uint32_t & TIMER_DBGPAUSE __attribute__((unused)) = * ((volatile uint32_t *) (0x40054000 + 44)) ;

  // Field DBG0: Pause when processor 0 is in debug mode
    const uint32_t TIMER_DBGPAUSE_DBG0 = 1U << 1 ;

  // Field DBG1: Pause when processor 1 is in debug mode
    const uint32_t TIMER_DBGPAUSE_DBG1 = 1U << 2 ;

//------------------------------------------------------------------------------

//---  Register PAUSE: Set high to pause the timer
  static volatile uint32_t & TIMER_PAUSE __attribute__((unused)) = * ((volatile uint32_t *) (0x40054000 + 48)) ;

  // Field PAUSE: 
    const uint32_t TIMER_PAUSE_PAUSE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register INTR: Raw Interrupts
  static volatile uint32_t & TIMER_INTR __attribute__((unused)) = * ((volatile uint32_t *) (0x40054000 + 52)) ;

  // Field ALARM_0: 
    const uint32_t TIMER_INTR_ALARM_0 = 1U << 0 ;

  // Field ALARM_1: 
    const uint32_t TIMER_INTR_ALARM_1 = 1U << 1 ;

  // Field ALARM_2: 
    const uint32_t TIMER_INTR_ALARM_2 = 1U << 2 ;

  // Field ALARM_3: 
    const uint32_t TIMER_INTR_ALARM_3 = 1U << 3 ;

//------------------------------------------------------------------------------

//---  Register INTE: Interrupt Enable
  static volatile uint32_t & TIMER_INTE __attribute__((unused)) = * ((volatile uint32_t *) (0x40054000 + 56)) ;

  // Field ALARM_0: 
    const uint32_t TIMER_INTE_ALARM_0 = 1U << 0 ;

  // Field ALARM_1: 
    const uint32_t TIMER_INTE_ALARM_1 = 1U << 1 ;

  // Field ALARM_2: 
    const uint32_t TIMER_INTE_ALARM_2 = 1U << 2 ;

  // Field ALARM_3: 
    const uint32_t TIMER_INTE_ALARM_3 = 1U << 3 ;

//------------------------------------------------------------------------------

//---  Register INTF: Interrupt Force
  static volatile uint32_t & TIMER_INTF __attribute__((unused)) = * ((volatile uint32_t *) (0x40054000 + 60)) ;

  // Field ALARM_0: 
    const uint32_t TIMER_INTF_ALARM_0 = 1U << 0 ;

  // Field ALARM_1: 
    const uint32_t TIMER_INTF_ALARM_1 = 1U << 1 ;

  // Field ALARM_2: 
    const uint32_t TIMER_INTF_ALARM_2 = 1U << 2 ;

  // Field ALARM_3: 
    const uint32_t TIMER_INTF_ALARM_3 = 1U << 3 ;

//------------------------------------------------------------------------------

//---  Register INTS: Interrupt status after masking & forcing
  static volatile uint32_t & TIMER_INTS __attribute__((unused)) = * ((volatile uint32_t *) (0x40054000 + 64)) ;

  // Field ALARM_0: 
    const uint32_t TIMER_INTS_ALARM_0 = 1U << 0 ;

  // Field ALARM_1: 
    const uint32_t TIMER_INTS_ALARM_1 = 1U << 1 ;

  // Field ALARM_2: 
    const uint32_t TIMER_INTS_ALARM_2 = 1U << 2 ;

  // Field ALARM_3: 
    const uint32_t TIMER_INTS_ALARM_3 = 1U << 3 ;

//------------------------------------------------------------------------------
// Peripheral UART0: 
//------------------------------------------------------------------------------

//---  Register UARTDR: Data Register, UARTDR
  static volatile uint32_t & UART0_UARTDR __attribute__((unused)) = * ((volatile uint32_t *) (0x40034000 + 0)) ;

  // Field DATA: Receive (read) data character. Transmit (write) data character.
    inline uint32_t UART0_UARTDR_DATA (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field FE: Framing error. When set to 1, it indicates that the received character did not have a valid stop bit (a valid stop bit is 1). In FIFO mode, this error is associated with the character at the top of the FIFO.
    const uint32_t UART0_UARTDR_FE = 1U << 8 ;

  // Field PE: Parity error. When set to 1, it indicates that the parity of the received data character does not match the parity that the EPS and SPS bits in the Line Control Register, UARTLCR_H. In FIFO mode, this error is associated with the character at the top of the FIFO.
    const uint32_t UART0_UARTDR_PE = 1U << 9 ;

  // Field BE: Break error. This bit is set to 1 if a break condition was detected, indicating that the received data input was held LOW for longer than a full-word transmission time (defined as start, data, parity and stop bits). In FIFO mode, this error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state), and the next valid start bit is received.
    const uint32_t UART0_UARTDR_BE = 1U << 10 ;

  // Field OE: Overrun error. This bit is set to 1 if data is received and the receive FIFO is already full. This is cleared to 0 once there is an empty space in the FIFO and a new character can be written to it.
    const uint32_t UART0_UARTDR_OE = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register UARTRSR: Receive Status Register/Error Clear Register, UARTRSR/UARTECR
  static volatile uint32_t & UART0_UARTRSR __attribute__((unused)) = * ((volatile uint32_t *) (0x40034000 + 4)) ;

  // Field FE: Framing error. When set to 1, it indicates that the received character did not have a valid stop bit (a valid stop bit is 1). This bit is cleared to 0 by a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO.
    const uint32_t UART0_UARTRSR_FE = 1U << 0 ;

  // Field PE: Parity error. When set to 1, it indicates that the parity of the received data character does not match the parity that the EPS and SPS bits in the Line Control Register, UARTLCR_H. This bit is cleared to 0 by a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO.
    const uint32_t UART0_UARTRSR_PE = 1U << 1 ;

  // Field BE: Break error. This bit is set to 1 if a break condition was detected, indicating that the received data input was held LOW for longer than a full-word transmission time (defined as start, data, parity, and stop bits). This bit is cleared to 0 after a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state) and the next valid start bit is received.
    const uint32_t UART0_UARTRSR_BE = 1U << 2 ;

  // Field OE: Overrun error. This bit is set to 1 if data is received and the FIFO is already full. This bit is cleared to 0 by a write to UARTECR. The FIFO contents remain valid because no more data is written when the FIFO is full, only the contents of the shift register are overwritten. The CPU must now read the data, to empty the FIFO.
    const uint32_t UART0_UARTRSR_OE = 1U << 3 ;

//------------------------------------------------------------------------------

//---  Register UARTFR: Flag Register, UARTFR
  static volatile uint32_t & UART0_UARTFR __attribute__((unused)) = * ((volatile uint32_t *) (0x40034000 + 24)) ;

  // Field CTS: Clear to send. This bit is the complement of the UART clear to send, nUARTCTS, modem status input. That is, the bit is 1 when nUARTCTS is LOW.
    const uint32_t UART0_UARTFR_CTS = 1U << 0 ;

  // Field DSR: Data set ready. This bit is the complement of the UART data set ready, nUARTDSR, modem status input. That is, the bit is 1 when nUARTDSR is LOW.
    const uint32_t UART0_UARTFR_DSR = 1U << 1 ;

  // Field DCD: Data carrier detect. This bit is the complement of the UART data carrier detect, nUARTDCD, modem status input. That is, the bit is 1 when nUARTDCD is LOW.
    const uint32_t UART0_UARTFR_DCD = 1U << 2 ;

  // Field BUSY: UART busy. If this bit is set to 1, the UART is busy transmitting data. This bit remains set until the complete byte, including all the stop bits, has been sent from the shift register. This bit is set as soon as the transmit FIFO becomes non-empty, regardless of whether the UART is enabled or not.
    const uint32_t UART0_UARTFR_BUSY = 1U << 3 ;

  // Field RXFE: Receive FIFO empty. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the receive holding register is empty. If the FIFO is enabled, the RXFE bit is set when the receive FIFO is empty.
    const uint32_t UART0_UARTFR_RXFE = 1U << 4 ;

  // Field TXFF: Transmit FIFO full. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the transmit holding register is full. If the FIFO is enabled, the TXFF bit is set when the transmit FIFO is full.
    const uint32_t UART0_UARTFR_TXFF = 1U << 5 ;

  // Field RXFF: Receive FIFO full. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the receive holding register is full. If the FIFO is enabled, the RXFF bit is set when the receive FIFO is full.
    const uint32_t UART0_UARTFR_RXFF = 1U << 6 ;

  // Field TXFE: Transmit FIFO empty. The meaning of this bit depends on the state of the FEN bit in the Line Control Register, UARTLCR_H. If the FIFO is disabled, this bit is set when the transmit holding register is empty. If the FIFO is enabled, the TXFE bit is set when the transmit FIFO is empty. This bit does not indicate if there is data in the transmit shift register.
    const uint32_t UART0_UARTFR_TXFE = 1U << 7 ;

  // Field RI: Ring indicator. This bit is the complement of the UART ring indicator, nUARTRI, modem status input. That is, the bit is 1 when nUARTRI is LOW.
    const uint32_t UART0_UARTFR_RI = 1U << 8 ;

//------------------------------------------------------------------------------

//---  Register UARTILPR: IrDA Low-Power Counter Register, UARTILPR
  static volatile uint32_t & UART0_UARTILPR __attribute__((unused)) = * ((volatile uint32_t *) (0x40034000 + 32)) ;

  // Field ILPDVSR: 8-bit low-power divisor value. These bits are cleared to 0 at reset.
    inline uint32_t UART0_UARTILPR_ILPDVSR (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register UARTIBRD: Integer Baud Rate Register, UARTIBRD
  static volatile uint32_t & UART0_UARTIBRD __attribute__((unused)) = * ((volatile uint32_t *) (0x40034000 + 36)) ;

  // Field BAUD_DIVINT: The integer baud rate divisor. These bits are cleared to 0 on reset.
    inline uint32_t UART0_UARTIBRD_BAUD_DIVINT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register UARTFBRD: Fractional Baud Rate Register, UARTFBRD
  static volatile uint32_t & UART0_UARTFBRD __attribute__((unused)) = * ((volatile uint32_t *) (0x40034000 + 40)) ;

  // Field BAUD_DIVFRAC: The fractional baud rate divisor. These bits are cleared to 0 on reset.
    inline uint32_t UART0_UARTFBRD_BAUD_DIVFRAC (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register UARTLCR_H: Line Control Register, UARTLCR_H
  static volatile uint32_t & UART0_UARTLCR_H __attribute__((unused)) = * ((volatile uint32_t *) (0x40034000 + 44)) ;

  // Field BRK: Send break. If this bit is set to 1, a low-level is continually output on the UARTTXD output, after completing transmission of the current character. For the proper execution of the break command, the software must set this bit for at least two complete frames. For normal use, this bit must be cleared to 0.
    const uint32_t UART0_UARTLCR_H_BRK = 1U << 0 ;

  // Field PEN: Parity enable: 0 = parity is disabled and no parity bit added to the data frame 1 = parity checking and generation is enabled.
    const uint32_t UART0_UARTLCR_H_PEN = 1U << 1 ;

  // Field EPS: Even parity select. Controls the type of parity the UART uses during transmission and reception: 0 = odd parity. The UART generates or checks for an odd number of 1s in the data and parity bits. 1 = even parity. The UART generates or checks for an even number of 1s in the data and parity bits. This bit has no effect when the PEN bit disables parity checking and generation.
    const uint32_t UART0_UARTLCR_H_EPS = 1U << 2 ;

  // Field STP2: Two stop bits select. If this bit is set to 1, two stop bits are transmitted at the end of the frame. The receive logic does not check for two stop bits being received.
    const uint32_t UART0_UARTLCR_H_STP2 = 1U << 3 ;

  // Field FEN: Enable FIFOs: 0 = FIFOs are disabled (character mode) that is, the FIFOs become 1-byte-deep holding registers 1 = transmit and receive FIFO buffers are enabled (FIFO mode).
    const uint32_t UART0_UARTLCR_H_FEN = 1U << 4 ;

  // Field WLEN: Word length. These bits indicate the number of data bits transmitted or received in a frame as follows: b11 = 8 bits b10 = 7 bits b01 = 6 bits b00 = 5 bits.
    inline uint32_t UART0_UARTLCR_H_WLEN (const uint32_t inValue) {return (inValue & 0x3U) << 5 ; }

  // Field SPS: Stick parity select. 0 = stick parity is disabled 1 = either: * if the EPS bit is 0 then the parity bit is transmitted and checked as a 1 * if the EPS bit is 1 then the parity bit is transmitted and checked as a 0. This bit has no effect when the PEN bit disables parity checking and generation.
    const uint32_t UART0_UARTLCR_H_SPS = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register UARTCR: Control Register, UARTCR
  static volatile uint32_t & UART0_UARTCR __attribute__((unused)) = * ((volatile uint32_t *) (0x40034000 + 48)) ;

  // Field UARTEN: UART enable: 0 = UART is disabled. If the UART is disabled in the middle of transmission or reception, it completes the current character before stopping. 1 = the UART is enabled. Data transmission and reception occurs for either UART signals or SIR signals depending on the setting of the SIREN bit.
    const uint32_t UART0_UARTCR_UARTEN = 1U << 0 ;

  // Field SIREN: SIR enable: 0 = IrDA SIR ENDEC is disabled. nSIROUT remains LOW (no light pulse generated), and signal transitions on SIRIN have no effect. 1 = IrDA SIR ENDEC is enabled. Data is transmitted and received on nSIROUT and SIRIN. UARTTXD remains HIGH, in the marking state. Signal transitions on UARTRXD or modem status inputs have no effect. This bit has no effect if the UARTEN bit disables the UART.
    const uint32_t UART0_UARTCR_SIREN = 1U << 1 ;

  // Field SIRLP: SIR low-power IrDA mode. This bit selects the IrDA encoding mode. If this bit is cleared to 0, low-level bits are transmitted as an active high pulse with a width of 3 / 16th of the bit period. If this bit is set to 1, low-level bits are transmitted with a pulse width that is 3 times the period of the IrLPBaud16 input signal, regardless of the selected bit rate. Setting this bit uses less power, but might reduce transmission distances.
    const uint32_t UART0_UARTCR_SIRLP = 1U << 2 ;

  // Field LBE: Loopback enable. If this bit is set to 1 and the SIREN bit is set to 1 and the SIRTEST bit in the Test Control Register, UARTTCR is set to 1, then the nSIROUT path is inverted, and fed through to the SIRIN path. The SIRTEST bit in the test register must be set to 1 to override the normal half-duplex SIR operation. This must be the requirement for accessing the test registers during normal operation, and SIRTEST must be cleared to 0 when loopback testing is finished. This feature reduces the amount of external coupling required during system test. If this bit is set to 1, and the SIRTEST bit is set to 0, the UARTTXD path is fed through to the UARTRXD path. In either SIR mode or UART mode, when this bit is set, the modem outputs are also fed through to the modem inputs. This bit is cleared to 0 on reset, to disable loopback.
    const uint32_t UART0_UARTCR_LBE = 1U << 7 ;

  // Field TXE: Transmit enable. If this bit is set to 1, the transmit section of the UART is enabled. Data transmission occurs for either UART signals, or SIR signals depending on the setting of the SIREN bit. When the UART is disabled in the middle of transmission, it completes the current character before stopping.
    const uint32_t UART0_UARTCR_TXE = 1U << 8 ;

  // Field RXE: Receive enable. If this bit is set to 1, the receive section of the UART is enabled. Data reception occurs for either UART signals or SIR signals depending on the setting of the SIREN bit. When the UART is disabled in the middle of reception, it completes the current character before stopping.
    const uint32_t UART0_UARTCR_RXE = 1U << 9 ;

  // Field DTR: Data transmit ready. This bit is the complement of the UART data transmit ready, nUARTDTR, modem status output. That is, when the bit is programmed to a 1 then nUARTDTR is LOW.
    const uint32_t UART0_UARTCR_DTR = 1U << 10 ;

  // Field RTS: Request to send. This bit is the complement of the UART request to send, nUARTRTS, modem status output. That is, when the bit is programmed to a 1 then nUARTRTS is LOW.
    const uint32_t UART0_UARTCR_RTS = 1U << 11 ;

  // Field OUT1: This bit is the complement of the UART Out1 (nUARTOut1) modem status output. That is, when the bit is programmed to a 1 the output is 0. For DTE this can be used as Data Carrier Detect (DCD).
    const uint32_t UART0_UARTCR_OUT1 = 1U << 12 ;

  // Field OUT2: This bit is the complement of the UART Out2 (nUARTOut2) modem status output. That is, when the bit is programmed to a 1, the output is 0. For DTE this can be used as Ring Indicator (RI).
    const uint32_t UART0_UARTCR_OUT2 = 1U << 13 ;

  // Field RTSEN: RTS hardware flow control enable. If this bit is set to 1, RTS hardware flow control is enabled. Data is only requested when there is space in the receive FIFO for it to be received.
    const uint32_t UART0_UARTCR_RTSEN = 1U << 14 ;

  // Field CTSEN: CTS hardware flow control enable. If this bit is set to 1, CTS hardware flow control is enabled. Data is only transmitted when the nUARTCTS signal is asserted.
    const uint32_t UART0_UARTCR_CTSEN = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register UARTIFLS: Interrupt FIFO Level Select Register, UARTIFLS
  static volatile uint32_t & UART0_UARTIFLS __attribute__((unused)) = * ((volatile uint32_t *) (0x40034000 + 52)) ;

  // Field TXIFLSEL: Transmit interrupt FIFO level select. The trigger points for the transmit interrupt are as follows: b000 = Transmit FIFO becomes <= 1 / 8 full b001 = Transmit FIFO becomes <= 1 / 4 full b010 = Transmit FIFO becomes <= 1 / 2 full b011 = Transmit FIFO becomes <= 3 / 4 full b100 = Transmit FIFO becomes <= 7 / 8 full b101-b111 = reserved.
    inline uint32_t UART0_UARTIFLS_TXIFLSEL (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field RXIFLSEL: Receive interrupt FIFO level select. The trigger points for the receive interrupt are as follows: b000 = Receive FIFO becomes >= 1 / 8 full b001 = Receive FIFO becomes >= 1 / 4 full b010 = Receive FIFO becomes >= 1 / 2 full b011 = Receive FIFO becomes >= 3 / 4 full b100 = Receive FIFO becomes >= 7 / 8 full b101-b111 = reserved.
    inline uint32_t UART0_UARTIFLS_RXIFLSEL (const uint32_t inValue) {return (inValue & 0x7U) << 3 ; }

//------------------------------------------------------------------------------

//---  Register UARTIMSC: Interrupt Mask Set/Clear Register, UARTIMSC
  static volatile uint32_t & UART0_UARTIMSC __attribute__((unused)) = * ((volatile uint32_t *) (0x40034000 + 56)) ;

  // Field RIMIM: nUARTRI modem interrupt mask. A read returns the current mask for the UARTRIINTR interrupt. On a write of 1, the mask of the UARTRIINTR interrupt is set. A write of 0 clears the mask.
    const uint32_t UART0_UARTIMSC_RIMIM = 1U << 0 ;

  // Field CTSMIM: nUARTCTS modem interrupt mask. A read returns the current mask for the UARTCTSINTR interrupt. On a write of 1, the mask of the UARTCTSINTR interrupt is set. A write of 0 clears the mask.
    const uint32_t UART0_UARTIMSC_CTSMIM = 1U << 1 ;

  // Field DCDMIM: nUARTDCD modem interrupt mask. A read returns the current mask for the UARTDCDINTR interrupt. On a write of 1, the mask of the UARTDCDINTR interrupt is set. A write of 0 clears the mask.
    const uint32_t UART0_UARTIMSC_DCDMIM = 1U << 2 ;

  // Field DSRMIM: nUARTDSR modem interrupt mask. A read returns the current mask for the UARTDSRINTR interrupt. On a write of 1, the mask of the UARTDSRINTR interrupt is set. A write of 0 clears the mask.
    const uint32_t UART0_UARTIMSC_DSRMIM = 1U << 3 ;

  // Field RXIM: Receive interrupt mask. A read returns the current mask for the UARTRXINTR interrupt. On a write of 1, the mask of the UARTRXINTR interrupt is set. A write of 0 clears the mask.
    const uint32_t UART0_UARTIMSC_RXIM = 1U << 4 ;

  // Field TXIM: Transmit interrupt mask. A read returns the current mask for the UARTTXINTR interrupt. On a write of 1, the mask of the UARTTXINTR interrupt is set. A write of 0 clears the mask.
    const uint32_t UART0_UARTIMSC_TXIM = 1U << 5 ;

  // Field RTIM: Receive timeout interrupt mask. A read returns the current mask for the UARTRTINTR interrupt. On a write of 1, the mask of the UARTRTINTR interrupt is set. A write of 0 clears the mask.
    const uint32_t UART0_UARTIMSC_RTIM = 1U << 6 ;

  // Field FEIM: Framing error interrupt mask. A read returns the current mask for the UARTFEINTR interrupt. On a write of 1, the mask of the UARTFEINTR interrupt is set. A write of 0 clears the mask.
    const uint32_t UART0_UARTIMSC_FEIM = 1U << 7 ;

  // Field PEIM: Parity error interrupt mask. A read returns the current mask for the UARTPEINTR interrupt. On a write of 1, the mask of the UARTPEINTR interrupt is set. A write of 0 clears the mask.
    const uint32_t UART0_UARTIMSC_PEIM = 1U << 8 ;

  // Field BEIM: Break error interrupt mask. A read returns the current mask for the UARTBEINTR interrupt. On a write of 1, the mask of the UARTBEINTR interrupt is set. A write of 0 clears the mask.
    const uint32_t UART0_UARTIMSC_BEIM = 1U << 9 ;

  // Field OEIM: Overrun error interrupt mask. A read returns the current mask for the UARTOEINTR interrupt. On a write of 1, the mask of the UARTOEINTR interrupt is set. A write of 0 clears the mask.
    const uint32_t UART0_UARTIMSC_OEIM = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register UARTRIS: Raw Interrupt Status Register, UARTRIS
  static volatile uint32_t & UART0_UARTRIS __attribute__((unused)) = * ((volatile uint32_t *) (0x40034000 + 60)) ;

  // Field RIRMIS: nUARTRI modem interrupt status. Returns the raw interrupt state of the UARTRIINTR interrupt.
    const uint32_t UART0_UARTRIS_RIRMIS = 1U << 0 ;

  // Field CTSRMIS: nUARTCTS modem interrupt status. Returns the raw interrupt state of the UARTCTSINTR interrupt.
    const uint32_t UART0_UARTRIS_CTSRMIS = 1U << 1 ;

  // Field DCDRMIS: nUARTDCD modem interrupt status. Returns the raw interrupt state of the UARTDCDINTR interrupt.
    const uint32_t UART0_UARTRIS_DCDRMIS = 1U << 2 ;

  // Field DSRRMIS: nUARTDSR modem interrupt status. Returns the raw interrupt state of the UARTDSRINTR interrupt.
    const uint32_t UART0_UARTRIS_DSRRMIS = 1U << 3 ;

  // Field RXRIS: Receive interrupt status. Returns the raw interrupt state of the UARTRXINTR interrupt.
    const uint32_t UART0_UARTRIS_RXRIS = 1U << 4 ;

  // Field TXRIS: Transmit interrupt status. Returns the raw interrupt state of the UARTTXINTR interrupt.
    const uint32_t UART0_UARTRIS_TXRIS = 1U << 5 ;

  // Field RTRIS: Receive timeout interrupt status. Returns the raw interrupt state of the UARTRTINTR interrupt. a
    const uint32_t UART0_UARTRIS_RTRIS = 1U << 6 ;

  // Field FERIS: Framing error interrupt status. Returns the raw interrupt state of the UARTFEINTR interrupt.
    const uint32_t UART0_UARTRIS_FERIS = 1U << 7 ;

  // Field PERIS: Parity error interrupt status. Returns the raw interrupt state of the UARTPEINTR interrupt.
    const uint32_t UART0_UARTRIS_PERIS = 1U << 8 ;

  // Field BERIS: Break error interrupt status. Returns the raw interrupt state of the UARTBEINTR interrupt.
    const uint32_t UART0_UARTRIS_BERIS = 1U << 9 ;

  // Field OERIS: Overrun error interrupt status. Returns the raw interrupt state of the UARTOEINTR interrupt.
    const uint32_t UART0_UARTRIS_OERIS = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register UARTMIS: Masked Interrupt Status Register, UARTMIS
  static volatile uint32_t & UART0_UARTMIS __attribute__((unused)) = * ((volatile uint32_t *) (0x40034000 + 64)) ;

  // Field RIMMIS: nUARTRI modem masked interrupt status. Returns the masked interrupt state of the UARTRIINTR interrupt.
    const uint32_t UART0_UARTMIS_RIMMIS = 1U << 0 ;

  // Field CTSMMIS: nUARTCTS modem masked interrupt status. Returns the masked interrupt state of the UARTCTSINTR interrupt.
    const uint32_t UART0_UARTMIS_CTSMMIS = 1U << 1 ;

  // Field DCDMMIS: nUARTDCD modem masked interrupt status. Returns the masked interrupt state of the UARTDCDINTR interrupt.
    const uint32_t UART0_UARTMIS_DCDMMIS = 1U << 2 ;

  // Field DSRMMIS: nUARTDSR modem masked interrupt status. Returns the masked interrupt state of the UARTDSRINTR interrupt.
    const uint32_t UART0_UARTMIS_DSRMMIS = 1U << 3 ;

  // Field RXMIS: Receive masked interrupt status. Returns the masked interrupt state of the UARTRXINTR interrupt.
    const uint32_t UART0_UARTMIS_RXMIS = 1U << 4 ;

  // Field TXMIS: Transmit masked interrupt status. Returns the masked interrupt state of the UARTTXINTR interrupt.
    const uint32_t UART0_UARTMIS_TXMIS = 1U << 5 ;

  // Field RTMIS: Receive timeout masked interrupt status. Returns the masked interrupt state of the UARTRTINTR interrupt.
    const uint32_t UART0_UARTMIS_RTMIS = 1U << 6 ;

  // Field FEMIS: Framing error masked interrupt status. Returns the masked interrupt state of the UARTFEINTR interrupt.
    const uint32_t UART0_UARTMIS_FEMIS = 1U << 7 ;

  // Field PEMIS: Parity error masked interrupt status. Returns the masked interrupt state of the UARTPEINTR interrupt.
    const uint32_t UART0_UARTMIS_PEMIS = 1U << 8 ;

  // Field BEMIS: Break error masked interrupt status. Returns the masked interrupt state of the UARTBEINTR interrupt.
    const uint32_t UART0_UARTMIS_BEMIS = 1U << 9 ;

  // Field OEMIS: Overrun error masked interrupt status. Returns the masked interrupt state of the UARTOEINTR interrupt.
    const uint32_t UART0_UARTMIS_OEMIS = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register UARTICR: Interrupt Clear Register, UARTICR
  static volatile uint32_t & UART0_UARTICR __attribute__((unused)) = * ((volatile uint32_t *) (0x40034000 + 68)) ;

  // Field RIMIC: nUARTRI modem interrupt clear. Clears the UARTRIINTR interrupt.
    const uint32_t UART0_UARTICR_RIMIC = 1U << 0 ;

  // Field CTSMIC: nUARTCTS modem interrupt clear. Clears the UARTCTSINTR interrupt.
    const uint32_t UART0_UARTICR_CTSMIC = 1U << 1 ;

  // Field DCDMIC: nUARTDCD modem interrupt clear. Clears the UARTDCDINTR interrupt.
    const uint32_t UART0_UARTICR_DCDMIC = 1U << 2 ;

  // Field DSRMIC: nUARTDSR modem interrupt clear. Clears the UARTDSRINTR interrupt.
    const uint32_t UART0_UARTICR_DSRMIC = 1U << 3 ;

  // Field RXIC: Receive interrupt clear. Clears the UARTRXINTR interrupt.
    const uint32_t UART0_UARTICR_RXIC = 1U << 4 ;

  // Field TXIC: Transmit interrupt clear. Clears the UARTTXINTR interrupt.
    const uint32_t UART0_UARTICR_TXIC = 1U << 5 ;

  // Field RTIC: Receive timeout interrupt clear. Clears the UARTRTINTR interrupt.
    const uint32_t UART0_UARTICR_RTIC = 1U << 6 ;

  // Field FEIC: Framing error interrupt clear. Clears the UARTFEINTR interrupt.
    const uint32_t UART0_UARTICR_FEIC = 1U << 7 ;

  // Field PEIC: Parity error interrupt clear. Clears the UARTPEINTR interrupt.
    const uint32_t UART0_UARTICR_PEIC = 1U << 8 ;

  // Field BEIC: Break error interrupt clear. Clears the UARTBEINTR interrupt.
    const uint32_t UART0_UARTICR_BEIC = 1U << 9 ;

  // Field OEIC: Overrun error interrupt clear. Clears the UARTOEINTR interrupt.
    const uint32_t UART0_UARTICR_OEIC = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register UARTDMACR: DMA Control Register, UARTDMACR
  static volatile uint32_t & UART0_UARTDMACR __attribute__((unused)) = * ((volatile uint32_t *) (0x40034000 + 72)) ;

  // Field RXDMAE: Receive DMA enable. If this bit is set to 1, DMA for the receive FIFO is enabled.
    const uint32_t UART0_UARTDMACR_RXDMAE = 1U << 0 ;

  // Field TXDMAE: Transmit DMA enable. If this bit is set to 1, DMA for the transmit FIFO is enabled.
    const uint32_t UART0_UARTDMACR_TXDMAE = 1U << 1 ;

  // Field DMAONERR: DMA on error. If this bit is set to 1, the DMA receive request outputs, UARTRXDMASREQ or UARTRXDMABREQ, are disabled when the UART error interrupt is asserted.
    const uint32_t UART0_UARTDMACR_DMAONERR = 1U << 2 ;

//------------------------------------------------------------------------------

//---  Register UARTPERIPHID0: UARTPeriphID0 Register
  static volatile uint32_t & UART0_UARTPERIPHID0 __attribute__((unused)) = * ((volatile uint32_t *) (0x40034000 + 4064)) ;

  // Field PARTNUMBER0: These bits read back as 0x11
    inline uint32_t UART0_UARTPERIPHID0_PARTNUMBER0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register UARTPERIPHID1: UARTPeriphID1 Register
  static volatile uint32_t & UART0_UARTPERIPHID1 __attribute__((unused)) = * ((volatile uint32_t *) (0x40034000 + 4068)) ;

  // Field PARTNUMBER1: These bits read back as 0x0
    inline uint32_t UART0_UARTPERIPHID1_PARTNUMBER1 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field DESIGNER0: These bits read back as 0x1
    inline uint32_t UART0_UARTPERIPHID1_DESIGNER0 (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

//------------------------------------------------------------------------------

//---  Register UARTPERIPHID2: UARTPeriphID2 Register
  static volatile uint32_t & UART0_UARTPERIPHID2 __attribute__((unused)) = * ((volatile uint32_t *) (0x40034000 + 4072)) ;

  // Field DESIGNER1: These bits read back as 0x4
    inline uint32_t UART0_UARTPERIPHID2_DESIGNER1 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field REVISION: This field depends on the revision of the UART: r1p0 0x0 r1p1 0x1 r1p3 0x2 r1p4 0x2 r1p5 0x3
    inline uint32_t UART0_UARTPERIPHID2_REVISION (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

//------------------------------------------------------------------------------

//---  Register UARTPERIPHID3: UARTPeriphID3 Register
  static volatile uint32_t & UART0_UARTPERIPHID3 __attribute__((unused)) = * ((volatile uint32_t *) (0x40034000 + 4076)) ;

  // Field CONFIGURATION: These bits read back as 0x00
    inline uint32_t UART0_UARTPERIPHID3_CONFIGURATION (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register UARTPCELLID0: UARTPCellID0 Register
  static volatile uint32_t & UART0_UARTPCELLID0 __attribute__((unused)) = * ((volatile uint32_t *) (0x40034000 + 4080)) ;

  // Field UARTPCELLID0: These bits read back as 0x0D
    inline uint32_t UART0_UARTPCELLID0_UARTPCELLID0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register UARTPCELLID1: UARTPCellID1 Register
  static volatile uint32_t & UART0_UARTPCELLID1 __attribute__((unused)) = * ((volatile uint32_t *) (0x40034000 + 4084)) ;

  // Field UARTPCELLID1: These bits read back as 0xF0
    inline uint32_t UART0_UARTPCELLID1_UARTPCELLID1 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register UARTPCELLID2: UARTPCellID2 Register
  static volatile uint32_t & UART0_UARTPCELLID2 __attribute__((unused)) = * ((volatile uint32_t *) (0x40034000 + 4088)) ;

  // Field UARTPCELLID2: These bits read back as 0x05
    inline uint32_t UART0_UARTPCELLID2_UARTPCELLID2 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register UARTPCELLID3: UARTPCellID3 Register
  static volatile uint32_t & UART0_UARTPCELLID3 __attribute__((unused)) = * ((volatile uint32_t *) (0x40034000 + 4092)) ;

  // Field UARTPCELLID3: These bits read back as 0xB1
    inline uint32_t UART0_UARTPCELLID3_UARTPCELLID3 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral UART1: 
//------------------------------------------------------------------------------

//---  Register UARTDR: Data Register, UARTDR
  static volatile uint32_t & UART1_UARTDR __attribute__((unused)) = * ((volatile uint32_t *) (0x40038000 + 0)) ;

  // Field DATA: Receive (read) data character. Transmit (write) data character.
    inline uint32_t UART1_UARTDR_DATA (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field FE: Framing error. When set to 1, it indicates that the received character did not have a valid stop bit (a valid stop bit is 1). In FIFO mode, this error is associated with the character at the top of the FIFO.
    const uint32_t UART1_UARTDR_FE = 1U << 8 ;

  // Field PE: Parity error. When set to 1, it indicates that the parity of the received data character does not match the parity that the EPS and SPS bits in the Line Control Register, UARTLCR_H. In FIFO mode, this error is associated with the character at the top of the FIFO.
    const uint32_t UART1_UARTDR_PE = 1U << 9 ;

  // Field BE: Break error. This bit is set to 1 if a break condition was detected, indicating that the received data input was held LOW for longer than a full-word transmission time (defined as start, data, parity and stop bits). In FIFO mode, this error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state), and the next valid start bit is received.
    const uint32_t UART1_UARTDR_BE = 1U << 10 ;

  // Field OE: Overrun error. This bit is set to 1 if data is received and the receive FIFO is already full. This is cleared to 0 once there is an empty space in the FIFO and a new character can be written to it.
    const uint32_t UART1_UARTDR_OE = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register UARTRSR: Receive Status Register/Error Clear Register, UARTRSR/UARTECR
  static volatile uint32_t & UART1_UARTRSR __attribute__((unused)) = * ((volatile uint32_t *) (0x40038000 + 4)) ;

  // Field FE: Framing error. When set to 1, it indicates that the received character did not have a valid stop bit (a valid stop bit is 1). This bit is cleared to 0 by a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO.
    const uint32_t UART1_UARTRSR_FE = 1U << 0 ;

  // Field PE: Parity error. When set to 1, it indicates that the parity of the received data character does not match the parity that the EPS and SPS bits in the Line Control Register, UARTLCR_H. This bit is cleared to 0 by a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO.
    const uint32_t UART1_UARTRSR_PE = 1U << 1 ;

  // Field BE: Break error. This bit is set to 1 if a break condition was detected, indicating that the received data input was held LOW for longer than a full-word transmission time (defined as start, data, parity, and stop bits). This bit is cleared to 0 after a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state) and the next valid start bit is received.
    const uint32_t UART1_UARTRSR_BE = 1U << 2 ;

  // Field OE: Overrun error. This bit is set to 1 if data is received and the FIFO is already full. This bit is cleared to 0 by a write to UARTECR. The FIFO contents remain valid because no more data is written when the FIFO is full, only the contents of the shift register are overwritten. The CPU must now read the data, to empty the FIFO.
    const uint32_t UART1_UARTRSR_OE = 1U << 3 ;

//------------------------------------------------------------------------------

//---  Register UARTFR: Flag Register, UARTFR
  static volatile uint32_t & UART1_UARTFR __attribute__((unused)) = * ((volatile uint32_t *) (0x40038000 + 24)) ;

  // Field CTS: Clear to send. This bit is the complement of the UART clear to send, nUARTCTS, modem status input. That is, the bit is 1 when nUARTCTS is LOW.
    const uint32_t UART1_UARTFR_CTS = 1U << 0 ;

  // Field DSR: Data set ready. This bit is the complement of the UART data set ready, nUARTDSR, modem status input. That is, the bit is 1 when nUARTDSR is LOW.
    const uint32_t UART1_UARTFR_DSR = 1U << 1 ;

  // Field DCD: Data carrier detect. This bit is the complement of the UART data carrier detect, nUARTDCD, modem status input. That is, the bit is 1 when nUARTDCD is LOW.
    const uint32_t UART1_UARTFR_DCD = 1U << 2 ;

  // Field BUSY: UART busy. If this bit is set to 1, the UART is busy transmitting data. This bit remains set until the complete byte, including all the stop bits, has been sent from the shift register. This bit is set as soon as the transmit FIFO becomes non-empty, regardless of whether the UART is enabled or not.
    const uint32_t UART1_UARTFR_BUSY = 1U << 3 ;

  // Field RXFE: Receive FIFO empty. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the receive holding register is empty. If the FIFO is enabled, the RXFE bit is set when the receive FIFO is empty.
    const uint32_t UART1_UARTFR_RXFE = 1U << 4 ;

  // Field TXFF: Transmit FIFO full. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the transmit holding register is full. If the FIFO is enabled, the TXFF bit is set when the transmit FIFO is full.
    const uint32_t UART1_UARTFR_TXFF = 1U << 5 ;

  // Field RXFF: Receive FIFO full. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the receive holding register is full. If the FIFO is enabled, the RXFF bit is set when the receive FIFO is full.
    const uint32_t UART1_UARTFR_RXFF = 1U << 6 ;

  // Field TXFE: Transmit FIFO empty. The meaning of this bit depends on the state of the FEN bit in the Line Control Register, UARTLCR_H. If the FIFO is disabled, this bit is set when the transmit holding register is empty. If the FIFO is enabled, the TXFE bit is set when the transmit FIFO is empty. This bit does not indicate if there is data in the transmit shift register.
    const uint32_t UART1_UARTFR_TXFE = 1U << 7 ;

  // Field RI: Ring indicator. This bit is the complement of the UART ring indicator, nUARTRI, modem status input. That is, the bit is 1 when nUARTRI is LOW.
    const uint32_t UART1_UARTFR_RI = 1U << 8 ;

//------------------------------------------------------------------------------

//---  Register UARTILPR: IrDA Low-Power Counter Register, UARTILPR
  static volatile uint32_t & UART1_UARTILPR __attribute__((unused)) = * ((volatile uint32_t *) (0x40038000 + 32)) ;

  // Field ILPDVSR: 8-bit low-power divisor value. These bits are cleared to 0 at reset.
    inline uint32_t UART1_UARTILPR_ILPDVSR (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register UARTIBRD: Integer Baud Rate Register, UARTIBRD
  static volatile uint32_t & UART1_UARTIBRD __attribute__((unused)) = * ((volatile uint32_t *) (0x40038000 + 36)) ;

  // Field BAUD_DIVINT: The integer baud rate divisor. These bits are cleared to 0 on reset.
    inline uint32_t UART1_UARTIBRD_BAUD_DIVINT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register UARTFBRD: Fractional Baud Rate Register, UARTFBRD
  static volatile uint32_t & UART1_UARTFBRD __attribute__((unused)) = * ((volatile uint32_t *) (0x40038000 + 40)) ;

  // Field BAUD_DIVFRAC: The fractional baud rate divisor. These bits are cleared to 0 on reset.
    inline uint32_t UART1_UARTFBRD_BAUD_DIVFRAC (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register UARTLCR_H: Line Control Register, UARTLCR_H
  static volatile uint32_t & UART1_UARTLCR_H __attribute__((unused)) = * ((volatile uint32_t *) (0x40038000 + 44)) ;

  // Field BRK: Send break. If this bit is set to 1, a low-level is continually output on the UARTTXD output, after completing transmission of the current character. For the proper execution of the break command, the software must set this bit for at least two complete frames. For normal use, this bit must be cleared to 0.
    const uint32_t UART1_UARTLCR_H_BRK = 1U << 0 ;

  // Field PEN: Parity enable: 0 = parity is disabled and no parity bit added to the data frame 1 = parity checking and generation is enabled.
    const uint32_t UART1_UARTLCR_H_PEN = 1U << 1 ;

  // Field EPS: Even parity select. Controls the type of parity the UART uses during transmission and reception: 0 = odd parity. The UART generates or checks for an odd number of 1s in the data and parity bits. 1 = even parity. The UART generates or checks for an even number of 1s in the data and parity bits. This bit has no effect when the PEN bit disables parity checking and generation.
    const uint32_t UART1_UARTLCR_H_EPS = 1U << 2 ;

  // Field STP2: Two stop bits select. If this bit is set to 1, two stop bits are transmitted at the end of the frame. The receive logic does not check for two stop bits being received.
    const uint32_t UART1_UARTLCR_H_STP2 = 1U << 3 ;

  // Field FEN: Enable FIFOs: 0 = FIFOs are disabled (character mode) that is, the FIFOs become 1-byte-deep holding registers 1 = transmit and receive FIFO buffers are enabled (FIFO mode).
    const uint32_t UART1_UARTLCR_H_FEN = 1U << 4 ;

  // Field WLEN: Word length. These bits indicate the number of data bits transmitted or received in a frame as follows: b11 = 8 bits b10 = 7 bits b01 = 6 bits b00 = 5 bits.
    inline uint32_t UART1_UARTLCR_H_WLEN (const uint32_t inValue) {return (inValue & 0x3U) << 5 ; }

  // Field SPS: Stick parity select. 0 = stick parity is disabled 1 = either: * if the EPS bit is 0 then the parity bit is transmitted and checked as a 1 * if the EPS bit is 1 then the parity bit is transmitted and checked as a 0. This bit has no effect when the PEN bit disables parity checking and generation.
    const uint32_t UART1_UARTLCR_H_SPS = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register UARTCR: Control Register, UARTCR
  static volatile uint32_t & UART1_UARTCR __attribute__((unused)) = * ((volatile uint32_t *) (0x40038000 + 48)) ;

  // Field UARTEN: UART enable: 0 = UART is disabled. If the UART is disabled in the middle of transmission or reception, it completes the current character before stopping. 1 = the UART is enabled. Data transmission and reception occurs for either UART signals or SIR signals depending on the setting of the SIREN bit.
    const uint32_t UART1_UARTCR_UARTEN = 1U << 0 ;

  // Field SIREN: SIR enable: 0 = IrDA SIR ENDEC is disabled. nSIROUT remains LOW (no light pulse generated), and signal transitions on SIRIN have no effect. 1 = IrDA SIR ENDEC is enabled. Data is transmitted and received on nSIROUT and SIRIN. UARTTXD remains HIGH, in the marking state. Signal transitions on UARTRXD or modem status inputs have no effect. This bit has no effect if the UARTEN bit disables the UART.
    const uint32_t UART1_UARTCR_SIREN = 1U << 1 ;

  // Field SIRLP: SIR low-power IrDA mode. This bit selects the IrDA encoding mode. If this bit is cleared to 0, low-level bits are transmitted as an active high pulse with a width of 3 / 16th of the bit period. If this bit is set to 1, low-level bits are transmitted with a pulse width that is 3 times the period of the IrLPBaud16 input signal, regardless of the selected bit rate. Setting this bit uses less power, but might reduce transmission distances.
    const uint32_t UART1_UARTCR_SIRLP = 1U << 2 ;

  // Field LBE: Loopback enable. If this bit is set to 1 and the SIREN bit is set to 1 and the SIRTEST bit in the Test Control Register, UARTTCR is set to 1, then the nSIROUT path is inverted, and fed through to the SIRIN path. The SIRTEST bit in the test register must be set to 1 to override the normal half-duplex SIR operation. This must be the requirement for accessing the test registers during normal operation, and SIRTEST must be cleared to 0 when loopback testing is finished. This feature reduces the amount of external coupling required during system test. If this bit is set to 1, and the SIRTEST bit is set to 0, the UARTTXD path is fed through to the UARTRXD path. In either SIR mode or UART mode, when this bit is set, the modem outputs are also fed through to the modem inputs. This bit is cleared to 0 on reset, to disable loopback.
    const uint32_t UART1_UARTCR_LBE = 1U << 7 ;

  // Field TXE: Transmit enable. If this bit is set to 1, the transmit section of the UART is enabled. Data transmission occurs for either UART signals, or SIR signals depending on the setting of the SIREN bit. When the UART is disabled in the middle of transmission, it completes the current character before stopping.
    const uint32_t UART1_UARTCR_TXE = 1U << 8 ;

  // Field RXE: Receive enable. If this bit is set to 1, the receive section of the UART is enabled. Data reception occurs for either UART signals or SIR signals depending on the setting of the SIREN bit. When the UART is disabled in the middle of reception, it completes the current character before stopping.
    const uint32_t UART1_UARTCR_RXE = 1U << 9 ;

  // Field DTR: Data transmit ready. This bit is the complement of the UART data transmit ready, nUARTDTR, modem status output. That is, when the bit is programmed to a 1 then nUARTDTR is LOW.
    const uint32_t UART1_UARTCR_DTR = 1U << 10 ;

  // Field RTS: Request to send. This bit is the complement of the UART request to send, nUARTRTS, modem status output. That is, when the bit is programmed to a 1 then nUARTRTS is LOW.
    const uint32_t UART1_UARTCR_RTS = 1U << 11 ;

  // Field OUT1: This bit is the complement of the UART Out1 (nUARTOut1) modem status output. That is, when the bit is programmed to a 1 the output is 0. For DTE this can be used as Data Carrier Detect (DCD).
    const uint32_t UART1_UARTCR_OUT1 = 1U << 12 ;

  // Field OUT2: This bit is the complement of the UART Out2 (nUARTOut2) modem status output. That is, when the bit is programmed to a 1, the output is 0. For DTE this can be used as Ring Indicator (RI).
    const uint32_t UART1_UARTCR_OUT2 = 1U << 13 ;

  // Field RTSEN: RTS hardware flow control enable. If this bit is set to 1, RTS hardware flow control is enabled. Data is only requested when there is space in the receive FIFO for it to be received.
    const uint32_t UART1_UARTCR_RTSEN = 1U << 14 ;

  // Field CTSEN: CTS hardware flow control enable. If this bit is set to 1, CTS hardware flow control is enabled. Data is only transmitted when the nUARTCTS signal is asserted.
    const uint32_t UART1_UARTCR_CTSEN = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register UARTIFLS: Interrupt FIFO Level Select Register, UARTIFLS
  static volatile uint32_t & UART1_UARTIFLS __attribute__((unused)) = * ((volatile uint32_t *) (0x40038000 + 52)) ;

  // Field TXIFLSEL: Transmit interrupt FIFO level select. The trigger points for the transmit interrupt are as follows: b000 = Transmit FIFO becomes <= 1 / 8 full b001 = Transmit FIFO becomes <= 1 / 4 full b010 = Transmit FIFO becomes <= 1 / 2 full b011 = Transmit FIFO becomes <= 3 / 4 full b100 = Transmit FIFO becomes <= 7 / 8 full b101-b111 = reserved.
    inline uint32_t UART1_UARTIFLS_TXIFLSEL (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field RXIFLSEL: Receive interrupt FIFO level select. The trigger points for the receive interrupt are as follows: b000 = Receive FIFO becomes >= 1 / 8 full b001 = Receive FIFO becomes >= 1 / 4 full b010 = Receive FIFO becomes >= 1 / 2 full b011 = Receive FIFO becomes >= 3 / 4 full b100 = Receive FIFO becomes >= 7 / 8 full b101-b111 = reserved.
    inline uint32_t UART1_UARTIFLS_RXIFLSEL (const uint32_t inValue) {return (inValue & 0x7U) << 3 ; }

//------------------------------------------------------------------------------

//---  Register UARTIMSC: Interrupt Mask Set/Clear Register, UARTIMSC
  static volatile uint32_t & UART1_UARTIMSC __attribute__((unused)) = * ((volatile uint32_t *) (0x40038000 + 56)) ;

  // Field RIMIM: nUARTRI modem interrupt mask. A read returns the current mask for the UARTRIINTR interrupt. On a write of 1, the mask of the UARTRIINTR interrupt is set. A write of 0 clears the mask.
    const uint32_t UART1_UARTIMSC_RIMIM = 1U << 0 ;

  // Field CTSMIM: nUARTCTS modem interrupt mask. A read returns the current mask for the UARTCTSINTR interrupt. On a write of 1, the mask of the UARTCTSINTR interrupt is set. A write of 0 clears the mask.
    const uint32_t UART1_UARTIMSC_CTSMIM = 1U << 1 ;

  // Field DCDMIM: nUARTDCD modem interrupt mask. A read returns the current mask for the UARTDCDINTR interrupt. On a write of 1, the mask of the UARTDCDINTR interrupt is set. A write of 0 clears the mask.
    const uint32_t UART1_UARTIMSC_DCDMIM = 1U << 2 ;

  // Field DSRMIM: nUARTDSR modem interrupt mask. A read returns the current mask for the UARTDSRINTR interrupt. On a write of 1, the mask of the UARTDSRINTR interrupt is set. A write of 0 clears the mask.
    const uint32_t UART1_UARTIMSC_DSRMIM = 1U << 3 ;

  // Field RXIM: Receive interrupt mask. A read returns the current mask for the UARTRXINTR interrupt. On a write of 1, the mask of the UARTRXINTR interrupt is set. A write of 0 clears the mask.
    const uint32_t UART1_UARTIMSC_RXIM = 1U << 4 ;

  // Field TXIM: Transmit interrupt mask. A read returns the current mask for the UARTTXINTR interrupt. On a write of 1, the mask of the UARTTXINTR interrupt is set. A write of 0 clears the mask.
    const uint32_t UART1_UARTIMSC_TXIM = 1U << 5 ;

  // Field RTIM: Receive timeout interrupt mask. A read returns the current mask for the UARTRTINTR interrupt. On a write of 1, the mask of the UARTRTINTR interrupt is set. A write of 0 clears the mask.
    const uint32_t UART1_UARTIMSC_RTIM = 1U << 6 ;

  // Field FEIM: Framing error interrupt mask. A read returns the current mask for the UARTFEINTR interrupt. On a write of 1, the mask of the UARTFEINTR interrupt is set. A write of 0 clears the mask.
    const uint32_t UART1_UARTIMSC_FEIM = 1U << 7 ;

  // Field PEIM: Parity error interrupt mask. A read returns the current mask for the UARTPEINTR interrupt. On a write of 1, the mask of the UARTPEINTR interrupt is set. A write of 0 clears the mask.
    const uint32_t UART1_UARTIMSC_PEIM = 1U << 8 ;

  // Field BEIM: Break error interrupt mask. A read returns the current mask for the UARTBEINTR interrupt. On a write of 1, the mask of the UARTBEINTR interrupt is set. A write of 0 clears the mask.
    const uint32_t UART1_UARTIMSC_BEIM = 1U << 9 ;

  // Field OEIM: Overrun error interrupt mask. A read returns the current mask for the UARTOEINTR interrupt. On a write of 1, the mask of the UARTOEINTR interrupt is set. A write of 0 clears the mask.
    const uint32_t UART1_UARTIMSC_OEIM = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register UARTRIS: Raw Interrupt Status Register, UARTRIS
  static volatile uint32_t & UART1_UARTRIS __attribute__((unused)) = * ((volatile uint32_t *) (0x40038000 + 60)) ;

  // Field RIRMIS: nUARTRI modem interrupt status. Returns the raw interrupt state of the UARTRIINTR interrupt.
    const uint32_t UART1_UARTRIS_RIRMIS = 1U << 0 ;

  // Field CTSRMIS: nUARTCTS modem interrupt status. Returns the raw interrupt state of the UARTCTSINTR interrupt.
    const uint32_t UART1_UARTRIS_CTSRMIS = 1U << 1 ;

  // Field DCDRMIS: nUARTDCD modem interrupt status. Returns the raw interrupt state of the UARTDCDINTR interrupt.
    const uint32_t UART1_UARTRIS_DCDRMIS = 1U << 2 ;

  // Field DSRRMIS: nUARTDSR modem interrupt status. Returns the raw interrupt state of the UARTDSRINTR interrupt.
    const uint32_t UART1_UARTRIS_DSRRMIS = 1U << 3 ;

  // Field RXRIS: Receive interrupt status. Returns the raw interrupt state of the UARTRXINTR interrupt.
    const uint32_t UART1_UARTRIS_RXRIS = 1U << 4 ;

  // Field TXRIS: Transmit interrupt status. Returns the raw interrupt state of the UARTTXINTR interrupt.
    const uint32_t UART1_UARTRIS_TXRIS = 1U << 5 ;

  // Field RTRIS: Receive timeout interrupt status. Returns the raw interrupt state of the UARTRTINTR interrupt. a
    const uint32_t UART1_UARTRIS_RTRIS = 1U << 6 ;

  // Field FERIS: Framing error interrupt status. Returns the raw interrupt state of the UARTFEINTR interrupt.
    const uint32_t UART1_UARTRIS_FERIS = 1U << 7 ;

  // Field PERIS: Parity error interrupt status. Returns the raw interrupt state of the UARTPEINTR interrupt.
    const uint32_t UART1_UARTRIS_PERIS = 1U << 8 ;

  // Field BERIS: Break error interrupt status. Returns the raw interrupt state of the UARTBEINTR interrupt.
    const uint32_t UART1_UARTRIS_BERIS = 1U << 9 ;

  // Field OERIS: Overrun error interrupt status. Returns the raw interrupt state of the UARTOEINTR interrupt.
    const uint32_t UART1_UARTRIS_OERIS = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register UARTMIS: Masked Interrupt Status Register, UARTMIS
  static volatile uint32_t & UART1_UARTMIS __attribute__((unused)) = * ((volatile uint32_t *) (0x40038000 + 64)) ;

  // Field RIMMIS: nUARTRI modem masked interrupt status. Returns the masked interrupt state of the UARTRIINTR interrupt.
    const uint32_t UART1_UARTMIS_RIMMIS = 1U << 0 ;

  // Field CTSMMIS: nUARTCTS modem masked interrupt status. Returns the masked interrupt state of the UARTCTSINTR interrupt.
    const uint32_t UART1_UARTMIS_CTSMMIS = 1U << 1 ;

  // Field DCDMMIS: nUARTDCD modem masked interrupt status. Returns the masked interrupt state of the UARTDCDINTR interrupt.
    const uint32_t UART1_UARTMIS_DCDMMIS = 1U << 2 ;

  // Field DSRMMIS: nUARTDSR modem masked interrupt status. Returns the masked interrupt state of the UARTDSRINTR interrupt.
    const uint32_t UART1_UARTMIS_DSRMMIS = 1U << 3 ;

  // Field RXMIS: Receive masked interrupt status. Returns the masked interrupt state of the UARTRXINTR interrupt.
    const uint32_t UART1_UARTMIS_RXMIS = 1U << 4 ;

  // Field TXMIS: Transmit masked interrupt status. Returns the masked interrupt state of the UARTTXINTR interrupt.
    const uint32_t UART1_UARTMIS_TXMIS = 1U << 5 ;

  // Field RTMIS: Receive timeout masked interrupt status. Returns the masked interrupt state of the UARTRTINTR interrupt.
    const uint32_t UART1_UARTMIS_RTMIS = 1U << 6 ;

  // Field FEMIS: Framing error masked interrupt status. Returns the masked interrupt state of the UARTFEINTR interrupt.
    const uint32_t UART1_UARTMIS_FEMIS = 1U << 7 ;

  // Field PEMIS: Parity error masked interrupt status. Returns the masked interrupt state of the UARTPEINTR interrupt.
    const uint32_t UART1_UARTMIS_PEMIS = 1U << 8 ;

  // Field BEMIS: Break error masked interrupt status. Returns the masked interrupt state of the UARTBEINTR interrupt.
    const uint32_t UART1_UARTMIS_BEMIS = 1U << 9 ;

  // Field OEMIS: Overrun error masked interrupt status. Returns the masked interrupt state of the UARTOEINTR interrupt.
    const uint32_t UART1_UARTMIS_OEMIS = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register UARTICR: Interrupt Clear Register, UARTICR
  static volatile uint32_t & UART1_UARTICR __attribute__((unused)) = * ((volatile uint32_t *) (0x40038000 + 68)) ;

  // Field RIMIC: nUARTRI modem interrupt clear. Clears the UARTRIINTR interrupt.
    const uint32_t UART1_UARTICR_RIMIC = 1U << 0 ;

  // Field CTSMIC: nUARTCTS modem interrupt clear. Clears the UARTCTSINTR interrupt.
    const uint32_t UART1_UARTICR_CTSMIC = 1U << 1 ;

  // Field DCDMIC: nUARTDCD modem interrupt clear. Clears the UARTDCDINTR interrupt.
    const uint32_t UART1_UARTICR_DCDMIC = 1U << 2 ;

  // Field DSRMIC: nUARTDSR modem interrupt clear. Clears the UARTDSRINTR interrupt.
    const uint32_t UART1_UARTICR_DSRMIC = 1U << 3 ;

  // Field RXIC: Receive interrupt clear. Clears the UARTRXINTR interrupt.
    const uint32_t UART1_UARTICR_RXIC = 1U << 4 ;

  // Field TXIC: Transmit interrupt clear. Clears the UARTTXINTR interrupt.
    const uint32_t UART1_UARTICR_TXIC = 1U << 5 ;

  // Field RTIC: Receive timeout interrupt clear. Clears the UARTRTINTR interrupt.
    const uint32_t UART1_UARTICR_RTIC = 1U << 6 ;

  // Field FEIC: Framing error interrupt clear. Clears the UARTFEINTR interrupt.
    const uint32_t UART1_UARTICR_FEIC = 1U << 7 ;

  // Field PEIC: Parity error interrupt clear. Clears the UARTPEINTR interrupt.
    const uint32_t UART1_UARTICR_PEIC = 1U << 8 ;

  // Field BEIC: Break error interrupt clear. Clears the UARTBEINTR interrupt.
    const uint32_t UART1_UARTICR_BEIC = 1U << 9 ;

  // Field OEIC: Overrun error interrupt clear. Clears the UARTOEINTR interrupt.
    const uint32_t UART1_UARTICR_OEIC = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register UARTDMACR: DMA Control Register, UARTDMACR
  static volatile uint32_t & UART1_UARTDMACR __attribute__((unused)) = * ((volatile uint32_t *) (0x40038000 + 72)) ;

  // Field RXDMAE: Receive DMA enable. If this bit is set to 1, DMA for the receive FIFO is enabled.
    const uint32_t UART1_UARTDMACR_RXDMAE = 1U << 0 ;

  // Field TXDMAE: Transmit DMA enable. If this bit is set to 1, DMA for the transmit FIFO is enabled.
    const uint32_t UART1_UARTDMACR_TXDMAE = 1U << 1 ;

  // Field DMAONERR: DMA on error. If this bit is set to 1, the DMA receive request outputs, UARTRXDMASREQ or UARTRXDMABREQ, are disabled when the UART error interrupt is asserted.
    const uint32_t UART1_UARTDMACR_DMAONERR = 1U << 2 ;

//------------------------------------------------------------------------------

//---  Register UARTPERIPHID0: UARTPeriphID0 Register
  static volatile uint32_t & UART1_UARTPERIPHID0 __attribute__((unused)) = * ((volatile uint32_t *) (0x40038000 + 4064)) ;

  // Field PARTNUMBER0: These bits read back as 0x11
    inline uint32_t UART1_UARTPERIPHID0_PARTNUMBER0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register UARTPERIPHID1: UARTPeriphID1 Register
  static volatile uint32_t & UART1_UARTPERIPHID1 __attribute__((unused)) = * ((volatile uint32_t *) (0x40038000 + 4068)) ;

  // Field PARTNUMBER1: These bits read back as 0x0
    inline uint32_t UART1_UARTPERIPHID1_PARTNUMBER1 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field DESIGNER0: These bits read back as 0x1
    inline uint32_t UART1_UARTPERIPHID1_DESIGNER0 (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

//------------------------------------------------------------------------------

//---  Register UARTPERIPHID2: UARTPeriphID2 Register
  static volatile uint32_t & UART1_UARTPERIPHID2 __attribute__((unused)) = * ((volatile uint32_t *) (0x40038000 + 4072)) ;

  // Field DESIGNER1: These bits read back as 0x4
    inline uint32_t UART1_UARTPERIPHID2_DESIGNER1 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field REVISION: This field depends on the revision of the UART: r1p0 0x0 r1p1 0x1 r1p3 0x2 r1p4 0x2 r1p5 0x3
    inline uint32_t UART1_UARTPERIPHID2_REVISION (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

//------------------------------------------------------------------------------

//---  Register UARTPERIPHID3: UARTPeriphID3 Register
  static volatile uint32_t & UART1_UARTPERIPHID3 __attribute__((unused)) = * ((volatile uint32_t *) (0x40038000 + 4076)) ;

  // Field CONFIGURATION: These bits read back as 0x00
    inline uint32_t UART1_UARTPERIPHID3_CONFIGURATION (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register UARTPCELLID0: UARTPCellID0 Register
  static volatile uint32_t & UART1_UARTPCELLID0 __attribute__((unused)) = * ((volatile uint32_t *) (0x40038000 + 4080)) ;

  // Field UARTPCELLID0: These bits read back as 0x0D
    inline uint32_t UART1_UARTPCELLID0_UARTPCELLID0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register UARTPCELLID1: UARTPCellID1 Register
  static volatile uint32_t & UART1_UARTPCELLID1 __attribute__((unused)) = * ((volatile uint32_t *) (0x40038000 + 4084)) ;

  // Field UARTPCELLID1: These bits read back as 0xF0
    inline uint32_t UART1_UARTPCELLID1_UARTPCELLID1 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register UARTPCELLID2: UARTPCellID2 Register
  static volatile uint32_t & UART1_UARTPCELLID2 __attribute__((unused)) = * ((volatile uint32_t *) (0x40038000 + 4088)) ;

  // Field UARTPCELLID2: These bits read back as 0x05
    inline uint32_t UART1_UARTPCELLID2_UARTPCELLID2 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register UARTPCELLID3: UARTPCellID3 Register
  static volatile uint32_t & UART1_UARTPCELLID3 __attribute__((unused)) = * ((volatile uint32_t *) (0x40038000 + 4092)) ;

  // Field UARTPCELLID3: These bits read back as 0xB1
    inline uint32_t UART1_UARTPCELLID3_UARTPCELLID3 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral USBCTRL_REGS: USB FS/LS controller device registers
//------------------------------------------------------------------------------

//---  Register ADDR_ENDP: Device address and endpoint control
  static volatile uint32_t & USBCTRL_REGS_ADDR_ENDP __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 0)) ;

  // Field ADDRESS: In device mode, the address that the device should respond to. Set in response to a SET_ADDR setup packet from the host. In host mode set to the address of the device to communicate with.
    inline uint32_t USBCTRL_REGS_ADDR_ENDP_ADDRESS (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field ENDPOINT: Device endpoint to send data to. Only valid for HOST mode.
    inline uint32_t USBCTRL_REGS_ADDR_ENDP_ENDPOINT (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register ADDR_ENDP1: Interrupt endpoint 1. Only valid for HOST mode.
  static volatile uint32_t & USBCTRL_REGS_ADDR_ENDP1 __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 4)) ;

  // Field ADDRESS: Device address
    inline uint32_t USBCTRL_REGS_ADDR_ENDP1_ADDRESS (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field ENDPOINT: Endpoint number of the interrupt endpoint
    inline uint32_t USBCTRL_REGS_ADDR_ENDP1_ENDPOINT (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field INTEP_DIR: Direction of the interrupt endpoint. In=0, Out=1
    const uint32_t USBCTRL_REGS_ADDR_ENDP1_INTEP_DIR = 1U << 25 ;

  // Field INTEP_PREAMBLE: Interrupt EP requires preamble (is a low speed device on a full speed hub)
    const uint32_t USBCTRL_REGS_ADDR_ENDP1_INTEP_PREAMBLE = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register ADDR_ENDP2: Interrupt endpoint 2. Only valid for HOST mode.
  static volatile uint32_t & USBCTRL_REGS_ADDR_ENDP2 __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 8)) ;

  // Field ADDRESS: Device address
    inline uint32_t USBCTRL_REGS_ADDR_ENDP2_ADDRESS (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field ENDPOINT: Endpoint number of the interrupt endpoint
    inline uint32_t USBCTRL_REGS_ADDR_ENDP2_ENDPOINT (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field INTEP_DIR: Direction of the interrupt endpoint. In=0, Out=1
    const uint32_t USBCTRL_REGS_ADDR_ENDP2_INTEP_DIR = 1U << 25 ;

  // Field INTEP_PREAMBLE: Interrupt EP requires preamble (is a low speed device on a full speed hub)
    const uint32_t USBCTRL_REGS_ADDR_ENDP2_INTEP_PREAMBLE = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register ADDR_ENDP3: Interrupt endpoint 3. Only valid for HOST mode.
  static volatile uint32_t & USBCTRL_REGS_ADDR_ENDP3 __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 12)) ;

  // Field ADDRESS: Device address
    inline uint32_t USBCTRL_REGS_ADDR_ENDP3_ADDRESS (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field ENDPOINT: Endpoint number of the interrupt endpoint
    inline uint32_t USBCTRL_REGS_ADDR_ENDP3_ENDPOINT (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field INTEP_DIR: Direction of the interrupt endpoint. In=0, Out=1
    const uint32_t USBCTRL_REGS_ADDR_ENDP3_INTEP_DIR = 1U << 25 ;

  // Field INTEP_PREAMBLE: Interrupt EP requires preamble (is a low speed device on a full speed hub)
    const uint32_t USBCTRL_REGS_ADDR_ENDP3_INTEP_PREAMBLE = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register ADDR_ENDP4: Interrupt endpoint 4. Only valid for HOST mode.
  static volatile uint32_t & USBCTRL_REGS_ADDR_ENDP4 __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 16)) ;

  // Field ADDRESS: Device address
    inline uint32_t USBCTRL_REGS_ADDR_ENDP4_ADDRESS (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field ENDPOINT: Endpoint number of the interrupt endpoint
    inline uint32_t USBCTRL_REGS_ADDR_ENDP4_ENDPOINT (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field INTEP_DIR: Direction of the interrupt endpoint. In=0, Out=1
    const uint32_t USBCTRL_REGS_ADDR_ENDP4_INTEP_DIR = 1U << 25 ;

  // Field INTEP_PREAMBLE: Interrupt EP requires preamble (is a low speed device on a full speed hub)
    const uint32_t USBCTRL_REGS_ADDR_ENDP4_INTEP_PREAMBLE = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register ADDR_ENDP5: Interrupt endpoint 5. Only valid for HOST mode.
  static volatile uint32_t & USBCTRL_REGS_ADDR_ENDP5 __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 20)) ;

  // Field ADDRESS: Device address
    inline uint32_t USBCTRL_REGS_ADDR_ENDP5_ADDRESS (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field ENDPOINT: Endpoint number of the interrupt endpoint
    inline uint32_t USBCTRL_REGS_ADDR_ENDP5_ENDPOINT (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field INTEP_DIR: Direction of the interrupt endpoint. In=0, Out=1
    const uint32_t USBCTRL_REGS_ADDR_ENDP5_INTEP_DIR = 1U << 25 ;

  // Field INTEP_PREAMBLE: Interrupt EP requires preamble (is a low speed device on a full speed hub)
    const uint32_t USBCTRL_REGS_ADDR_ENDP5_INTEP_PREAMBLE = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register ADDR_ENDP6: Interrupt endpoint 6. Only valid for HOST mode.
  static volatile uint32_t & USBCTRL_REGS_ADDR_ENDP6 __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 24)) ;

  // Field ADDRESS: Device address
    inline uint32_t USBCTRL_REGS_ADDR_ENDP6_ADDRESS (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field ENDPOINT: Endpoint number of the interrupt endpoint
    inline uint32_t USBCTRL_REGS_ADDR_ENDP6_ENDPOINT (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field INTEP_DIR: Direction of the interrupt endpoint. In=0, Out=1
    const uint32_t USBCTRL_REGS_ADDR_ENDP6_INTEP_DIR = 1U << 25 ;

  // Field INTEP_PREAMBLE: Interrupt EP requires preamble (is a low speed device on a full speed hub)
    const uint32_t USBCTRL_REGS_ADDR_ENDP6_INTEP_PREAMBLE = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register ADDR_ENDP7: Interrupt endpoint 7. Only valid for HOST mode.
  static volatile uint32_t & USBCTRL_REGS_ADDR_ENDP7 __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 28)) ;

  // Field ADDRESS: Device address
    inline uint32_t USBCTRL_REGS_ADDR_ENDP7_ADDRESS (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field ENDPOINT: Endpoint number of the interrupt endpoint
    inline uint32_t USBCTRL_REGS_ADDR_ENDP7_ENDPOINT (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field INTEP_DIR: Direction of the interrupt endpoint. In=0, Out=1
    const uint32_t USBCTRL_REGS_ADDR_ENDP7_INTEP_DIR = 1U << 25 ;

  // Field INTEP_PREAMBLE: Interrupt EP requires preamble (is a low speed device on a full speed hub)
    const uint32_t USBCTRL_REGS_ADDR_ENDP7_INTEP_PREAMBLE = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register ADDR_ENDP8: Interrupt endpoint 8. Only valid for HOST mode.
  static volatile uint32_t & USBCTRL_REGS_ADDR_ENDP8 __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 32)) ;

  // Field ADDRESS: Device address
    inline uint32_t USBCTRL_REGS_ADDR_ENDP8_ADDRESS (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field ENDPOINT: Endpoint number of the interrupt endpoint
    inline uint32_t USBCTRL_REGS_ADDR_ENDP8_ENDPOINT (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field INTEP_DIR: Direction of the interrupt endpoint. In=0, Out=1
    const uint32_t USBCTRL_REGS_ADDR_ENDP8_INTEP_DIR = 1U << 25 ;

  // Field INTEP_PREAMBLE: Interrupt EP requires preamble (is a low speed device on a full speed hub)
    const uint32_t USBCTRL_REGS_ADDR_ENDP8_INTEP_PREAMBLE = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register ADDR_ENDP9: Interrupt endpoint 9. Only valid for HOST mode.
  static volatile uint32_t & USBCTRL_REGS_ADDR_ENDP9 __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 36)) ;

  // Field ADDRESS: Device address
    inline uint32_t USBCTRL_REGS_ADDR_ENDP9_ADDRESS (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field ENDPOINT: Endpoint number of the interrupt endpoint
    inline uint32_t USBCTRL_REGS_ADDR_ENDP9_ENDPOINT (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field INTEP_DIR: Direction of the interrupt endpoint. In=0, Out=1
    const uint32_t USBCTRL_REGS_ADDR_ENDP9_INTEP_DIR = 1U << 25 ;

  // Field INTEP_PREAMBLE: Interrupt EP requires preamble (is a low speed device on a full speed hub)
    const uint32_t USBCTRL_REGS_ADDR_ENDP9_INTEP_PREAMBLE = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register ADDR_ENDP10: Interrupt endpoint 10. Only valid for HOST mode.
  static volatile uint32_t & USBCTRL_REGS_ADDR_ENDP10 __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 40)) ;

  // Field ADDRESS: Device address
    inline uint32_t USBCTRL_REGS_ADDR_ENDP10_ADDRESS (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field ENDPOINT: Endpoint number of the interrupt endpoint
    inline uint32_t USBCTRL_REGS_ADDR_ENDP10_ENDPOINT (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field INTEP_DIR: Direction of the interrupt endpoint. In=0, Out=1
    const uint32_t USBCTRL_REGS_ADDR_ENDP10_INTEP_DIR = 1U << 25 ;

  // Field INTEP_PREAMBLE: Interrupt EP requires preamble (is a low speed device on a full speed hub)
    const uint32_t USBCTRL_REGS_ADDR_ENDP10_INTEP_PREAMBLE = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register ADDR_ENDP11: Interrupt endpoint 11. Only valid for HOST mode.
  static volatile uint32_t & USBCTRL_REGS_ADDR_ENDP11 __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 44)) ;

  // Field ADDRESS: Device address
    inline uint32_t USBCTRL_REGS_ADDR_ENDP11_ADDRESS (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field ENDPOINT: Endpoint number of the interrupt endpoint
    inline uint32_t USBCTRL_REGS_ADDR_ENDP11_ENDPOINT (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field INTEP_DIR: Direction of the interrupt endpoint. In=0, Out=1
    const uint32_t USBCTRL_REGS_ADDR_ENDP11_INTEP_DIR = 1U << 25 ;

  // Field INTEP_PREAMBLE: Interrupt EP requires preamble (is a low speed device on a full speed hub)
    const uint32_t USBCTRL_REGS_ADDR_ENDP11_INTEP_PREAMBLE = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register ADDR_ENDP12: Interrupt endpoint 12. Only valid for HOST mode.
  static volatile uint32_t & USBCTRL_REGS_ADDR_ENDP12 __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 48)) ;

  // Field ADDRESS: Device address
    inline uint32_t USBCTRL_REGS_ADDR_ENDP12_ADDRESS (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field ENDPOINT: Endpoint number of the interrupt endpoint
    inline uint32_t USBCTRL_REGS_ADDR_ENDP12_ENDPOINT (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field INTEP_DIR: Direction of the interrupt endpoint. In=0, Out=1
    const uint32_t USBCTRL_REGS_ADDR_ENDP12_INTEP_DIR = 1U << 25 ;

  // Field INTEP_PREAMBLE: Interrupt EP requires preamble (is a low speed device on a full speed hub)
    const uint32_t USBCTRL_REGS_ADDR_ENDP12_INTEP_PREAMBLE = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register ADDR_ENDP13: Interrupt endpoint 13. Only valid for HOST mode.
  static volatile uint32_t & USBCTRL_REGS_ADDR_ENDP13 __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 52)) ;

  // Field ADDRESS: Device address
    inline uint32_t USBCTRL_REGS_ADDR_ENDP13_ADDRESS (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field ENDPOINT: Endpoint number of the interrupt endpoint
    inline uint32_t USBCTRL_REGS_ADDR_ENDP13_ENDPOINT (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field INTEP_DIR: Direction of the interrupt endpoint. In=0, Out=1
    const uint32_t USBCTRL_REGS_ADDR_ENDP13_INTEP_DIR = 1U << 25 ;

  // Field INTEP_PREAMBLE: Interrupt EP requires preamble (is a low speed device on a full speed hub)
    const uint32_t USBCTRL_REGS_ADDR_ENDP13_INTEP_PREAMBLE = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register ADDR_ENDP14: Interrupt endpoint 14. Only valid for HOST mode.
  static volatile uint32_t & USBCTRL_REGS_ADDR_ENDP14 __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 56)) ;

  // Field ADDRESS: Device address
    inline uint32_t USBCTRL_REGS_ADDR_ENDP14_ADDRESS (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field ENDPOINT: Endpoint number of the interrupt endpoint
    inline uint32_t USBCTRL_REGS_ADDR_ENDP14_ENDPOINT (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field INTEP_DIR: Direction of the interrupt endpoint. In=0, Out=1
    const uint32_t USBCTRL_REGS_ADDR_ENDP14_INTEP_DIR = 1U << 25 ;

  // Field INTEP_PREAMBLE: Interrupt EP requires preamble (is a low speed device on a full speed hub)
    const uint32_t USBCTRL_REGS_ADDR_ENDP14_INTEP_PREAMBLE = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register ADDR_ENDP15: Interrupt endpoint 15. Only valid for HOST mode.
  static volatile uint32_t & USBCTRL_REGS_ADDR_ENDP15 __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 60)) ;

  // Field ADDRESS: Device address
    inline uint32_t USBCTRL_REGS_ADDR_ENDP15_ADDRESS (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field ENDPOINT: Endpoint number of the interrupt endpoint
    inline uint32_t USBCTRL_REGS_ADDR_ENDP15_ENDPOINT (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field INTEP_DIR: Direction of the interrupt endpoint. In=0, Out=1
    const uint32_t USBCTRL_REGS_ADDR_ENDP15_INTEP_DIR = 1U << 25 ;

  // Field INTEP_PREAMBLE: Interrupt EP requires preamble (is a low speed device on a full speed hub)
    const uint32_t USBCTRL_REGS_ADDR_ENDP15_INTEP_PREAMBLE = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register MAIN_CTRL: Main control register
  static volatile uint32_t & USBCTRL_REGS_MAIN_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 64)) ;

  // Field CONTROLLER_EN: Enable controller
    const uint32_t USBCTRL_REGS_MAIN_CTRL_CONTROLLER_EN = 1U << 0 ;

  // Field HOST_NDEVICE: Device mode = 0, Host mode = 1
    const uint32_t USBCTRL_REGS_MAIN_CTRL_HOST_NDEVICE = 1U << 1 ;

  // Field SIM_TIMING: Reduced timings for simulation
    const uint32_t USBCTRL_REGS_MAIN_CTRL_SIM_TIMING = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register SOF_WR: Set the SOF (Start of Frame) frame number in the host controller. The SOF packet is sent every 1ms and the host will increment the frame number by 1 each time.
  static volatile uint32_t & USBCTRL_REGS_SOF_WR __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 68)) ;

  // Field COUNT: 
    inline uint32_t USBCTRL_REGS_SOF_WR_COUNT (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SOF_RD: Read the last SOF (Start of Frame) frame number seen. In device mode the last SOF received from the host. In host mode the last SOF sent by the host.
  static volatile uint32_t & USBCTRL_REGS_SOF_RD __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 72)) ;

  // Field COUNT: 
    inline uint32_t USBCTRL_REGS_SOF_RD_COUNT (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SIE_CTRL: SIE control register
  static volatile uint32_t & USBCTRL_REGS_SIE_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 76)) ;

  // Field START_TRANS: Host: Start transaction
    const uint32_t USBCTRL_REGS_SIE_CTRL_START_TRANS = 1U << 0 ;

  // Field SEND_SETUP: Host: Send Setup packet
    const uint32_t USBCTRL_REGS_SIE_CTRL_SEND_SETUP = 1U << 1 ;

  // Field SEND_DATA: Host: Send transaction (OUT from host)
    const uint32_t USBCTRL_REGS_SIE_CTRL_SEND_DATA = 1U << 2 ;

  // Field RECEIVE_DATA: Host: Receive transaction (IN to host)
    const uint32_t USBCTRL_REGS_SIE_CTRL_RECEIVE_DATA = 1U << 3 ;

  // Field STOP_TRANS: Host: Stop transaction
    const uint32_t USBCTRL_REGS_SIE_CTRL_STOP_TRANS = 1U << 4 ;

  // Field PREAMBLE_EN: Host: Preable enable for LS device on FS hub
    const uint32_t USBCTRL_REGS_SIE_CTRL_PREAMBLE_EN = 1U << 6 ;

  // Field SOF_SYNC: Host: Delay packet(s) until after SOF
    const uint32_t USBCTRL_REGS_SIE_CTRL_SOF_SYNC = 1U << 8 ;

  // Field SOF_EN: Host: Enable SOF generation (for full speed bus)
    const uint32_t USBCTRL_REGS_SIE_CTRL_SOF_EN = 1U << 9 ;

  // Field KEEP_ALIVE_EN: Host: Enable keep alive packet (for low speed bus)
    const uint32_t USBCTRL_REGS_SIE_CTRL_KEEP_ALIVE_EN = 1U << 10 ;

  // Field VBUS_EN: Host: Enable VBUS
    const uint32_t USBCTRL_REGS_SIE_CTRL_VBUS_EN = 1U << 11 ;

  // Field RESUME: Device: Remote wakeup. Device can initiate its own resume after suspend.
    const uint32_t USBCTRL_REGS_SIE_CTRL_RESUME = 1U << 12 ;

  // Field RESET_BUS: Host: Reset bus
    const uint32_t USBCTRL_REGS_SIE_CTRL_RESET_BUS = 1U << 13 ;

  // Field PULLDOWN_EN: Host: Enable pull down resistors
    const uint32_t USBCTRL_REGS_SIE_CTRL_PULLDOWN_EN = 1U << 15 ;

  // Field PULLUP_EN: Device: Enable pull up resistor
    const uint32_t USBCTRL_REGS_SIE_CTRL_PULLUP_EN = 1U << 16 ;

  // Field RPU_OPT: Device: Pull-up strength (0=1K2, 1=2k3)
    const uint32_t USBCTRL_REGS_SIE_CTRL_RPU_OPT = 1U << 17 ;

  // Field TRANSCEIVER_PD: Power down bus transceiver
    const uint32_t USBCTRL_REGS_SIE_CTRL_TRANSCEIVER_PD = 1U << 18 ;

  // Field DIRECT_DM: Direct control of DM
    const uint32_t USBCTRL_REGS_SIE_CTRL_DIRECT_DM = 1U << 24 ;

  // Field DIRECT_DP: Direct control of DP
    const uint32_t USBCTRL_REGS_SIE_CTRL_DIRECT_DP = 1U << 25 ;

  // Field DIRECT_EN: Direct bus drive enable
    const uint32_t USBCTRL_REGS_SIE_CTRL_DIRECT_EN = 1U << 26 ;

  // Field EP0_INT_NAK: Device: Set bit in EP_STATUS_STALL_NAK when EP0 sends a NAK
    const uint32_t USBCTRL_REGS_SIE_CTRL_EP0_INT_NAK = 1U << 27 ;

  // Field EP0_INT_2BUF: Device: Set bit in BUFF_STATUS for every 2 buffers completed on EP0
    const uint32_t USBCTRL_REGS_SIE_CTRL_EP0_INT_2BUF = 1U << 28 ;

  // Field EP0_INT_1BUF: Device: Set bit in BUFF_STATUS for every buffer completed on EP0
    const uint32_t USBCTRL_REGS_SIE_CTRL_EP0_INT_1BUF = 1U << 29 ;

  // Field EP0_DOUBLE_BUF: Device: EP0 single buffered = 0, double buffered = 1
    const uint32_t USBCTRL_REGS_SIE_CTRL_EP0_DOUBLE_BUF = 1U << 30 ;

  // Field EP0_INT_STALL: Device: Set bit in EP_STATUS_STALL_NAK when EP0 sends a STALL
    const uint32_t USBCTRL_REGS_SIE_CTRL_EP0_INT_STALL = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register SIE_STATUS: SIE status register
  static volatile uint32_t & USBCTRL_REGS_SIE_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 80)) ;

  // Field VBUS_DETECTED: Device: VBUS Detected
    const uint32_t USBCTRL_REGS_SIE_STATUS_VBUS_DETECTED = 1U << 0 ;

  // Field LINE_STATE: USB bus line state
    inline uint32_t USBCTRL_REGS_SIE_STATUS_LINE_STATE (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field SUSPENDED: Bus in suspended state. Valid for device and host. Host and device will go into suspend if neither Keep Alive / SOF frames are enabled.
    const uint32_t USBCTRL_REGS_SIE_STATUS_SUSPENDED = 1U << 4 ;

  // Field SPEED: Host: device speed. Disconnected = 00, LS = 01, FS = 10
    inline uint32_t USBCTRL_REGS_SIE_STATUS_SPEED (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field VBUS_OVER_CURR: VBUS over current detected
    const uint32_t USBCTRL_REGS_SIE_STATUS_VBUS_OVER_CURR = 1U << 10 ;

  // Field RESUME: Host: Device has initiated a remote resume. Device: host has initiated a resume.
    const uint32_t USBCTRL_REGS_SIE_STATUS_RESUME = 1U << 11 ;

  // Field CONNECTED: Device: connected
    const uint32_t USBCTRL_REGS_SIE_STATUS_CONNECTED = 1U << 16 ;

  // Field SETUP_REC: Device: Setup packet received
    const uint32_t USBCTRL_REGS_SIE_STATUS_SETUP_REC = 1U << 17 ;

  // Field TRANS_COMPLETE: Transaction complete.\n\n Raised by device if:\n\n * An IN or OUT packet is sent with the `LAST_BUFF` bit set in the buffer control register\n\n Raised by host if:\n\n * A setup packet is sent when no data in or data out transaction follows * An IN packet is received and the `LAST_BUFF` bit is set in the buffer control register * An IN packet is received with zero length * An OUT packet is sent and the `LAST_BUFF` bit is set
    const uint32_t USBCTRL_REGS_SIE_STATUS_TRANS_COMPLETE = 1U << 18 ;

  // Field BUS_RESET: Device: bus reset received
    const uint32_t USBCTRL_REGS_SIE_STATUS_BUS_RESET = 1U << 19 ;

  // Field CRC_ERROR: CRC Error. Raised by the Serial RX engine.
    const uint32_t USBCTRL_REGS_SIE_STATUS_CRC_ERROR = 1U << 24 ;

  // Field BIT_STUFF_ERROR: Bit Stuff Error. Raised by the Serial RX engine.
    const uint32_t USBCTRL_REGS_SIE_STATUS_BIT_STUFF_ERROR = 1U << 25 ;

  // Field RX_OVERFLOW: RX overflow is raised by the Serial RX engine if the incoming data is too fast.
    const uint32_t USBCTRL_REGS_SIE_STATUS_RX_OVERFLOW = 1U << 26 ;

  // Field RX_TIMEOUT: RX timeout is raised by both the host and device if an ACK is not received in the maximum time specified by the USB spec.
    const uint32_t USBCTRL_REGS_SIE_STATUS_RX_TIMEOUT = 1U << 27 ;

  // Field NAK_REC: Host: NAK received
    const uint32_t USBCTRL_REGS_SIE_STATUS_NAK_REC = 1U << 28 ;

  // Field STALL_REC: Host: STALL received
    const uint32_t USBCTRL_REGS_SIE_STATUS_STALL_REC = 1U << 29 ;

  // Field ACK_REC: ACK received. Raised by both host and device.
    const uint32_t USBCTRL_REGS_SIE_STATUS_ACK_REC = 1U << 30 ;

  // Field DATA_SEQ_ERROR: Data Sequence Error.\n\n The device can raise a sequence error in the following conditions:\n\n * A SETUP packet is received followed by a DATA1 packet (data phase should always be DATA0) * An OUT packet is received from the host but doesn't match the data pid in the buffer control register read from DPSRAM\n\n The host can raise a data sequence error in the following conditions:\n\n * An IN packet from the device has the wrong data PID
    const uint32_t USBCTRL_REGS_SIE_STATUS_DATA_SEQ_ERROR = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register INT_EP_CTRL: interrupt endpoint control register
  static volatile uint32_t & USBCTRL_REGS_INT_EP_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 84)) ;

  // Field INT_EP_ACTIVE: Host: Enable interrupt endpoint 1 -> 15
    inline uint32_t USBCTRL_REGS_INT_EP_CTRL_INT_EP_ACTIVE (const uint32_t inValue) {return (inValue & 0x7FFFU) << 1 ; }

//------------------------------------------------------------------------------

//---  Register BUFF_STATUS: Buffer status register. A bit set here indicates that a buffer has completed on the endpoint (if the buffer interrupt is enabled). It is possible for 2 buffers to be completed, so clearing the buffer status bit may instantly re set it on the next clock cycle.
  static volatile uint32_t & USBCTRL_REGS_BUFF_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 88)) ;

  // Field EP0_IN: 
    const uint32_t USBCTRL_REGS_BUFF_STATUS_EP0_IN = 1U << 0 ;

  // Field EP0_OUT: 
    const uint32_t USBCTRL_REGS_BUFF_STATUS_EP0_OUT = 1U << 1 ;

  // Field EP1_IN: 
    const uint32_t USBCTRL_REGS_BUFF_STATUS_EP1_IN = 1U << 2 ;

  // Field EP1_OUT: 
    const uint32_t USBCTRL_REGS_BUFF_STATUS_EP1_OUT = 1U << 3 ;

  // Field EP2_IN: 
    const uint32_t USBCTRL_REGS_BUFF_STATUS_EP2_IN = 1U << 4 ;

  // Field EP2_OUT: 
    const uint32_t USBCTRL_REGS_BUFF_STATUS_EP2_OUT = 1U << 5 ;

  // Field EP3_IN: 
    const uint32_t USBCTRL_REGS_BUFF_STATUS_EP3_IN = 1U << 6 ;

  // Field EP3_OUT: 
    const uint32_t USBCTRL_REGS_BUFF_STATUS_EP3_OUT = 1U << 7 ;

  // Field EP4_IN: 
    const uint32_t USBCTRL_REGS_BUFF_STATUS_EP4_IN = 1U << 8 ;

  // Field EP4_OUT: 
    const uint32_t USBCTRL_REGS_BUFF_STATUS_EP4_OUT = 1U << 9 ;

  // Field EP5_IN: 
    const uint32_t USBCTRL_REGS_BUFF_STATUS_EP5_IN = 1U << 10 ;

  // Field EP5_OUT: 
    const uint32_t USBCTRL_REGS_BUFF_STATUS_EP5_OUT = 1U << 11 ;

  // Field EP6_IN: 
    const uint32_t USBCTRL_REGS_BUFF_STATUS_EP6_IN = 1U << 12 ;

  // Field EP6_OUT: 
    const uint32_t USBCTRL_REGS_BUFF_STATUS_EP6_OUT = 1U << 13 ;

  // Field EP7_IN: 
    const uint32_t USBCTRL_REGS_BUFF_STATUS_EP7_IN = 1U << 14 ;

  // Field EP7_OUT: 
    const uint32_t USBCTRL_REGS_BUFF_STATUS_EP7_OUT = 1U << 15 ;

  // Field EP8_IN: 
    const uint32_t USBCTRL_REGS_BUFF_STATUS_EP8_IN = 1U << 16 ;

  // Field EP8_OUT: 
    const uint32_t USBCTRL_REGS_BUFF_STATUS_EP8_OUT = 1U << 17 ;

  // Field EP9_IN: 
    const uint32_t USBCTRL_REGS_BUFF_STATUS_EP9_IN = 1U << 18 ;

  // Field EP9_OUT: 
    const uint32_t USBCTRL_REGS_BUFF_STATUS_EP9_OUT = 1U << 19 ;

  // Field EP10_IN: 
    const uint32_t USBCTRL_REGS_BUFF_STATUS_EP10_IN = 1U << 20 ;

  // Field EP10_OUT: 
    const uint32_t USBCTRL_REGS_BUFF_STATUS_EP10_OUT = 1U << 21 ;

  // Field EP11_IN: 
    const uint32_t USBCTRL_REGS_BUFF_STATUS_EP11_IN = 1U << 22 ;

  // Field EP11_OUT: 
    const uint32_t USBCTRL_REGS_BUFF_STATUS_EP11_OUT = 1U << 23 ;

  // Field EP12_IN: 
    const uint32_t USBCTRL_REGS_BUFF_STATUS_EP12_IN = 1U << 24 ;

  // Field EP12_OUT: 
    const uint32_t USBCTRL_REGS_BUFF_STATUS_EP12_OUT = 1U << 25 ;

  // Field EP13_IN: 
    const uint32_t USBCTRL_REGS_BUFF_STATUS_EP13_IN = 1U << 26 ;

  // Field EP13_OUT: 
    const uint32_t USBCTRL_REGS_BUFF_STATUS_EP13_OUT = 1U << 27 ;

  // Field EP14_IN: 
    const uint32_t USBCTRL_REGS_BUFF_STATUS_EP14_IN = 1U << 28 ;

  // Field EP14_OUT: 
    const uint32_t USBCTRL_REGS_BUFF_STATUS_EP14_OUT = 1U << 29 ;

  // Field EP15_IN: 
    const uint32_t USBCTRL_REGS_BUFF_STATUS_EP15_IN = 1U << 30 ;

  // Field EP15_OUT: 
    const uint32_t USBCTRL_REGS_BUFF_STATUS_EP15_OUT = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register BUFF_CPU_SHOULD_HANDLE: Which of the double buffers should be handled. Only valid if using an interrupt per buffer (i.e. not per 2 buffers). Not valid for host interrupt endpoint polling because they are only single buffered.
  static volatile uint32_t & USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 92)) ;

  // Field EP0_IN: 
    const uint32_t USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP0_IN = 1U << 0 ;

  // Field EP0_OUT: 
    const uint32_t USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP0_OUT = 1U << 1 ;

  // Field EP1_IN: 
    const uint32_t USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP1_IN = 1U << 2 ;

  // Field EP1_OUT: 
    const uint32_t USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP1_OUT = 1U << 3 ;

  // Field EP2_IN: 
    const uint32_t USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP2_IN = 1U << 4 ;

  // Field EP2_OUT: 
    const uint32_t USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP2_OUT = 1U << 5 ;

  // Field EP3_IN: 
    const uint32_t USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP3_IN = 1U << 6 ;

  // Field EP3_OUT: 
    const uint32_t USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP3_OUT = 1U << 7 ;

  // Field EP4_IN: 
    const uint32_t USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP4_IN = 1U << 8 ;

  // Field EP4_OUT: 
    const uint32_t USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP4_OUT = 1U << 9 ;

  // Field EP5_IN: 
    const uint32_t USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP5_IN = 1U << 10 ;

  // Field EP5_OUT: 
    const uint32_t USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP5_OUT = 1U << 11 ;

  // Field EP6_IN: 
    const uint32_t USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP6_IN = 1U << 12 ;

  // Field EP6_OUT: 
    const uint32_t USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP6_OUT = 1U << 13 ;

  // Field EP7_IN: 
    const uint32_t USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP7_IN = 1U << 14 ;

  // Field EP7_OUT: 
    const uint32_t USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP7_OUT = 1U << 15 ;

  // Field EP8_IN: 
    const uint32_t USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP8_IN = 1U << 16 ;

  // Field EP8_OUT: 
    const uint32_t USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP8_OUT = 1U << 17 ;

  // Field EP9_IN: 
    const uint32_t USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP9_IN = 1U << 18 ;

  // Field EP9_OUT: 
    const uint32_t USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP9_OUT = 1U << 19 ;

  // Field EP10_IN: 
    const uint32_t USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP10_IN = 1U << 20 ;

  // Field EP10_OUT: 
    const uint32_t USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP10_OUT = 1U << 21 ;

  // Field EP11_IN: 
    const uint32_t USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP11_IN = 1U << 22 ;

  // Field EP11_OUT: 
    const uint32_t USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP11_OUT = 1U << 23 ;

  // Field EP12_IN: 
    const uint32_t USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP12_IN = 1U << 24 ;

  // Field EP12_OUT: 
    const uint32_t USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP12_OUT = 1U << 25 ;

  // Field EP13_IN: 
    const uint32_t USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP13_IN = 1U << 26 ;

  // Field EP13_OUT: 
    const uint32_t USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP13_OUT = 1U << 27 ;

  // Field EP14_IN: 
    const uint32_t USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP14_IN = 1U << 28 ;

  // Field EP14_OUT: 
    const uint32_t USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP14_OUT = 1U << 29 ;

  // Field EP15_IN: 
    const uint32_t USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP15_IN = 1U << 30 ;

  // Field EP15_OUT: 
    const uint32_t USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP15_OUT = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register EP_ABORT: Device only: Can be set to ignore the buffer control register for this endpoint in case you would like to revoke a buffer. A NAK will be sent for every access to the endpoint until this bit is cleared. A corresponding bit in `EP_ABORT_DONE` is set when it is safe to modify the buffer control register.
  static volatile uint32_t & USBCTRL_REGS_EP_ABORT __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 96)) ;

  // Field EP0_IN: 
    const uint32_t USBCTRL_REGS_EP_ABORT_EP0_IN = 1U << 0 ;

  // Field EP0_OUT: 
    const uint32_t USBCTRL_REGS_EP_ABORT_EP0_OUT = 1U << 1 ;

  // Field EP1_IN: 
    const uint32_t USBCTRL_REGS_EP_ABORT_EP1_IN = 1U << 2 ;

  // Field EP1_OUT: 
    const uint32_t USBCTRL_REGS_EP_ABORT_EP1_OUT = 1U << 3 ;

  // Field EP2_IN: 
    const uint32_t USBCTRL_REGS_EP_ABORT_EP2_IN = 1U << 4 ;

  // Field EP2_OUT: 
    const uint32_t USBCTRL_REGS_EP_ABORT_EP2_OUT = 1U << 5 ;

  // Field EP3_IN: 
    const uint32_t USBCTRL_REGS_EP_ABORT_EP3_IN = 1U << 6 ;

  // Field EP3_OUT: 
    const uint32_t USBCTRL_REGS_EP_ABORT_EP3_OUT = 1U << 7 ;

  // Field EP4_IN: 
    const uint32_t USBCTRL_REGS_EP_ABORT_EP4_IN = 1U << 8 ;

  // Field EP4_OUT: 
    const uint32_t USBCTRL_REGS_EP_ABORT_EP4_OUT = 1U << 9 ;

  // Field EP5_IN: 
    const uint32_t USBCTRL_REGS_EP_ABORT_EP5_IN = 1U << 10 ;

  // Field EP5_OUT: 
    const uint32_t USBCTRL_REGS_EP_ABORT_EP5_OUT = 1U << 11 ;

  // Field EP6_IN: 
    const uint32_t USBCTRL_REGS_EP_ABORT_EP6_IN = 1U << 12 ;

  // Field EP6_OUT: 
    const uint32_t USBCTRL_REGS_EP_ABORT_EP6_OUT = 1U << 13 ;

  // Field EP7_IN: 
    const uint32_t USBCTRL_REGS_EP_ABORT_EP7_IN = 1U << 14 ;

  // Field EP7_OUT: 
    const uint32_t USBCTRL_REGS_EP_ABORT_EP7_OUT = 1U << 15 ;

  // Field EP8_IN: 
    const uint32_t USBCTRL_REGS_EP_ABORT_EP8_IN = 1U << 16 ;

  // Field EP8_OUT: 
    const uint32_t USBCTRL_REGS_EP_ABORT_EP8_OUT = 1U << 17 ;

  // Field EP9_IN: 
    const uint32_t USBCTRL_REGS_EP_ABORT_EP9_IN = 1U << 18 ;

  // Field EP9_OUT: 
    const uint32_t USBCTRL_REGS_EP_ABORT_EP9_OUT = 1U << 19 ;

  // Field EP10_IN: 
    const uint32_t USBCTRL_REGS_EP_ABORT_EP10_IN = 1U << 20 ;

  // Field EP10_OUT: 
    const uint32_t USBCTRL_REGS_EP_ABORT_EP10_OUT = 1U << 21 ;

  // Field EP11_IN: 
    const uint32_t USBCTRL_REGS_EP_ABORT_EP11_IN = 1U << 22 ;

  // Field EP11_OUT: 
    const uint32_t USBCTRL_REGS_EP_ABORT_EP11_OUT = 1U << 23 ;

  // Field EP12_IN: 
    const uint32_t USBCTRL_REGS_EP_ABORT_EP12_IN = 1U << 24 ;

  // Field EP12_OUT: 
    const uint32_t USBCTRL_REGS_EP_ABORT_EP12_OUT = 1U << 25 ;

  // Field EP13_IN: 
    const uint32_t USBCTRL_REGS_EP_ABORT_EP13_IN = 1U << 26 ;

  // Field EP13_OUT: 
    const uint32_t USBCTRL_REGS_EP_ABORT_EP13_OUT = 1U << 27 ;

  // Field EP14_IN: 
    const uint32_t USBCTRL_REGS_EP_ABORT_EP14_IN = 1U << 28 ;

  // Field EP14_OUT: 
    const uint32_t USBCTRL_REGS_EP_ABORT_EP14_OUT = 1U << 29 ;

  // Field EP15_IN: 
    const uint32_t USBCTRL_REGS_EP_ABORT_EP15_IN = 1U << 30 ;

  // Field EP15_OUT: 
    const uint32_t USBCTRL_REGS_EP_ABORT_EP15_OUT = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register EP_ABORT_DONE: Device only: Used in conjunction with `EP_ABORT`. Set once an endpoint is idle so the programmer knows it is safe to modify the buffer control register.
  static volatile uint32_t & USBCTRL_REGS_EP_ABORT_DONE __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 100)) ;

  // Field EP0_IN: 
    const uint32_t USBCTRL_REGS_EP_ABORT_DONE_EP0_IN = 1U << 0 ;

  // Field EP0_OUT: 
    const uint32_t USBCTRL_REGS_EP_ABORT_DONE_EP0_OUT = 1U << 1 ;

  // Field EP1_IN: 
    const uint32_t USBCTRL_REGS_EP_ABORT_DONE_EP1_IN = 1U << 2 ;

  // Field EP1_OUT: 
    const uint32_t USBCTRL_REGS_EP_ABORT_DONE_EP1_OUT = 1U << 3 ;

  // Field EP2_IN: 
    const uint32_t USBCTRL_REGS_EP_ABORT_DONE_EP2_IN = 1U << 4 ;

  // Field EP2_OUT: 
    const uint32_t USBCTRL_REGS_EP_ABORT_DONE_EP2_OUT = 1U << 5 ;

  // Field EP3_IN: 
    const uint32_t USBCTRL_REGS_EP_ABORT_DONE_EP3_IN = 1U << 6 ;

  // Field EP3_OUT: 
    const uint32_t USBCTRL_REGS_EP_ABORT_DONE_EP3_OUT = 1U << 7 ;

  // Field EP4_IN: 
    const uint32_t USBCTRL_REGS_EP_ABORT_DONE_EP4_IN = 1U << 8 ;

  // Field EP4_OUT: 
    const uint32_t USBCTRL_REGS_EP_ABORT_DONE_EP4_OUT = 1U << 9 ;

  // Field EP5_IN: 
    const uint32_t USBCTRL_REGS_EP_ABORT_DONE_EP5_IN = 1U << 10 ;

  // Field EP5_OUT: 
    const uint32_t USBCTRL_REGS_EP_ABORT_DONE_EP5_OUT = 1U << 11 ;

  // Field EP6_IN: 
    const uint32_t USBCTRL_REGS_EP_ABORT_DONE_EP6_IN = 1U << 12 ;

  // Field EP6_OUT: 
    const uint32_t USBCTRL_REGS_EP_ABORT_DONE_EP6_OUT = 1U << 13 ;

  // Field EP7_IN: 
    const uint32_t USBCTRL_REGS_EP_ABORT_DONE_EP7_IN = 1U << 14 ;

  // Field EP7_OUT: 
    const uint32_t USBCTRL_REGS_EP_ABORT_DONE_EP7_OUT = 1U << 15 ;

  // Field EP8_IN: 
    const uint32_t USBCTRL_REGS_EP_ABORT_DONE_EP8_IN = 1U << 16 ;

  // Field EP8_OUT: 
    const uint32_t USBCTRL_REGS_EP_ABORT_DONE_EP8_OUT = 1U << 17 ;

  // Field EP9_IN: 
    const uint32_t USBCTRL_REGS_EP_ABORT_DONE_EP9_IN = 1U << 18 ;

  // Field EP9_OUT: 
    const uint32_t USBCTRL_REGS_EP_ABORT_DONE_EP9_OUT = 1U << 19 ;

  // Field EP10_IN: 
    const uint32_t USBCTRL_REGS_EP_ABORT_DONE_EP10_IN = 1U << 20 ;

  // Field EP10_OUT: 
    const uint32_t USBCTRL_REGS_EP_ABORT_DONE_EP10_OUT = 1U << 21 ;

  // Field EP11_IN: 
    const uint32_t USBCTRL_REGS_EP_ABORT_DONE_EP11_IN = 1U << 22 ;

  // Field EP11_OUT: 
    const uint32_t USBCTRL_REGS_EP_ABORT_DONE_EP11_OUT = 1U << 23 ;

  // Field EP12_IN: 
    const uint32_t USBCTRL_REGS_EP_ABORT_DONE_EP12_IN = 1U << 24 ;

  // Field EP12_OUT: 
    const uint32_t USBCTRL_REGS_EP_ABORT_DONE_EP12_OUT = 1U << 25 ;

  // Field EP13_IN: 
    const uint32_t USBCTRL_REGS_EP_ABORT_DONE_EP13_IN = 1U << 26 ;

  // Field EP13_OUT: 
    const uint32_t USBCTRL_REGS_EP_ABORT_DONE_EP13_OUT = 1U << 27 ;

  // Field EP14_IN: 
    const uint32_t USBCTRL_REGS_EP_ABORT_DONE_EP14_IN = 1U << 28 ;

  // Field EP14_OUT: 
    const uint32_t USBCTRL_REGS_EP_ABORT_DONE_EP14_OUT = 1U << 29 ;

  // Field EP15_IN: 
    const uint32_t USBCTRL_REGS_EP_ABORT_DONE_EP15_IN = 1U << 30 ;

  // Field EP15_OUT: 
    const uint32_t USBCTRL_REGS_EP_ABORT_DONE_EP15_OUT = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register EP_STALL_ARM: Device: this bit must be set in conjunction with the `STALL` bit in the buffer control register to send a STALL on EP0. The device controller clears these bits when a SETUP packet is received because the USB spec requires that a STALL condition is cleared when a SETUP packet is received.
  static volatile uint32_t & USBCTRL_REGS_EP_STALL_ARM __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 104)) ;

  // Field EP0_IN: 
    const uint32_t USBCTRL_REGS_EP_STALL_ARM_EP0_IN = 1U << 0 ;

  // Field EP0_OUT: 
    const uint32_t USBCTRL_REGS_EP_STALL_ARM_EP0_OUT = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register NAK_POLL: Used by the host controller. Sets the wait time in microseconds before trying again if the device replies with a NAK.
  static volatile uint32_t & USBCTRL_REGS_NAK_POLL __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 108)) ;

  // Field DELAY_LS: NAK polling interval for a low speed device
    inline uint32_t USBCTRL_REGS_NAK_POLL_DELAY_LS (const uint32_t inValue) {return (inValue & 0x3FFU) << 0 ; }

  // Field DELAY_FS: NAK polling interval for a full speed device
    inline uint32_t USBCTRL_REGS_NAK_POLL_DELAY_FS (const uint32_t inValue) {return (inValue & 0x3FFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register EP_STATUS_STALL_NAK: Device: bits are set when the `IRQ_ON_NAK` or `IRQ_ON_STALL` bits are set. For EP0 this comes from `SIE_CTRL`. For all other endpoints it comes from the endpoint control register.
  static volatile uint32_t & USBCTRL_REGS_EP_STATUS_STALL_NAK __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 112)) ;

  // Field EP0_IN: 
    const uint32_t USBCTRL_REGS_EP_STATUS_STALL_NAK_EP0_IN = 1U << 0 ;

  // Field EP0_OUT: 
    const uint32_t USBCTRL_REGS_EP_STATUS_STALL_NAK_EP0_OUT = 1U << 1 ;

  // Field EP1_IN: 
    const uint32_t USBCTRL_REGS_EP_STATUS_STALL_NAK_EP1_IN = 1U << 2 ;

  // Field EP1_OUT: 
    const uint32_t USBCTRL_REGS_EP_STATUS_STALL_NAK_EP1_OUT = 1U << 3 ;

  // Field EP2_IN: 
    const uint32_t USBCTRL_REGS_EP_STATUS_STALL_NAK_EP2_IN = 1U << 4 ;

  // Field EP2_OUT: 
    const uint32_t USBCTRL_REGS_EP_STATUS_STALL_NAK_EP2_OUT = 1U << 5 ;

  // Field EP3_IN: 
    const uint32_t USBCTRL_REGS_EP_STATUS_STALL_NAK_EP3_IN = 1U << 6 ;

  // Field EP3_OUT: 
    const uint32_t USBCTRL_REGS_EP_STATUS_STALL_NAK_EP3_OUT = 1U << 7 ;

  // Field EP4_IN: 
    const uint32_t USBCTRL_REGS_EP_STATUS_STALL_NAK_EP4_IN = 1U << 8 ;

  // Field EP4_OUT: 
    const uint32_t USBCTRL_REGS_EP_STATUS_STALL_NAK_EP4_OUT = 1U << 9 ;

  // Field EP5_IN: 
    const uint32_t USBCTRL_REGS_EP_STATUS_STALL_NAK_EP5_IN = 1U << 10 ;

  // Field EP5_OUT: 
    const uint32_t USBCTRL_REGS_EP_STATUS_STALL_NAK_EP5_OUT = 1U << 11 ;

  // Field EP6_IN: 
    const uint32_t USBCTRL_REGS_EP_STATUS_STALL_NAK_EP6_IN = 1U << 12 ;

  // Field EP6_OUT: 
    const uint32_t USBCTRL_REGS_EP_STATUS_STALL_NAK_EP6_OUT = 1U << 13 ;

  // Field EP7_IN: 
    const uint32_t USBCTRL_REGS_EP_STATUS_STALL_NAK_EP7_IN = 1U << 14 ;

  // Field EP7_OUT: 
    const uint32_t USBCTRL_REGS_EP_STATUS_STALL_NAK_EP7_OUT = 1U << 15 ;

  // Field EP8_IN: 
    const uint32_t USBCTRL_REGS_EP_STATUS_STALL_NAK_EP8_IN = 1U << 16 ;

  // Field EP8_OUT: 
    const uint32_t USBCTRL_REGS_EP_STATUS_STALL_NAK_EP8_OUT = 1U << 17 ;

  // Field EP9_IN: 
    const uint32_t USBCTRL_REGS_EP_STATUS_STALL_NAK_EP9_IN = 1U << 18 ;

  // Field EP9_OUT: 
    const uint32_t USBCTRL_REGS_EP_STATUS_STALL_NAK_EP9_OUT = 1U << 19 ;

  // Field EP10_IN: 
    const uint32_t USBCTRL_REGS_EP_STATUS_STALL_NAK_EP10_IN = 1U << 20 ;

  // Field EP10_OUT: 
    const uint32_t USBCTRL_REGS_EP_STATUS_STALL_NAK_EP10_OUT = 1U << 21 ;

  // Field EP11_IN: 
    const uint32_t USBCTRL_REGS_EP_STATUS_STALL_NAK_EP11_IN = 1U << 22 ;

  // Field EP11_OUT: 
    const uint32_t USBCTRL_REGS_EP_STATUS_STALL_NAK_EP11_OUT = 1U << 23 ;

  // Field EP12_IN: 
    const uint32_t USBCTRL_REGS_EP_STATUS_STALL_NAK_EP12_IN = 1U << 24 ;

  // Field EP12_OUT: 
    const uint32_t USBCTRL_REGS_EP_STATUS_STALL_NAK_EP12_OUT = 1U << 25 ;

  // Field EP13_IN: 
    const uint32_t USBCTRL_REGS_EP_STATUS_STALL_NAK_EP13_IN = 1U << 26 ;

  // Field EP13_OUT: 
    const uint32_t USBCTRL_REGS_EP_STATUS_STALL_NAK_EP13_OUT = 1U << 27 ;

  // Field EP14_IN: 
    const uint32_t USBCTRL_REGS_EP_STATUS_STALL_NAK_EP14_IN = 1U << 28 ;

  // Field EP14_OUT: 
    const uint32_t USBCTRL_REGS_EP_STATUS_STALL_NAK_EP14_OUT = 1U << 29 ;

  // Field EP15_IN: 
    const uint32_t USBCTRL_REGS_EP_STATUS_STALL_NAK_EP15_IN = 1U << 30 ;

  // Field EP15_OUT: 
    const uint32_t USBCTRL_REGS_EP_STATUS_STALL_NAK_EP15_OUT = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register USB_MUXING: Where to connect the USB controller. Should be to_phy by default.
  static volatile uint32_t & USBCTRL_REGS_USB_MUXING __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 116)) ;

  // Field TO_PHY: 
    const uint32_t USBCTRL_REGS_USB_MUXING_TO_PHY = 1U << 0 ;

  // Field TO_EXTPHY: 
    const uint32_t USBCTRL_REGS_USB_MUXING_TO_EXTPHY = 1U << 1 ;

  // Field TO_DIGITAL_PAD: 
    const uint32_t USBCTRL_REGS_USB_MUXING_TO_DIGITAL_PAD = 1U << 2 ;

  // Field SOFTCON: 
    const uint32_t USBCTRL_REGS_USB_MUXING_SOFTCON = 1U << 3 ;

//------------------------------------------------------------------------------

//---  Register USB_PWR: Overrides for the power signals in the event that the VBUS signals are not hooked up to GPIO. Set the value of the override and then the override enable to switch over to the override value.
  static volatile uint32_t & USBCTRL_REGS_USB_PWR __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 120)) ;

  // Field VBUS_EN: 
    const uint32_t USBCTRL_REGS_USB_PWR_VBUS_EN = 1U << 0 ;

  // Field VBUS_EN_OVERRIDE_EN: 
    const uint32_t USBCTRL_REGS_USB_PWR_VBUS_EN_OVERRIDE_EN = 1U << 1 ;

  // Field VBUS_DETECT: 
    const uint32_t USBCTRL_REGS_USB_PWR_VBUS_DETECT = 1U << 2 ;

  // Field VBUS_DETECT_OVERRIDE_EN: 
    const uint32_t USBCTRL_REGS_USB_PWR_VBUS_DETECT_OVERRIDE_EN = 1U << 3 ;

  // Field OVERCURR_DETECT: 
    const uint32_t USBCTRL_REGS_USB_PWR_OVERCURR_DETECT = 1U << 4 ;

  // Field OVERCURR_DETECT_EN: 
    const uint32_t USBCTRL_REGS_USB_PWR_OVERCURR_DETECT_EN = 1U << 5 ;

//------------------------------------------------------------------------------

//---  Register USBPHY_DIRECT: This register allows for direct control of the USB phy. Use in conjunction with usbphy_direct_override register to enable each override bit.
  static volatile uint32_t & USBCTRL_REGS_USBPHY_DIRECT __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 124)) ;

  // Field DP_PULLUP_HISEL: Enable the second DP pull up resistor. 0 - Pull = Rpu2; 1 - Pull = Rpu1 + Rpu2
    const uint32_t USBCTRL_REGS_USBPHY_DIRECT_DP_PULLUP_HISEL = 1U << 0 ;

  // Field DP_PULLUP_EN: DP pull up enable
    const uint32_t USBCTRL_REGS_USBPHY_DIRECT_DP_PULLUP_EN = 1U << 1 ;

  // Field DP_PULLDN_EN: DP pull down enable
    const uint32_t USBCTRL_REGS_USBPHY_DIRECT_DP_PULLDN_EN = 1U << 2 ;

  // Field DM_PULLUP_HISEL: Enable the second DM pull up resistor. 0 - Pull = Rpu2; 1 - Pull = Rpu1 + Rpu2
    const uint32_t USBCTRL_REGS_USBPHY_DIRECT_DM_PULLUP_HISEL = 1U << 4 ;

  // Field DM_PULLUP_EN: DM pull up enable
    const uint32_t USBCTRL_REGS_USBPHY_DIRECT_DM_PULLUP_EN = 1U << 5 ;

  // Field DM_PULLDN_EN: DM pull down enable
    const uint32_t USBCTRL_REGS_USBPHY_DIRECT_DM_PULLDN_EN = 1U << 6 ;

  // Field TX_DP_OE: Output enable. If TX_DIFFMODE=1, OE for DPP/DPM diff pair. 0 - DPP/DPM in Hi-Z state; 1 - DPP/DPM driving\n If TX_DIFFMODE=0, OE for DPP only. 0 - DPP in Hi-Z state; 1 - DPP driving
    const uint32_t USBCTRL_REGS_USBPHY_DIRECT_TX_DP_OE = 1U << 8 ;

  // Field TX_DM_OE: Output enable. If TX_DIFFMODE=1, Ignored.\n If TX_DIFFMODE=0, OE for DPM only. 0 - DPM in Hi-Z state; 1 - DPM driving
    const uint32_t USBCTRL_REGS_USBPHY_DIRECT_TX_DM_OE = 1U << 9 ;

  // Field TX_DP: Output data. If TX_DIFFMODE=1, Drives DPP/DPM diff pair. TX_DP_OE=1 to enable drive. DPP=TX_DP, DPM=~TX_DP\n If TX_DIFFMODE=0, Drives DPP only. TX_DP_OE=1 to enable drive. DPP=TX_DP
    const uint32_t USBCTRL_REGS_USBPHY_DIRECT_TX_DP = 1U << 10 ;

  // Field TX_DM: Output data. TX_DIFFMODE=1, Ignored\n TX_DIFFMODE=0, Drives DPM only. TX_DM_OE=1 to enable drive. DPM=TX_DM
    const uint32_t USBCTRL_REGS_USBPHY_DIRECT_TX_DM = 1U << 11 ;

  // Field RX_PD: RX power down override (if override enable is set). 1 = powered down.
    const uint32_t USBCTRL_REGS_USBPHY_DIRECT_RX_PD = 1U << 12 ;

  // Field TX_PD: TX power down override (if override enable is set). 1 = powered down.
    const uint32_t USBCTRL_REGS_USBPHY_DIRECT_TX_PD = 1U << 13 ;

  // Field TX_FSSLEW: TX_FSSLEW=0: Low speed slew rate\n TX_FSSLEW=1: Full speed slew rate
    const uint32_t USBCTRL_REGS_USBPHY_DIRECT_TX_FSSLEW = 1U << 14 ;

  // Field TX_DIFFMODE: TX_DIFFMODE=0: Single ended mode\n TX_DIFFMODE=1: Differential drive mode (TX_DM, TX_DM_OE ignored)
    const uint32_t USBCTRL_REGS_USBPHY_DIRECT_TX_DIFFMODE = 1U << 15 ;

  // Field RX_DD: Differential RX
    const uint32_t USBCTRL_REGS_USBPHY_DIRECT_RX_DD = 1U << 16 ;

  // Field RX_DP: DPP pin state
    const uint32_t USBCTRL_REGS_USBPHY_DIRECT_RX_DP = 1U << 17 ;

  // Field RX_DM: DPM pin state
    const uint32_t USBCTRL_REGS_USBPHY_DIRECT_RX_DM = 1U << 18 ;

  // Field DP_OVCN: DP overcurrent
    const uint32_t USBCTRL_REGS_USBPHY_DIRECT_DP_OVCN = 1U << 19 ;

  // Field DM_OVCN: DM overcurrent
    const uint32_t USBCTRL_REGS_USBPHY_DIRECT_DM_OVCN = 1U << 20 ;

  // Field DP_OVV: DP over voltage
    const uint32_t USBCTRL_REGS_USBPHY_DIRECT_DP_OVV = 1U << 21 ;

  // Field DM_OVV: DM over voltage
    const uint32_t USBCTRL_REGS_USBPHY_DIRECT_DM_OVV = 1U << 22 ;

//------------------------------------------------------------------------------

//---  Register USBPHY_DIRECT_OVERRIDE: Override enable for each control in usbphy_direct
  static volatile uint32_t & USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 128)) ;

  // Field DP_PULLUP_HISEL_OVERRIDE_EN: 
    const uint32_t USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DP_PULLUP_HISEL_OVERRIDE_EN = 1U << 0 ;

  // Field DM_PULLUP_HISEL_OVERRIDE_EN: 
    const uint32_t USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DM_PULLUP_HISEL_OVERRIDE_EN = 1U << 1 ;

  // Field DP_PULLUP_EN_OVERRIDE_EN: 
    const uint32_t USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DP_PULLUP_EN_OVERRIDE_EN = 1U << 2 ;

  // Field DP_PULLDN_EN_OVERRIDE_EN: 
    const uint32_t USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DP_PULLDN_EN_OVERRIDE_EN = 1U << 3 ;

  // Field DM_PULLDN_EN_OVERRIDE_EN: 
    const uint32_t USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DM_PULLDN_EN_OVERRIDE_EN = 1U << 4 ;

  // Field TX_DP_OE_OVERRIDE_EN: 
    const uint32_t USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DP_OE_OVERRIDE_EN = 1U << 5 ;

  // Field TX_DM_OE_OVERRIDE_EN: 
    const uint32_t USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DM_OE_OVERRIDE_EN = 1U << 6 ;

  // Field TX_DP_OVERRIDE_EN: 
    const uint32_t USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DP_OVERRIDE_EN = 1U << 7 ;

  // Field TX_DM_OVERRIDE_EN: 
    const uint32_t USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DM_OVERRIDE_EN = 1U << 8 ;

  // Field RX_PD_OVERRIDE_EN: 
    const uint32_t USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_RX_PD_OVERRIDE_EN = 1U << 9 ;

  // Field TX_PD_OVERRIDE_EN: 
    const uint32_t USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_PD_OVERRIDE_EN = 1U << 10 ;

  // Field TX_FSSLEW_OVERRIDE_EN: 
    const uint32_t USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_FSSLEW_OVERRIDE_EN = 1U << 11 ;

  // Field DM_PULLUP_OVERRIDE_EN: 
    const uint32_t USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DM_PULLUP_OVERRIDE_EN = 1U << 12 ;

  // Field TX_DIFFMODE_OVERRIDE_EN: 
    const uint32_t USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DIFFMODE_OVERRIDE_EN = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register USBPHY_TRIM: Used to adjust trim values of USB phy pull down resistors.
  static volatile uint32_t & USBCTRL_REGS_USBPHY_TRIM __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 132)) ;

  // Field DP_PULLDN_TRIM: Value to drive to USB PHY\n DP pulldown resistor trim control\n Experimental data suggests that the reset value will work, but this register allows adjustment if required
    inline uint32_t USBCTRL_REGS_USBPHY_TRIM_DP_PULLDN_TRIM (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field DM_PULLDN_TRIM: Value to drive to USB PHY\n DM pulldown resistor trim control\n Experimental data suggests that the reset value will work, but this register allows adjustment if required
    inline uint32_t USBCTRL_REGS_USBPHY_TRIM_DM_PULLDN_TRIM (const uint32_t inValue) {return (inValue & 0x1FU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register INTR: Raw Interrupts
  static volatile uint32_t & USBCTRL_REGS_INTR __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 140)) ;

  // Field HOST_CONN_DIS: Host: raised when a device is connected or disconnected (i.e. when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED
    const uint32_t USBCTRL_REGS_INTR_HOST_CONN_DIS = 1U << 0 ;

  // Field HOST_RESUME: Host: raised when a device wakes up the host. Cleared by writing to SIE_STATUS.RESUME
    const uint32_t USBCTRL_REGS_INTR_HOST_RESUME = 1U << 1 ;

  // Field HOST_SOF: Host: raised every time the host sends a SOF (Start of Frame). Cleared by reading SOF_RD
    const uint32_t USBCTRL_REGS_INTR_HOST_SOF = 1U << 2 ;

  // Field TRANS_COMPLETE: Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this bit.
    const uint32_t USBCTRL_REGS_INTR_TRANS_COMPLETE = 1U << 3 ;

  // Field BUFF_STATUS: Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in BUFF_STATUS.
    const uint32_t USBCTRL_REGS_INTR_BUFF_STATUS = 1U << 4 ;

  // Field ERROR_DATA_SEQ: Source: SIE_STATUS.DATA_SEQ_ERROR
    const uint32_t USBCTRL_REGS_INTR_ERROR_DATA_SEQ = 1U << 5 ;

  // Field ERROR_RX_TIMEOUT: Source: SIE_STATUS.RX_TIMEOUT
    const uint32_t USBCTRL_REGS_INTR_ERROR_RX_TIMEOUT = 1U << 6 ;

  // Field ERROR_RX_OVERFLOW: Source: SIE_STATUS.RX_OVERFLOW
    const uint32_t USBCTRL_REGS_INTR_ERROR_RX_OVERFLOW = 1U << 7 ;

  // Field ERROR_BIT_STUFF: Source: SIE_STATUS.BIT_STUFF_ERROR
    const uint32_t USBCTRL_REGS_INTR_ERROR_BIT_STUFF = 1U << 8 ;

  // Field ERROR_CRC: Source: SIE_STATUS.CRC_ERROR
    const uint32_t USBCTRL_REGS_INTR_ERROR_CRC = 1U << 9 ;

  // Field STALL: Source: SIE_STATUS.STALL_REC
    const uint32_t USBCTRL_REGS_INTR_STALL = 1U << 10 ;

  // Field VBUS_DETECT: Source: SIE_STATUS.VBUS_DETECT
    const uint32_t USBCTRL_REGS_INTR_VBUS_DETECT = 1U << 11 ;

  // Field BUS_RESET: Source: SIE_STATUS.BUS_RESET
    const uint32_t USBCTRL_REGS_INTR_BUS_RESET = 1U << 12 ;

  // Field DEV_CONN_DIS: Set when the device connection state changes. Cleared by writing to SIE_STATUS.CONNECTED
    const uint32_t USBCTRL_REGS_INTR_DEV_CONN_DIS = 1U << 13 ;

  // Field DEV_SUSPEND: Set when the device suspend state changes. Cleared by writing to SIE_STATUS.SUSPENDED
    const uint32_t USBCTRL_REGS_INTR_DEV_SUSPEND = 1U << 14 ;

  // Field DEV_RESUME_FROM_HOST: Set when the device receives a resume from the host. Cleared by writing to SIE_STATUS.RESUME
    const uint32_t USBCTRL_REGS_INTR_DEV_RESUME_FROM_HOST = 1U << 15 ;

  // Field SETUP_REQ: Device. Source: SIE_STATUS.SETUP_REC
    const uint32_t USBCTRL_REGS_INTR_SETUP_REQ = 1U << 16 ;

  // Field DEV_SOF: Set every time the device receives a SOF (Start of Frame) packet. Cleared by reading SOF_RD
    const uint32_t USBCTRL_REGS_INTR_DEV_SOF = 1U << 17 ;

  // Field ABORT_DONE: Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in ABORT_DONE.
    const uint32_t USBCTRL_REGS_INTR_ABORT_DONE = 1U << 18 ;

  // Field EP_STALL_NAK: Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in EP_STATUS_STALL_NAK.
    const uint32_t USBCTRL_REGS_INTR_EP_STALL_NAK = 1U << 19 ;

//------------------------------------------------------------------------------

//---  Register INTE: Interrupt Enable
  static volatile uint32_t & USBCTRL_REGS_INTE __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 144)) ;

  // Field HOST_CONN_DIS: Host: raised when a device is connected or disconnected (i.e. when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED
    const uint32_t USBCTRL_REGS_INTE_HOST_CONN_DIS = 1U << 0 ;

  // Field HOST_RESUME: Host: raised when a device wakes up the host. Cleared by writing to SIE_STATUS.RESUME
    const uint32_t USBCTRL_REGS_INTE_HOST_RESUME = 1U << 1 ;

  // Field HOST_SOF: Host: raised every time the host sends a SOF (Start of Frame). Cleared by reading SOF_RD
    const uint32_t USBCTRL_REGS_INTE_HOST_SOF = 1U << 2 ;

  // Field TRANS_COMPLETE: Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this bit.
    const uint32_t USBCTRL_REGS_INTE_TRANS_COMPLETE = 1U << 3 ;

  // Field BUFF_STATUS: Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in BUFF_STATUS.
    const uint32_t USBCTRL_REGS_INTE_BUFF_STATUS = 1U << 4 ;

  // Field ERROR_DATA_SEQ: Source: SIE_STATUS.DATA_SEQ_ERROR
    const uint32_t USBCTRL_REGS_INTE_ERROR_DATA_SEQ = 1U << 5 ;

  // Field ERROR_RX_TIMEOUT: Source: SIE_STATUS.RX_TIMEOUT
    const uint32_t USBCTRL_REGS_INTE_ERROR_RX_TIMEOUT = 1U << 6 ;

  // Field ERROR_RX_OVERFLOW: Source: SIE_STATUS.RX_OVERFLOW
    const uint32_t USBCTRL_REGS_INTE_ERROR_RX_OVERFLOW = 1U << 7 ;

  // Field ERROR_BIT_STUFF: Source: SIE_STATUS.BIT_STUFF_ERROR
    const uint32_t USBCTRL_REGS_INTE_ERROR_BIT_STUFF = 1U << 8 ;

  // Field ERROR_CRC: Source: SIE_STATUS.CRC_ERROR
    const uint32_t USBCTRL_REGS_INTE_ERROR_CRC = 1U << 9 ;

  // Field STALL: Source: SIE_STATUS.STALL_REC
    const uint32_t USBCTRL_REGS_INTE_STALL = 1U << 10 ;

  // Field VBUS_DETECT: Source: SIE_STATUS.VBUS_DETECT
    const uint32_t USBCTRL_REGS_INTE_VBUS_DETECT = 1U << 11 ;

  // Field BUS_RESET: Source: SIE_STATUS.BUS_RESET
    const uint32_t USBCTRL_REGS_INTE_BUS_RESET = 1U << 12 ;

  // Field DEV_CONN_DIS: Set when the device connection state changes. Cleared by writing to SIE_STATUS.CONNECTED
    const uint32_t USBCTRL_REGS_INTE_DEV_CONN_DIS = 1U << 13 ;

  // Field DEV_SUSPEND: Set when the device suspend state changes. Cleared by writing to SIE_STATUS.SUSPENDED
    const uint32_t USBCTRL_REGS_INTE_DEV_SUSPEND = 1U << 14 ;

  // Field DEV_RESUME_FROM_HOST: Set when the device receives a resume from the host. Cleared by writing to SIE_STATUS.RESUME
    const uint32_t USBCTRL_REGS_INTE_DEV_RESUME_FROM_HOST = 1U << 15 ;

  // Field SETUP_REQ: Device. Source: SIE_STATUS.SETUP_REC
    const uint32_t USBCTRL_REGS_INTE_SETUP_REQ = 1U << 16 ;

  // Field DEV_SOF: Set every time the device receives a SOF (Start of Frame) packet. Cleared by reading SOF_RD
    const uint32_t USBCTRL_REGS_INTE_DEV_SOF = 1U << 17 ;

  // Field ABORT_DONE: Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in ABORT_DONE.
    const uint32_t USBCTRL_REGS_INTE_ABORT_DONE = 1U << 18 ;

  // Field EP_STALL_NAK: Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in EP_STATUS_STALL_NAK.
    const uint32_t USBCTRL_REGS_INTE_EP_STALL_NAK = 1U << 19 ;

//------------------------------------------------------------------------------

//---  Register INTF: Interrupt Force
  static volatile uint32_t & USBCTRL_REGS_INTF __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 148)) ;

  // Field HOST_CONN_DIS: Host: raised when a device is connected or disconnected (i.e. when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED
    const uint32_t USBCTRL_REGS_INTF_HOST_CONN_DIS = 1U << 0 ;

  // Field HOST_RESUME: Host: raised when a device wakes up the host. Cleared by writing to SIE_STATUS.RESUME
    const uint32_t USBCTRL_REGS_INTF_HOST_RESUME = 1U << 1 ;

  // Field HOST_SOF: Host: raised every time the host sends a SOF (Start of Frame). Cleared by reading SOF_RD
    const uint32_t USBCTRL_REGS_INTF_HOST_SOF = 1U << 2 ;

  // Field TRANS_COMPLETE: Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this bit.
    const uint32_t USBCTRL_REGS_INTF_TRANS_COMPLETE = 1U << 3 ;

  // Field BUFF_STATUS: Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in BUFF_STATUS.
    const uint32_t USBCTRL_REGS_INTF_BUFF_STATUS = 1U << 4 ;

  // Field ERROR_DATA_SEQ: Source: SIE_STATUS.DATA_SEQ_ERROR
    const uint32_t USBCTRL_REGS_INTF_ERROR_DATA_SEQ = 1U << 5 ;

  // Field ERROR_RX_TIMEOUT: Source: SIE_STATUS.RX_TIMEOUT
    const uint32_t USBCTRL_REGS_INTF_ERROR_RX_TIMEOUT = 1U << 6 ;

  // Field ERROR_RX_OVERFLOW: Source: SIE_STATUS.RX_OVERFLOW
    const uint32_t USBCTRL_REGS_INTF_ERROR_RX_OVERFLOW = 1U << 7 ;

  // Field ERROR_BIT_STUFF: Source: SIE_STATUS.BIT_STUFF_ERROR
    const uint32_t USBCTRL_REGS_INTF_ERROR_BIT_STUFF = 1U << 8 ;

  // Field ERROR_CRC: Source: SIE_STATUS.CRC_ERROR
    const uint32_t USBCTRL_REGS_INTF_ERROR_CRC = 1U << 9 ;

  // Field STALL: Source: SIE_STATUS.STALL_REC
    const uint32_t USBCTRL_REGS_INTF_STALL = 1U << 10 ;

  // Field VBUS_DETECT: Source: SIE_STATUS.VBUS_DETECT
    const uint32_t USBCTRL_REGS_INTF_VBUS_DETECT = 1U << 11 ;

  // Field BUS_RESET: Source: SIE_STATUS.BUS_RESET
    const uint32_t USBCTRL_REGS_INTF_BUS_RESET = 1U << 12 ;

  // Field DEV_CONN_DIS: Set when the device connection state changes. Cleared by writing to SIE_STATUS.CONNECTED
    const uint32_t USBCTRL_REGS_INTF_DEV_CONN_DIS = 1U << 13 ;

  // Field DEV_SUSPEND: Set when the device suspend state changes. Cleared by writing to SIE_STATUS.SUSPENDED
    const uint32_t USBCTRL_REGS_INTF_DEV_SUSPEND = 1U << 14 ;

  // Field DEV_RESUME_FROM_HOST: Set when the device receives a resume from the host. Cleared by writing to SIE_STATUS.RESUME
    const uint32_t USBCTRL_REGS_INTF_DEV_RESUME_FROM_HOST = 1U << 15 ;

  // Field SETUP_REQ: Device. Source: SIE_STATUS.SETUP_REC
    const uint32_t USBCTRL_REGS_INTF_SETUP_REQ = 1U << 16 ;

  // Field DEV_SOF: Set every time the device receives a SOF (Start of Frame) packet. Cleared by reading SOF_RD
    const uint32_t USBCTRL_REGS_INTF_DEV_SOF = 1U << 17 ;

  // Field ABORT_DONE: Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in ABORT_DONE.
    const uint32_t USBCTRL_REGS_INTF_ABORT_DONE = 1U << 18 ;

  // Field EP_STALL_NAK: Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in EP_STATUS_STALL_NAK.
    const uint32_t USBCTRL_REGS_INTF_EP_STALL_NAK = 1U << 19 ;

//------------------------------------------------------------------------------

//---  Register INTS: Interrupt status after masking & forcing
  static volatile uint32_t & USBCTRL_REGS_INTS __attribute__((unused)) = * ((volatile uint32_t *) (0x50110000 + 152)) ;

  // Field HOST_CONN_DIS: Host: raised when a device is connected or disconnected (i.e. when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED
    const uint32_t USBCTRL_REGS_INTS_HOST_CONN_DIS = 1U << 0 ;

  // Field HOST_RESUME: Host: raised when a device wakes up the host. Cleared by writing to SIE_STATUS.RESUME
    const uint32_t USBCTRL_REGS_INTS_HOST_RESUME = 1U << 1 ;

  // Field HOST_SOF: Host: raised every time the host sends a SOF (Start of Frame). Cleared by reading SOF_RD
    const uint32_t USBCTRL_REGS_INTS_HOST_SOF = 1U << 2 ;

  // Field TRANS_COMPLETE: Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this bit.
    const uint32_t USBCTRL_REGS_INTS_TRANS_COMPLETE = 1U << 3 ;

  // Field BUFF_STATUS: Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in BUFF_STATUS.
    const uint32_t USBCTRL_REGS_INTS_BUFF_STATUS = 1U << 4 ;

  // Field ERROR_DATA_SEQ: Source: SIE_STATUS.DATA_SEQ_ERROR
    const uint32_t USBCTRL_REGS_INTS_ERROR_DATA_SEQ = 1U << 5 ;

  // Field ERROR_RX_TIMEOUT: Source: SIE_STATUS.RX_TIMEOUT
    const uint32_t USBCTRL_REGS_INTS_ERROR_RX_TIMEOUT = 1U << 6 ;

  // Field ERROR_RX_OVERFLOW: Source: SIE_STATUS.RX_OVERFLOW
    const uint32_t USBCTRL_REGS_INTS_ERROR_RX_OVERFLOW = 1U << 7 ;

  // Field ERROR_BIT_STUFF: Source: SIE_STATUS.BIT_STUFF_ERROR
    const uint32_t USBCTRL_REGS_INTS_ERROR_BIT_STUFF = 1U << 8 ;

  // Field ERROR_CRC: Source: SIE_STATUS.CRC_ERROR
    const uint32_t USBCTRL_REGS_INTS_ERROR_CRC = 1U << 9 ;

  // Field STALL: Source: SIE_STATUS.STALL_REC
    const uint32_t USBCTRL_REGS_INTS_STALL = 1U << 10 ;

  // Field VBUS_DETECT: Source: SIE_STATUS.VBUS_DETECT
    const uint32_t USBCTRL_REGS_INTS_VBUS_DETECT = 1U << 11 ;

  // Field BUS_RESET: Source: SIE_STATUS.BUS_RESET
    const uint32_t USBCTRL_REGS_INTS_BUS_RESET = 1U << 12 ;

  // Field DEV_CONN_DIS: Set when the device connection state changes. Cleared by writing to SIE_STATUS.CONNECTED
    const uint32_t USBCTRL_REGS_INTS_DEV_CONN_DIS = 1U << 13 ;

  // Field DEV_SUSPEND: Set when the device suspend state changes. Cleared by writing to SIE_STATUS.SUSPENDED
    const uint32_t USBCTRL_REGS_INTS_DEV_SUSPEND = 1U << 14 ;

  // Field DEV_RESUME_FROM_HOST: Set when the device receives a resume from the host. Cleared by writing to SIE_STATUS.RESUME
    const uint32_t USBCTRL_REGS_INTS_DEV_RESUME_FROM_HOST = 1U << 15 ;

  // Field SETUP_REQ: Device. Source: SIE_STATUS.SETUP_REC
    const uint32_t USBCTRL_REGS_INTS_SETUP_REQ = 1U << 16 ;

  // Field DEV_SOF: Set every time the device receives a SOF (Start of Frame) packet. Cleared by reading SOF_RD
    const uint32_t USBCTRL_REGS_INTS_DEV_SOF = 1U << 17 ;

  // Field ABORT_DONE: Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in ABORT_DONE.
    const uint32_t USBCTRL_REGS_INTS_ABORT_DONE = 1U << 18 ;

  // Field EP_STALL_NAK: Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in EP_STATUS_STALL_NAK.
    const uint32_t USBCTRL_REGS_INTS_EP_STALL_NAK = 1U << 19 ;

//------------------------------------------------------------------------------
// Peripheral VREG_AND_CHIP_RESET: control and status for on-chip voltage regulator and chip level reset subsystem
//------------------------------------------------------------------------------

//---  Register VREG: Voltage regulator control and status
  static volatile uint32_t & VREG_AND_CHIP_RESET_VREG __attribute__((unused)) = * ((volatile uint32_t *) (0x40064000 + 0)) ;

  // Field EN: enable\n 0=not enabled, 1=enabled
    const uint32_t VREG_AND_CHIP_RESET_VREG_EN = 1U << 0 ;

  // Field HIZ: high impedance mode select\n 0=not in high impedance mode, 1=in high impedance mode
    const uint32_t VREG_AND_CHIP_RESET_VREG_HIZ = 1U << 1 ;

  // Field VSEL: output voltage select\n 0000 to 0101 - 0.80V\n 0110 - 0.85V\n 0111 - 0.90V\n 1000 - 0.95V\n 1001 - 1.00V\n 1010 - 1.05V\n 1011 - 1.10V (default)\n 1100 - 1.15V\n 1101 - 1.20V\n 1110 - 1.25V\n 1111 - 1.30V
    inline uint32_t VREG_AND_CHIP_RESET_VREG_VSEL (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field ROK: regulation status\n 0=not in regulation, 1=in regulation
    const uint32_t VREG_AND_CHIP_RESET_VREG_ROK = 1U << 12 ;

//------------------------------------------------------------------------------

//---  Register BOD: brown-out detection control
  static volatile uint32_t & VREG_AND_CHIP_RESET_BOD __attribute__((unused)) = * ((volatile uint32_t *) (0x40064000 + 4)) ;

  // Field EN: enable\n 0=not enabled, 1=enabled
    const uint32_t VREG_AND_CHIP_RESET_BOD_EN = 1U << 0 ;

  // Field VSEL: threshold select\n 0000 - 0.473V\n 0001 - 0.516V\n 0010 - 0.559V\n 0011 - 0.602V\n 0100 - 0.645V\n 0101 - 0.688V\n 0110 - 0.731V\n 0111 - 0.774V\n 1000 - 0.817V\n 1001 - 0.860V (default)\n 1010 - 0.903V\n 1011 - 0.946V\n 1100 - 0.989V\n 1101 - 1.032V\n 1110 - 1.075V\n 1111 - 1.118V
    inline uint32_t VREG_AND_CHIP_RESET_BOD_VSEL (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

//------------------------------------------------------------------------------

//---  Register CHIP_RESET: Chip reset control and status
  static volatile uint32_t & VREG_AND_CHIP_RESET_CHIP_RESET __attribute__((unused)) = * ((volatile uint32_t *) (0x40064000 + 8)) ;

  // Field HAD_POR: Last reset was from the power-on reset or brown-out detection blocks
    const uint32_t VREG_AND_CHIP_RESET_CHIP_RESET_HAD_POR = 1U << 8 ;

  // Field HAD_RUN: Last reset was from the RUN pin
    const uint32_t VREG_AND_CHIP_RESET_CHIP_RESET_HAD_RUN = 1U << 16 ;

  // Field HAD_PSM_RESTART: Last reset was from the debug port
    const uint32_t VREG_AND_CHIP_RESET_CHIP_RESET_HAD_PSM_RESTART = 1U << 20 ;

  // Field PSM_RESTART_FLAG: This is set by psm_restart from the debugger.\n Its purpose is to branch bootcode to a safe mode when the debugger has issued a psm_restart in order to recover from a boot lock-up.\n In the safe mode the debugger can repair the boot code, clear this flag then reboot the processor.
    const uint32_t VREG_AND_CHIP_RESET_CHIP_RESET_PSM_RESTART_FLAG = 1U << 24 ;

//------------------------------------------------------------------------------
// Peripheral WATCHDOG: 
//------------------------------------------------------------------------------

//---  Register CTRL: Watchdog control\n The rst_wdsel register determines which subsystems are reset when the watchdog is triggered.\n The watchdog can be triggered in software.
  static volatile uint32_t & WATCHDOG_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40058000 + 0)) ;

  // Field TIME: Indicates the number of ticks / 2 (see errata RP2040-E1) before a watchdog reset will be triggered
    inline uint32_t WATCHDOG_CTRL_TIME (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 0 ; }

  // Field PAUSE_JTAG: Pause the watchdog timer when JTAG is accessing the bus fabric
    const uint32_t WATCHDOG_CTRL_PAUSE_JTAG = 1U << 24 ;

  // Field PAUSE_DBG0: Pause the watchdog timer when processor 0 is in debug mode
    const uint32_t WATCHDOG_CTRL_PAUSE_DBG0 = 1U << 25 ;

  // Field PAUSE_DBG1: Pause the watchdog timer when processor 1 is in debug mode
    const uint32_t WATCHDOG_CTRL_PAUSE_DBG1 = 1U << 26 ;

  // Field ENABLE: When not enabled the watchdog timer is paused
    const uint32_t WATCHDOG_CTRL_ENABLE = 1U << 30 ;

  // Field TRIGGER: Trigger a watchdog reset
    const uint32_t WATCHDOG_CTRL_TRIGGER = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register LOAD: Load the watchdog timer. The maximum setting is 0xffffff which corresponds to 0xffffff / 2 ticks before triggering a watchdog reset (see errata RP2040-E1).
  static volatile uint32_t & WATCHDOG_LOAD __attribute__((unused)) = * ((volatile uint32_t *) (0x40058000 + 4)) ;

  // Field LOAD: 
    inline uint32_t WATCHDOG_LOAD_LOAD (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register REASON: Logs the reason for the last reset. Both bits are zero for the case of a hardware reset.
  static volatile uint32_t & WATCHDOG_REASON __attribute__((unused)) = * ((volatile uint32_t *) (0x40058000 + 8)) ;

  // Field TIMER: 
    const uint32_t WATCHDOG_REASON_TIMER = 1U << 0 ;

  // Field FORCE: 
    const uint32_t WATCHDOG_REASON_FORCE = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register SCRATCH0: Scratch register. Information persists through soft reset of the chip.
  static volatile uint32_t & WATCHDOG_SCRATCH0 __attribute__((unused)) = * ((volatile uint32_t *) (0x40058000 + 12)) ;

//------------------------------------------------------------------------------

//---  Register SCRATCH1: Scratch register. Information persists through soft reset of the chip.
  static volatile uint32_t & WATCHDOG_SCRATCH1 __attribute__((unused)) = * ((volatile uint32_t *) (0x40058000 + 16)) ;

//------------------------------------------------------------------------------

//---  Register SCRATCH2: Scratch register. Information persists through soft reset of the chip.
  static volatile uint32_t & WATCHDOG_SCRATCH2 __attribute__((unused)) = * ((volatile uint32_t *) (0x40058000 + 20)) ;

//------------------------------------------------------------------------------

//---  Register SCRATCH3: Scratch register. Information persists through soft reset of the chip.
  static volatile uint32_t & WATCHDOG_SCRATCH3 __attribute__((unused)) = * ((volatile uint32_t *) (0x40058000 + 24)) ;

//------------------------------------------------------------------------------

//---  Register SCRATCH4: Scratch register. Information persists through soft reset of the chip.
  static volatile uint32_t & WATCHDOG_SCRATCH4 __attribute__((unused)) = * ((volatile uint32_t *) (0x40058000 + 28)) ;

//------------------------------------------------------------------------------

//---  Register SCRATCH5: Scratch register. Information persists through soft reset of the chip.
  static volatile uint32_t & WATCHDOG_SCRATCH5 __attribute__((unused)) = * ((volatile uint32_t *) (0x40058000 + 32)) ;

//------------------------------------------------------------------------------

//---  Register SCRATCH6: Scratch register. Information persists through soft reset of the chip.
  static volatile uint32_t & WATCHDOG_SCRATCH6 __attribute__((unused)) = * ((volatile uint32_t *) (0x40058000 + 36)) ;

//------------------------------------------------------------------------------

//---  Register SCRATCH7: Scratch register. Information persists through soft reset of the chip.
  static volatile uint32_t & WATCHDOG_SCRATCH7 __attribute__((unused)) = * ((volatile uint32_t *) (0x40058000 + 40)) ;

//------------------------------------------------------------------------------

//---  Register TICK: Controls the tick generator
  static volatile uint32_t & WATCHDOG_TICK __attribute__((unused)) = * ((volatile uint32_t *) (0x40058000 + 44)) ;

  // Field CYCLES: Total number of clk_tick cycles before the next tick.
    inline uint32_t WATCHDOG_TICK_CYCLES (const uint32_t inValue) {return (inValue & 0x1FFU) << 0 ; }

  // Field ENABLE: start / stop tick generation
    const uint32_t WATCHDOG_TICK_ENABLE = 1U << 9 ;

  // Field RUNNING: Is the tick generator running?
    const uint32_t WATCHDOG_TICK_RUNNING = 1U << 10 ;

  // Field COUNT: Count down timer: the remaining number clk_tick cycles before the next tick is generated.
    inline uint32_t WATCHDOG_TICK_COUNT (const uint32_t inValue) {return (inValue & 0x1FFU) << 11 ; }

//------------------------------------------------------------------------------
// Peripheral XIP_CTRL: QSPI flash execute-in-place block
//------------------------------------------------------------------------------

//---  Register CTRL: Cache control
  static volatile uint32_t & XIP_CTRL_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x14000000 + 0)) ;

  // Field EN: When 1, enable the cache. When the cache is disabled, all XIP accesses\n will go straight to the flash, without querying the cache. When enabled,\n cacheable XIP accesses will query the cache, and the flash will\n not be accessed if the tag matches and the valid bit is set.\n\n If the cache is enabled, cache-as-SRAM accesses have no effect on the\n cache data RAM, and will produce a bus error response.
    const uint32_t XIP_CTRL_CTRL_EN = 1U << 0 ;

  // Field ERR_BADWRITE: When 1, writes to any alias other than 0x0 (caching, allocating)\n will produce a bus fault. When 0, these writes are silently ignored.\n In either case, writes to the 0x0 alias will deallocate on tag match,\n as usual.
    const uint32_t XIP_CTRL_CTRL_ERR_BADWRITE = 1U << 1 ;

  // Field POWER_DOWN: When 1, the cache memories are powered down. They retain state,\n but can not be accessed. This reduces static power dissipation.\n Writing 1 to this bit forces CTRL_EN to 0, i.e. the cache cannot\n be enabled when powered down.\n Cache-as-SRAM accesses will produce a bus error response when\n the cache is powered down.
    const uint32_t XIP_CTRL_CTRL_POWER_DOWN = 1U << 3 ;

//------------------------------------------------------------------------------

//---  Register FLUSH: Cache Flush control
  static volatile uint32_t & XIP_CTRL_FLUSH __attribute__((unused)) = * ((volatile uint32_t *) (0x14000000 + 4)) ;

  // Field FLUSH: Write 1 to flush the cache. This clears the tag memory, but\n the data memory retains its contents. (This means cache-as-SRAM\n contents is not affected by flush or reset.)\n Reading will hold the bus (stall the processor) until the flush\n completes. Alternatively STAT can be polled until completion.
    const uint32_t XIP_CTRL_FLUSH_FLUSH = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register STAT: Cache Status
  static volatile uint32_t & XIP_CTRL_STAT __attribute__((unused)) = * ((volatile uint32_t *) (0x14000000 + 8)) ;

  // Field FLUSH_READY: Reads as 0 while a cache flush is in progress, and 1 otherwise.\n The cache is flushed whenever the XIP block is reset, and also\n when requested via the FLUSH register.
    const uint32_t XIP_CTRL_STAT_FLUSH_READY = 1U << 0 ;

  // Field FIFO_EMPTY: When 1, indicates the XIP streaming FIFO is completely empty.
    const uint32_t XIP_CTRL_STAT_FIFO_EMPTY = 1U << 1 ;

  // Field FIFO_FULL: When 1, indicates the XIP streaming FIFO is completely full.\n The streaming FIFO is 2 entries deep, so the full and empty\n flag allow its level to be ascertained.
    const uint32_t XIP_CTRL_STAT_FIFO_FULL = 1U << 2 ;

//------------------------------------------------------------------------------

//---  Register CTR_HIT: Cache Hit counter\n A 32 bit saturating counter that increments upon each cache hit,\n i.e. when an XIP access is serviced directly from cached data.\n Write any value to clear.
  static volatile uint32_t & XIP_CTRL_CTR_HIT __attribute__((unused)) = * ((volatile uint32_t *) (0x14000000 + 12)) ;

//------------------------------------------------------------------------------

//---  Register CTR_ACC: Cache Access counter\n A 32 bit saturating counter that increments upon each XIP access,\n whether the cache is hit or not. This includes noncacheable accesses.\n Write any value to clear.
  static volatile uint32_t & XIP_CTRL_CTR_ACC __attribute__((unused)) = * ((volatile uint32_t *) (0x14000000 + 16)) ;

//------------------------------------------------------------------------------

//---  Register STREAM_ADDR: FIFO stream address
  static volatile uint32_t & XIP_CTRL_STREAM_ADDR __attribute__((unused)) = * ((volatile uint32_t *) (0x14000000 + 20)) ;

  // Field STREAM_ADDR: The address of the next word to be streamed from flash to the streaming FIFO.\n Increments automatically after each flash access.\n Write the initial access address here before starting a streaming read.
    inline uint32_t XIP_CTRL_STREAM_ADDR_STREAM_ADDR (const uint32_t inValue) {return (inValue & 0x3FFFFFFFU) << 2 ; }

//------------------------------------------------------------------------------

//---  Register STREAM_CTR: FIFO stream control
  static volatile uint32_t & XIP_CTRL_STREAM_CTR __attribute__((unused)) = * ((volatile uint32_t *) (0x14000000 + 24)) ;

  // Field STREAM_CTR: Write a nonzero value to start a streaming read. This will then\n progress in the background, using flash idle cycles to transfer\n a linear data block from flash to the streaming FIFO.\n Decrements automatically (1 at a time) as the stream\n progresses, and halts on reaching 0.\n Write 0 to halt an in-progress stream, and discard any in-flight\n read, so that a new stream can immediately be started (after\n draining the FIFO and reinitialising STREAM_ADDR)
    inline uint32_t XIP_CTRL_STREAM_CTR_STREAM_CTR (const uint32_t inValue) {return (inValue & 0x3FFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register STREAM_FIFO: FIFO stream data\n Streamed data is buffered here, for retrieval by the system DMA.\n This FIFO can also be accessed via the XIP_AUX slave, to avoid exposing\n the DMA to bus stalls caused by other XIP traffic.
  static volatile uint32_t const & XIP_CTRL_STREAM_FIFO __attribute__((unused)) = * ((const volatile uint32_t *) (0x14000000 + 28)) ;

//------------------------------------------------------------------------------
// Peripheral XIP_SSI: DW_apb_ssi has the following features:\n         * APB interface – Allows for easy integration into a DesignWare Synthesizable Components for AMBA 2 implementation.\n         * APB3 and APB4 protocol support.\n         * Scalable APB data bus width – Supports APB data bus widths of 8, 16, and 32 bits.\n         * Serial-master or serial-slave operation – Enables serial communication with serial-master or serial-slave peripheral devices.\n         * Programmable Dual/Quad/Octal SPI support in Master Mode.\n         * Dual Data Rate (DDR) and Read Data Strobe (RDS) Support - Enables the DW_apb_ssi master to perform operations with the device in DDR and RDS modes when working in Dual/Quad/Octal mode of operation.\n         * Data Mask Support - Enables the DW_apb_ssi to selectively update the bytes in the device. This feature is applicable only in enhanced SPI modes.\n         * eXecute-In-Place (XIP) support - Enables the DW_apb_ssi master to behave as a memory mapped I/O and fetches the data from the device based on the APB read request. This feature is applicable only in enhanced SPI modes.\n         * DMA Controller Interface – Enables the DW_apb_ssi to interface to a DMA controller over the bus using a handshaking interface for transfer requests.\n         * Independent masking of interrupts – Master collision, transmit FIFO overflow, transmit FIFO empty, receive FIFO full, receive FIFO underflow, and receive FIFO overflow interrupts can all be masked independently.\n         * Multi-master contention detection – Informs the processor of multiple serial-master accesses on the serial bus.\n         * Bypass of meta-stability flip-flops for synchronous clocks – When the APB clock (pclk) and the DW_apb_ssi serial clock (ssi_clk) are synchronous, meta-stable flip-flops are not used when transferring control signals across these clock domains.\n         * Programmable delay on the sample time of the received serial data bit (rxd); enables programmable control of routing delays resulting in higher serial data-bit rates.\n         * Programmable features:\n         - Serial interface operation – Choice of Motorola SPI, Texas Instruments Synchronous Serial Protocol or National Semiconductor Microwire.\n         - Clock bit-rate – Dynamic control of the serial bit rate of the data transfer; used in only serial-master mode of operation.\n         - Data Item size (4 to 32 bits) – Item size of each data transfer under the control of the programmer.\n         * Configured features:\n         - FIFO depth – 16 words deep. The FIFO width is fixed at 32 bits.\n         - 1 slave select output.\n         - Hardware slave-select – Dedicated hardware slave-select line.\n         - Combined interrupt line - one combined interrupt line from the DW_apb_ssi to the interrupt controller.\n         - Interrupt polarity – active high interrupt lines.\n         - Serial clock polarity – low serial-clock polarity directly after reset.\n         - Serial clock phase – capture on first edge of serial-clock directly after reset.
//------------------------------------------------------------------------------

//---  Register CTRLR0: Control register 0
  static volatile uint32_t & XIP_SSI_CTRLR0 __attribute__((unused)) = * ((volatile uint32_t *) (0x18000000 + 0)) ;

  // Field DFS: Data frame size
    inline uint32_t XIP_SSI_CTRLR0_DFS (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field FRF: Frame format
    inline uint32_t XIP_SSI_CTRLR0_FRF (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field SCPH: Serial clock phase
    const uint32_t XIP_SSI_CTRLR0_SCPH = 1U << 6 ;

  // Field SCPOL: Serial clock polarity
    const uint32_t XIP_SSI_CTRLR0_SCPOL = 1U << 7 ;

  // Field TMOD: Transfer mode
    inline uint32_t XIP_SSI_CTRLR0_TMOD (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field SLV_OE: Slave output enable
    const uint32_t XIP_SSI_CTRLR0_SLV_OE = 1U << 10 ;

  // Field SRL: Shift register loop (test mode)
    const uint32_t XIP_SSI_CTRLR0_SRL = 1U << 11 ;

  // Field CFS: Control frame size\n Value of n -> n+1 clocks per frame.
    inline uint32_t XIP_SSI_CTRLR0_CFS (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field DFS_32: Data frame size in 32b transfer mode\n Value of n -> n+1 clocks per frame.
    inline uint32_t XIP_SSI_CTRLR0_DFS_32 (const uint32_t inValue) {return (inValue & 0x1FU) << 16 ; }

  // Field SPI_FRF: SPI frame format
    inline uint32_t XIP_SSI_CTRLR0_SPI_FRF (const uint32_t inValue) {return (inValue & 0x3U) << 21 ; }

  // Field SSTE: Slave select toggle enable
    const uint32_t XIP_SSI_CTRLR0_SSTE = 1U << 24 ;

//------------------------------------------------------------------------------

//---  Register CTRLR1: Master Control register 1
  static volatile uint32_t & XIP_SSI_CTRLR1 __attribute__((unused)) = * ((volatile uint32_t *) (0x18000000 + 4)) ;

  // Field NDF: Number of data frames
    inline uint32_t XIP_SSI_CTRLR1_NDF (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SSIENR: SSI Enable
  static volatile uint32_t & XIP_SSI_SSIENR __attribute__((unused)) = * ((volatile uint32_t *) (0x18000000 + 8)) ;

  // Field SSI_EN: SSI enable
    const uint32_t XIP_SSI_SSIENR_SSI_EN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register MWCR: Microwire Control
  static volatile uint32_t & XIP_SSI_MWCR __attribute__((unused)) = * ((volatile uint32_t *) (0x18000000 + 12)) ;

  // Field MWMOD: Microwire transfer mode
    const uint32_t XIP_SSI_MWCR_MWMOD = 1U << 0 ;

  // Field MDD: Microwire control
    const uint32_t XIP_SSI_MWCR_MDD = 1U << 1 ;

  // Field MHS: Microwire handshaking
    const uint32_t XIP_SSI_MWCR_MHS = 1U << 2 ;

//------------------------------------------------------------------------------

//---  Register SER: Slave enable
  static volatile uint32_t & XIP_SSI_SER __attribute__((unused)) = * ((volatile uint32_t *) (0x18000000 + 16)) ;

  // Field SER: For each bit:\n 0 -> slave not selected\n 1 -> slave selected
    const uint32_t XIP_SSI_SER_SER = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register BAUDR: Baud rate
  static volatile uint32_t & XIP_SSI_BAUDR __attribute__((unused)) = * ((volatile uint32_t *) (0x18000000 + 20)) ;

  // Field SCKDV: SSI clock divider
    inline uint32_t XIP_SSI_BAUDR_SCKDV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register TXFTLR: TX FIFO threshold level
  static volatile uint32_t & XIP_SSI_TXFTLR __attribute__((unused)) = * ((volatile uint32_t *) (0x18000000 + 24)) ;

  // Field TFT: Transmit FIFO threshold
    inline uint32_t XIP_SSI_TXFTLR_TFT (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RXFTLR: RX FIFO threshold level
  static volatile uint32_t & XIP_SSI_RXFTLR __attribute__((unused)) = * ((volatile uint32_t *) (0x18000000 + 28)) ;

  // Field RFT: Receive FIFO threshold
    inline uint32_t XIP_SSI_RXFTLR_RFT (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register TXFLR: TX FIFO level
  static volatile uint32_t & XIP_SSI_TXFLR __attribute__((unused)) = * ((volatile uint32_t *) (0x18000000 + 32)) ;

  // Field TFTFL: Transmit FIFO level
    inline uint32_t XIP_SSI_TXFLR_TFTFL (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RXFLR: RX FIFO level
  static volatile uint32_t & XIP_SSI_RXFLR __attribute__((unused)) = * ((volatile uint32_t *) (0x18000000 + 36)) ;

  // Field RXTFL: Receive FIFO level
    inline uint32_t XIP_SSI_RXFLR_RXTFL (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SR: Status register
  static volatile uint32_t & XIP_SSI_SR __attribute__((unused)) = * ((volatile uint32_t *) (0x18000000 + 40)) ;

  // Field BUSY: SSI busy flag
    const uint32_t XIP_SSI_SR_BUSY = 1U << 0 ;

  // Field TFNF: Transmit FIFO not full
    const uint32_t XIP_SSI_SR_TFNF = 1U << 1 ;

  // Field TFE: Transmit FIFO empty
    const uint32_t XIP_SSI_SR_TFE = 1U << 2 ;

  // Field RFNE: Receive FIFO not empty
    const uint32_t XIP_SSI_SR_RFNE = 1U << 3 ;

  // Field RFF: Receive FIFO full
    const uint32_t XIP_SSI_SR_RFF = 1U << 4 ;

  // Field TXE: Transmission error
    const uint32_t XIP_SSI_SR_TXE = 1U << 5 ;

  // Field DCOL: Data collision error
    const uint32_t XIP_SSI_SR_DCOL = 1U << 6 ;

//------------------------------------------------------------------------------

//---  Register IMR: Interrupt mask
  static volatile uint32_t & XIP_SSI_IMR __attribute__((unused)) = * ((volatile uint32_t *) (0x18000000 + 44)) ;

  // Field TXEIM: Transmit FIFO empty interrupt mask
    const uint32_t XIP_SSI_IMR_TXEIM = 1U << 0 ;

  // Field TXOIM: Transmit FIFO overflow interrupt mask
    const uint32_t XIP_SSI_IMR_TXOIM = 1U << 1 ;

  // Field RXUIM: Receive FIFO underflow interrupt mask
    const uint32_t XIP_SSI_IMR_RXUIM = 1U << 2 ;

  // Field RXOIM: Receive FIFO overflow interrupt mask
    const uint32_t XIP_SSI_IMR_RXOIM = 1U << 3 ;

  // Field RXFIM: Receive FIFO full interrupt mask
    const uint32_t XIP_SSI_IMR_RXFIM = 1U << 4 ;

  // Field MSTIM: Multi-master contention interrupt mask
    const uint32_t XIP_SSI_IMR_MSTIM = 1U << 5 ;

//------------------------------------------------------------------------------

//---  Register ISR: Interrupt status
  static volatile uint32_t & XIP_SSI_ISR __attribute__((unused)) = * ((volatile uint32_t *) (0x18000000 + 48)) ;

  // Field TXEIS: Transmit FIFO empty interrupt status
    const uint32_t XIP_SSI_ISR_TXEIS = 1U << 0 ;

  // Field TXOIS: Transmit FIFO overflow interrupt status
    const uint32_t XIP_SSI_ISR_TXOIS = 1U << 1 ;

  // Field RXUIS: Receive FIFO underflow interrupt status
    const uint32_t XIP_SSI_ISR_RXUIS = 1U << 2 ;

  // Field RXOIS: Receive FIFO overflow interrupt status
    const uint32_t XIP_SSI_ISR_RXOIS = 1U << 3 ;

  // Field RXFIS: Receive FIFO full interrupt status
    const uint32_t XIP_SSI_ISR_RXFIS = 1U << 4 ;

  // Field MSTIS: Multi-master contention interrupt status
    const uint32_t XIP_SSI_ISR_MSTIS = 1U << 5 ;

//------------------------------------------------------------------------------

//---  Register RISR: Raw interrupt status
  static volatile uint32_t & XIP_SSI_RISR __attribute__((unused)) = * ((volatile uint32_t *) (0x18000000 + 52)) ;

  // Field TXEIR: Transmit FIFO empty raw interrupt status
    const uint32_t XIP_SSI_RISR_TXEIR = 1U << 0 ;

  // Field TXOIR: Transmit FIFO overflow raw interrupt status
    const uint32_t XIP_SSI_RISR_TXOIR = 1U << 1 ;

  // Field RXUIR: Receive FIFO underflow raw interrupt status
    const uint32_t XIP_SSI_RISR_RXUIR = 1U << 2 ;

  // Field RXOIR: Receive FIFO overflow raw interrupt status
    const uint32_t XIP_SSI_RISR_RXOIR = 1U << 3 ;

  // Field RXFIR: Receive FIFO full raw interrupt status
    const uint32_t XIP_SSI_RISR_RXFIR = 1U << 4 ;

  // Field MSTIR: Multi-master contention raw interrupt status
    const uint32_t XIP_SSI_RISR_MSTIR = 1U << 5 ;

//------------------------------------------------------------------------------

//---  Register TXOICR: TX FIFO overflow interrupt clear
  static volatile uint32_t & XIP_SSI_TXOICR __attribute__((unused)) = * ((volatile uint32_t *) (0x18000000 + 56)) ;

  // Field TXOICR: Clear-on-read transmit FIFO overflow interrupt
    const uint32_t XIP_SSI_TXOICR_TXOICR = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register RXOICR: RX FIFO overflow interrupt clear
  static volatile uint32_t & XIP_SSI_RXOICR __attribute__((unused)) = * ((volatile uint32_t *) (0x18000000 + 60)) ;

  // Field RXOICR: Clear-on-read receive FIFO overflow interrupt
    const uint32_t XIP_SSI_RXOICR_RXOICR = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register RXUICR: RX FIFO underflow interrupt clear
  static volatile uint32_t & XIP_SSI_RXUICR __attribute__((unused)) = * ((volatile uint32_t *) (0x18000000 + 64)) ;

  // Field RXUICR: Clear-on-read receive FIFO underflow interrupt
    const uint32_t XIP_SSI_RXUICR_RXUICR = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register MSTICR: Multi-master interrupt clear
  static volatile uint32_t & XIP_SSI_MSTICR __attribute__((unused)) = * ((volatile uint32_t *) (0x18000000 + 68)) ;

  // Field MSTICR: Clear-on-read multi-master contention interrupt
    const uint32_t XIP_SSI_MSTICR_MSTICR = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register ICR: Interrupt clear
  static volatile uint32_t & XIP_SSI_ICR __attribute__((unused)) = * ((volatile uint32_t *) (0x18000000 + 72)) ;

  // Field ICR: Clear-on-read all active interrupts
    const uint32_t XIP_SSI_ICR_ICR = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register DMACR: DMA control
  static volatile uint32_t & XIP_SSI_DMACR __attribute__((unused)) = * ((volatile uint32_t *) (0x18000000 + 76)) ;

  // Field RDMAE: Receive DMA enable
    const uint32_t XIP_SSI_DMACR_RDMAE = 1U << 0 ;

  // Field TDMAE: Transmit DMA enable
    const uint32_t XIP_SSI_DMACR_TDMAE = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register DMATDLR: DMA TX data level
  static volatile uint32_t & XIP_SSI_DMATDLR __attribute__((unused)) = * ((volatile uint32_t *) (0x18000000 + 80)) ;

  // Field DMATDL: Transmit data watermark level
    inline uint32_t XIP_SSI_DMATDLR_DMATDL (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DMARDLR: DMA RX data level
  static volatile uint32_t & XIP_SSI_DMARDLR __attribute__((unused)) = * ((volatile uint32_t *) (0x18000000 + 84)) ;

  // Field DMARDL: Receive data watermark level (DMARDLR+1)
    inline uint32_t XIP_SSI_DMARDLR_DMARDL (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IDR: Identification register
  static volatile uint32_t & XIP_SSI_IDR __attribute__((unused)) = * ((volatile uint32_t *) (0x18000000 + 88)) ;

  // Field IDCODE: Peripheral dentification code
    inline uint32_t XIP_SSI_IDR_IDCODE (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SSI_VERSION_ID: Version ID
  static volatile uint32_t & XIP_SSI_SSI_VERSION_ID __attribute__((unused)) = * ((volatile uint32_t *) (0x18000000 + 92)) ;

  // Field SSI_COMP_VERSION: SNPS component version (format X.YY)
    inline uint32_t XIP_SSI_SSI_VERSION_ID_SSI_COMP_VERSION (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DR0: Data Register 0 (of 36)
  static volatile uint32_t & XIP_SSI_DR0 __attribute__((unused)) = * ((volatile uint32_t *) (0x18000000 + 96)) ;

  // Field DR: First data register of 36
    inline uint32_t XIP_SSI_DR0_DR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RX_SAMPLE_DLY: RX sample delay
  static volatile uint32_t & XIP_SSI_RX_SAMPLE_DLY __attribute__((unused)) = * ((volatile uint32_t *) (0x18000000 + 240)) ;

  // Field RSD: RXD sample delay (in SCLK cycles)
    inline uint32_t XIP_SSI_RX_SAMPLE_DLY_RSD (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SPI_CTRLR0: SPI control
  static volatile uint32_t & XIP_SSI_SPI_CTRLR0 __attribute__((unused)) = * ((volatile uint32_t *) (0x18000000 + 244)) ;

  // Field TRANS_TYPE: Address and instruction transfer format
    inline uint32_t XIP_SSI_SPI_CTRLR0_TRANS_TYPE (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field ADDR_L: Address length (0b-60b in 4b increments)
    inline uint32_t XIP_SSI_SPI_CTRLR0_ADDR_L (const uint32_t inValue) {return (inValue & 0xFU) << 2 ; }

  // Field INST_L: Instruction length (0/4/8/16b)
    inline uint32_t XIP_SSI_SPI_CTRLR0_INST_L (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field WAIT_CYCLES: Wait cycles between control frame transmit and data reception (in SCLK cycles)
    inline uint32_t XIP_SSI_SPI_CTRLR0_WAIT_CYCLES (const uint32_t inValue) {return (inValue & 0x1FU) << 11 ; }

  // Field SPI_DDR_EN: SPI DDR transfer enable
    const uint32_t XIP_SSI_SPI_CTRLR0_SPI_DDR_EN = 1U << 16 ;

  // Field INST_DDR_EN: Instruction DDR transfer enable
    const uint32_t XIP_SSI_SPI_CTRLR0_INST_DDR_EN = 1U << 17 ;

  // Field SPI_RXDS_EN: Read data strobe enable
    const uint32_t XIP_SSI_SPI_CTRLR0_SPI_RXDS_EN = 1U << 18 ;

  // Field XIP_CMD: SPI Command to send in XIP mode (INST_L = 8-bit) or to append to Address (INST_L = 0-bit)
    inline uint32_t XIP_SSI_SPI_CTRLR0_XIP_CMD (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register TXD_DRIVE_EDGE: TX drive edge
  static volatile uint32_t & XIP_SSI_TXD_DRIVE_EDGE __attribute__((unused)) = * ((volatile uint32_t *) (0x18000000 + 248)) ;

  // Field TDE: TXD drive edge
    inline uint32_t XIP_SSI_TXD_DRIVE_EDGE_TDE (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral XOSC: Controls the crystal oscillator
//------------------------------------------------------------------------------

//---  Register CTRL: Crystal Oscillator Control
  static volatile uint32_t & XOSC_CTRL __attribute__((unused)) = * ((volatile uint32_t *) (0x40024000 + 0)) ;

  // Field FREQ_RANGE: Frequency range. This resets to 0xAA0 and cannot be changed.
    inline uint32_t XOSC_CTRL_FREQ_RANGE (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

  // Field ENABLE: On power-up this field is initialised to DISABLE and the chip runs from the ROSC.\n If the chip has subsequently been programmed to run from the XOSC then setting this field to DISABLE may lock-up the chip. If this is a concern then run the clk_ref from the ROSC and enable the clk_sys RESUS feature.\n The 12-bit code is intended to give some protection against accidental writes. An invalid setting will enable the oscillator.
    inline uint32_t XOSC_CTRL_ENABLE (const uint32_t inValue) {return (inValue & 0xFFFU) << 12 ; }

//------------------------------------------------------------------------------

//---  Register STATUS: Crystal Oscillator Status
  static volatile uint32_t & XOSC_STATUS __attribute__((unused)) = * ((volatile uint32_t *) (0x40024000 + 4)) ;

  // Field FREQ_RANGE: The current frequency range setting, always reads 0
    inline uint32_t XOSC_STATUS_FREQ_RANGE (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field ENABLED: Oscillator is enabled but not necessarily running and stable, resets to 0
    const uint32_t XOSC_STATUS_ENABLED = 1U << 12 ;

  // Field BADWRITE: An invalid value has been written to CTRL_ENABLE or CTRL_FREQ_RANGE or DORMANT
    const uint32_t XOSC_STATUS_BADWRITE = 1U << 24 ;

  // Field STABLE: Oscillator is running and stable
    const uint32_t XOSC_STATUS_STABLE = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register DORMANT: Crystal Oscillator pause control\n This is used to save power by pausing the XOSC\n On power-up this field is initialised to WAKE\n An invalid write will also select WAKE\n WARNING: stop the PLLs before selecting dormant mode\n WARNING: setup the irq before selecting dormant mode
  static volatile uint32_t & XOSC_DORMANT __attribute__((unused)) = * ((volatile uint32_t *) (0x40024000 + 8)) ;

//------------------------------------------------------------------------------

//---  Register STARTUP: Controls the startup delay
  static volatile uint32_t & XOSC_STARTUP __attribute__((unused)) = * ((volatile uint32_t *) (0x40024000 + 12)) ;

  // Field DELAY: in multiples of 256*xtal_period
    inline uint32_t XOSC_STARTUP_DELAY (const uint32_t inValue) {return (inValue & 0x3FFFU) << 0 ; }

  // Field X4: Multiplies the startup_delay by 4. This is of little value to the user given that the delay can be programmed directly
    const uint32_t XOSC_STARTUP_X4 = 1U << 20 ;

//------------------------------------------------------------------------------

//---  Register COUNT: A down counter running at the xosc frequency which counts to zero and stops.\n To start the counter write a non-zero value.\n Can be used for short software pauses when setting up time sensitive hardware.
  static volatile uint32_t & XOSC_COUNT __attribute__((unused)) = * ((volatile uint32_t *) (0x40024000 + 28)) ;

  // Field COUNT: 
    inline uint32_t XOSC_COUNT_COUNT (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------
// INTERRUPTS
//------------------------------------------------------------------------------

enum class ISRSlot : uint8_t {
  TIMER_IRQ_0 = 0,
  TIMER_IRQ_1 = 1,
  TIMER_IRQ_2 = 2,
  TIMER_IRQ_3 = 3,
  PWM_IRQ_WRAP = 4,
  USBCTRL_IRQ = 5,
  XIP_IRQ = 6,
  PIO0_IRQ_0 = 7,
  PIO0_IRQ_1 = 8,
  PIO1_IRQ_0 = 9,
  PIO1_IRQ_1 = 10,
  DMA_IRQ_0 = 11,
  DMA_IRQ_1 = 12,
  IO_IRQ_BANK0 = 13,
  IO_IRQ_QSPI = 14,
  SIO_IRQ_PROC0 = 15,
  SIO_IRQ_PROC1 = 16,
  CLOCKS_IRQ = 17,
  SPI0_IRQ = 18,
  SPI1_IRQ = 19,
  UART0_IRQ = 20,
  UART1_IRQ = 21,
  ADC_IRQ_FIFO = 22,
  I2C0_IRQ = 23,
  I2C1_IRQ = 24,
  RTC_IRQ = 25,
} ;

//------------------------------------------------------------------------------

inline void NVIC_ENABLE_IRQ (const ISRSlot inInterrupt) {
  const uint32_t it = static_cast <uint32_t> (inInterrupt) ;
  *((volatile uint32_t *) (0xE000E100 + 4 * (it >> 5))) = 1U << (it & 31) ;
}

//------------------------------------------------------------------------------

inline void NVIC_DISABLE_IRQ (const ISRSlot inInterrupt) {
  const uint32_t it = static_cast <uint32_t> (inInterrupt) ;
  *((volatile uint32_t *) (0xE000E180 + 4 * (it >> 5))) = 1U << (it & 31) ;
}

//------------------------------------------------------------------------------
// BITBAND
//------------------------------------------------------------------------------

inline void bitband32 (const volatile uint32_t & inRegister, const uint8_t inBit, const bool inValue) {
  const uint32_t address = ((uint32_t) &inRegister - 0x40000000) * 32 + ((uint32_t) inBit) * 4 + 0x42000000 ;
  volatile uint32_t * ptr = (volatile uint32_t *) address ;
  *ptr = (uint32_t) inValue ;
}

//------------------------------------------------------------------------------
