#! /usr/bin/env python3
# -*- coding: UTF-8 -*-
#---------------------------------------------------------------------------------------------------

def asSeparator () :
  return "//" + ("-" * 78) + "\n"

#---------------------------------------------------------------------------------------------------

def generate_svc_handler () :
  sCode = asSeparator ()
  sCode += "//   SVC HANDLE (DOUBLE STACK MODE)\n"
  sCode += asSeparator ()
  sCode += "//\n"
  sCode += "//          PSP+32 -> |                            |\n"
  sCode += "//                    |----------------------------| -\n"
  sCode += "//          PSP+28 -> | xPSR                       |  |\n"
  sCode += "//                    |----------------------------|  |\n"
  sCode += "//          PSP+24 -> | PC (after SVC instruction) |  |\n"
  sCode += "//                    |----------------------------|  |\n"
  sCode += "//          PSP+20 -> | LR                         |  |\n"
  sCode += "//                    |----------------------------|  |\n"
  sCode += "//          PSP+16 -> | R12                        |  |  Saved by interrupt response\n"
  sCode += "//                    |----------------------------|  |\n"
  sCode += "//          PSP+12 -> | R3                         |  |\n"
  sCode += "//                    |----------------------------|  |\n"
  sCode += "//          PSP+8  -> | R2                         |  |\n"
  sCode += "//                    |----------------------------|  |\n"
  sCode += "//          PSP+4  -> | R1                         |  |\n"
  sCode += "//                    |----------------------------|  |\n"
  sCode += "//     /--- PSP ----> | R0                         |  |\n"
  sCode += "//     |              |----------------------------| -\n"
  sCode += "//     |              |                            |\n"
  sCode += "//     |\n"
  sCode += "//     |                                          *---------------------*\n"
  sCode += "//     |                                          | LR return code      | +36 [ 9]\n"
  sCode += "//     |                                          *---------------------*\n"
  sCode += "//     \----------------------------------------- | R13 (PSP)           | +32 [ 8]\n"
  sCode += "//                                                *---------------------*\n"
  sCode += "//                                                | R11                 | +28 [ 7]\n"
  sCode += "//                                                *---------------------*\n"
  sCode += "//                                                | R10                 | +24 [ 6]\n"
  sCode += "//                                                *---------------------*\n"
  sCode += "//                                                | R9                  | +20 [ 5]\n"
  sCode += "//                                                *---------------------*\n"
  sCode += "//                                                | R8                  | +16 [ 4]\n"
  sCode += "//                                                *---------------------*\n"
  sCode += "//                                                | R7                  | +12 [ 3]\n"
  sCode += "//                                                *---------------------*\n"
  sCode += "//                                                | R6                  | + 8 [ 2]\n"
  sCode += "//                                                *---------------------*\n"
  sCode += "//                                                | R5                  | + 4 [ 1]\n"
  sCode += "//  *------------------------------------*        *---------------------*\n"
  sCode += "//  | var.running.task.control.block.ptr +------> | R4                  | + 0 [ 0]\n"
  sCode += "//  *------------------------------------*        *---------------------*\n"
  sCode += "//\n"
  sCode += asSeparator () + "\n"
  sCode += "  .section  .bss.var.background.task.context, \"aw\", %nobits\n"
  sCode += "  .align    3\n\n"
  sCode += "var.background.tasks.context:\n"
  sCode += "  .space  16\n\n"
  sCode += asSeparator () + "\n"
  sCode += "  .section  .text.interrupt.SVC, \"ax\", %progbits\n\n"
  sCode += "  .global interrupt.SVC\n"
  sCode += "  .type interrupt.SVC, %function\n\n"
  sCode += "interrupt.SVC:\n"
  sCode += "//----------------------------------------- R0 <- calling task context\n"
  sCode += "  ldr   r1, = 0xD0000000 + 0x000 // Address of SIO CPUID control register\n"
  sCode += "  ldr   r1, [r1] // R1 <- 0 for CPU0, 1 for CPU 1\n"
  sCode += "  lsls  r1, r1, # 2 // R1 <- 0 for CPU0, 4 for CPU 1\n"
  sCode += "  ldr   r0, =var.running.tasks.control.block.ptr\n"
  sCode += "  ldr   r0, [r0, r1]\n"
  sCode += "//----------------------------------------- Save calling task context\n"
  sCode += "  cmp   r0, # 0\n"
  sCode += "  beq   save.background.task.context\n"
  sCode += "//--- Save registers r4 to r11, PSP (stored in R12), LR\n"
  sCode += "  stm   r0!, {r4, r5, r6, r7}\n"
  sCode += "  mov   r1, r8\n"
  sCode += "  mov   r2, r9\n"
  sCode += "  mov   r3, r10\n"
  sCode += "  stm   r0!, {r1, r2, r3}\n"
  sCode += "  mov   r4, r11\n"
  sCode += "  mrs   r5, psp\n"
  sCode += "  mov   r6, lr\n"
  sCode += "  stm   r0!, {r4, r5, r6}\n"
  sCode += "  b     context.has.been.saved\n"
  sCode += "save.background.task.context:\n"
  sCode += "  ldr   r1, = 0xD0000000 + 0x000 // Address of SIO CPUID control register\n"
  sCode += "  ldr   r1, [r1] // R1 <- 0 for CPU0, 1 for CPU 1\n"
  sCode += "  lsls  r1, r1, # 3 // R1 <- 0 for CPU0, 8 for CPU 1\n"
  sCode += "  ldr   r0, =var.background.tasks.context\n"
  sCode += "  add   r0, r1\n"
  sCode += "  mov   r4, lr\n"
  sCode += "  mrs   r5, psp\n"
  sCode += "  stm   r0!, {r4, r5}\n"
  sCode += "context.has.been.saved:\n"
  sCode += "//----------------------------------------- R0 <- Address of instruction following SVC\n"
  sCode += "  ldr   r0, [r5, #24]   // 24 : 6 stacked registers before saved PC\n"
  sCode += "//----------------------------------------- R0 <- bits 0-7 of SVC instruction\n"
  sCode += "  subs  r0, #2         // R0 <- Address of SVC instruction\n"
  sCode += "  ldrb  r0, [r0]       // R0 is service call index\n"
  sCode += "//----------------------------------------- R1 <- address of dispatcher table\n"
  sCode += "  ldr   r1, =svc.dispatcher.table\n"
  sCode += "//----------------------------------------- R6 <- address of routine to call\n"
  sCode += "  lsls  r0, r0, #2 // R0 = (R0 << 2)\n"
  sCode += "  ldr   r6, [r1, r0]\n"
  sCode += "//----------------------------------------- Restore R0, R1, R2 and R3 from saved stack\n"
  sCode += "  ldmia r5!, {r0, r1, r2, r3}\n"
  sCode += "//----------------------------------------- Get spinlock 0\n"
  sCode += "//--- R4 <- Address of SPINLOCK 0 (rp2040 datasheet, 2.3.1.7, page 42)\n"
  sCode += "  ldr   r4, = 0xD0000000 + 0x100\n"
  sCode += "//--- Read: attempt to claim the lock. Read value is nonzero if the lock was\n"
  sCode += "//    successfully claimed, or zero if the lock had already been claimed\n"
  sCode += "//    by a previous read (rp2040 datasheet, section 2.3.1.3 page 30).\n"
  sCode += "svc.spinlock.busy.wait:\n"
  sCode += "  ldr   r5, [r4]\n"
  sCode += "  cmp   r5, #0\n"
  sCode += "  beq   svc.spinlock.busy.wait\n"
  sCode += "//----------------------------------------- Call service routine\n"
  sCode += "  blx   r6\n"
  sCode += "//--- Continues in sequence to handle.context.switch\n\n"
  sCode += asSeparator ()
  sCode += "//  HANDLE CONTEXT SWITCH (DOUBLE STACK MODE)\n"
  sCode += "//  R4 contains the spinlock #0 address\n"
  sCode += asSeparator () + "\n"
  sCode += "handle.context.switch:\n"
  sCode += "//----------------------------------------- Select task to run\n"
  sCode += "  bl    kernel.select.task.to.run\n"
  sCode += "//----------------------------------------- Release spinlock\n"
  sCode += "//--- Write (any value): release the lock (rp2040 datasheet, section 2.3.1.3 page 30).\n"
  sCode += "//    The next attempt to claim the lock will be successful.\n"
  sCode += "  str   r5, [r4]\n"
  sCode += "//----------------------------------------- R0 <- new task context\n"
  sCode += "  ldr   r1, = 0xD0000000 + 0x000 // Address of SIO CPUID control register\n"
  sCode += "  ldr   r1, [r1] // R1 <- 0 for CPU0, 1 for CPU 1\n"
  sCode += "  lsls  r1, r1, # 2 // R1 <- 0 for CPU0, 4 for CPU 1\n"
  sCode += "  ldr   r0, =var.running.tasks.control.block.ptr\n"
  sCode += "  ldr   r0, [r0, r1]\n"
  sCode += "//----------------------------------------- Restore context of activated task\n"
  sCode += "  cmp   r0, #0\n"
  sCode += "  beq   restore.background.task.context\n"
  sCode += "  ldm   r0!, {r4, r5, r6, r7}\n"
  sCode += "  ldm   r0!, {r1, r2, r3}\n"
  sCode += "  mov   r8, r1\n"
  sCode += "  mov   r9, r2\n"
  sCode += "  mov   r10, r3\n"
  sCode += "  ldm   r0!, {r1, r2, r3}\n"
  sCode += "  mov   r11, r1\n"
  sCode += "  msr   psp, r2\n"
  sCode += "  mov   lr, r3\n"
  sCode += "  bx    lr\n"
  sCode += "//----------------------------------------- Restore background task context\n"
  sCode += "restore.background.task.context:\n"
  sCode += "  ldr   r1, = 0xD0000000 + 0x000 // Address of SIO CPUID control register\n"
  sCode += "  ldr   r1, [r1] // R1 <- 0 for CPU0, 1 for CPU 1\n"
  sCode += "  lsls  r1, r1, # 3 // R1 <- 0 for CPU0, 8 for CPU 1\n"
  sCode += "  ldr   r0, =var.background.tasks.context\n"
  sCode += "  add   r0, r1\n"
  sCode += "  ldm   r0!, {r1, r2}\n"
  sCode += "  mov   lr, r1\n"
  sCode += "  msr   psp, r2\n"
  sCode += "  bx    lr\n\n"
  return sCode

#---------------------------------------------------------------------------------------------------
#    ENTRY POINT
#---------------------------------------------------------------------------------------------------

def buildServiceCode (serviceList, boolServiceSet, interruptServiceList, interruptDictionary) :
  sFile = generate_svc_handler ()
  del interruptDictionary ["SVC"]
  sFile += asSeparator ()
  sFile += "//   SERVICES\n"
  idx = 2
  for service in serviceList :
    sFile += asSeparator () + "\n"
    sFile += "  .section .text." + service + ", \"ax\", %progbits\n"
    sFile += "  .global " + service +"\n"
    sFile += "  .align 1\n"
    sFile += "  .type " + service +", %function\n\n"
    sFile += service +":\n"
    sFile += "  .fnstart\n"
    sFile += "  svc #" + str (idx) + "\n"
    if service in boolServiceSet :
      sFile += "  ldr r3, = get.user.result\n"
      sFile += "  bx  r3\n\n"
    else:
      sFile += "  bx  lr\n\n"
    sFile += ".Lfunc_end_" + service +":\n"
    sFile += "  .size " + service +", .Lfunc_end_" + service +" - " + service +"\n"
    sFile += "  .cantunwind\n"
    sFile += "  .fnend\n\n"
    idx += 1
  sFile += asSeparator ()
  sFile += "//    SERVICE DISPATCHER TABLE\n"
  sFile += asSeparator () + "\n"
  sFile += "  .align   2\n"
  sFile += "  .global  svc.dispatcher.table\n\n"
  sFile += "svc.dispatcher.table:\n"
  sFile += "  .word cpu.0.phase3.init // 0\n"
  sFile += "  .word cpu.1.phase3.init // 1\n"
  idx = 2
  for service in serviceList :
    sFile += "  .word service." + service + " // " + str (idx) + "\n"
    idx += 1
  sFile += "\n"
  #------------------------------ Interrupts as service
  for interruptServiceName in interruptServiceList :
    sFile += asSeparator ()
    sFile += "//   INTERRUPT - SERVICE: " + interruptServiceName + "\n"
    sFile += asSeparator () + "\n"
    sFile += "  .section .text.interrupt." + interruptServiceName + ", \"ax\", %progbits\n\n"
    sFile += "  .align  1\n"
    sFile += "  .global interrupt." + interruptServiceName + "\n"
    sFile += "  .type interrupt." + interruptServiceName + ", %function\n\n"
    sFile += "interrupt." + interruptServiceName + ":\n"
    sFile += "//----------------------------------------- Activity led On\n"
    sFile += "  MACRO_ACTIVITY_LED_0_OR_1_ON\n"
    sFile += "//----------------------------------------- R0 <- calling task context\n"
    sFile += "  ldr   r1, = 0xD0000000 + 0x000 // Address of SIO CPUID control register\n"
    sFile += "  ldr   r1, [r1] // R1 <- 0 for CPU0, 1 for CPU 1\n"
    sFile += "  lsls  r1, r1, # 2 // R1 <- 0 for CPU0, 4 for CPU 1\n"
    sFile += "  ldr   r0, =var.running.tasks.control.block.ptr\n"
    sFile += "  ldr   r0, [r0, r1]\n"
    sFile += "//----------------------------------------- Save calling task context\n"
    sFile += "  cmp   r0, # 0\n"
    sFile += "  beq   save.background.task.context." + interruptServiceName + "\n"
    sFile += "//--- Save registers r4 to r11, PSP (stored in R12), LR\n"
    sFile += "  stm   r0!, {r4, r5, r6, r7}\n"
    sFile += "  mov   r1, r8\n"
    sFile += "  mov   r2, r9\n"
    sFile += "  mov   r3, r10\n"
    sFile += "  stm   r0!, {r1, r2, r3}\n"
    sFile += "  mov   r1, r11\n"
    sFile += "  mrs   r2, psp\n"
    sFile += "  mov   r3, lr\n"
    sFile += "  stm   r0!, {r1, r2, r3}\n"
    sFile += "  b     context.has.been.saved." + interruptServiceName + "\n"
    sFile += "save.background.task.context." + interruptServiceName + ":\n"
    sFile += "  ldr   r1, = 0xD0000000 + 0x000 // Address of SIO CPUID control register\n"
    sFile += "  ldr   r1, [r1] // R1 <- 0 for CPU0, 1 for CPU 1\n"
    sFile += "  lsls  r1, r1, # 3 // R1 <- 0 for CPU0, 8 for CPU 1\n"
    sFile += "  ldr   r0, =var.background.tasks.context\n"
    sFile += "  add   r0, r1\n"
    sFile += "  mov   r1, lr\n"
    sFile += "  mrs   r2, psp\n"
    sFile += "  stm   r0!, {r1, r2}\n"
    sFile += "context.has.been.saved." + interruptServiceName + ":\n"
    sFile += "//----------------------------------------- Get spinlock 0\n"
    sFile += "//--- R4 <- Address of SPINLOCK 0 (rp2040 datasheet, 2.3.1.7, page 42)\n"
    sFile += "  ldr   r4, = 0xD0000000 + 0x100\n"
    sFile += "//--- Read: attempt to claim the lock. Read value is nonzero if the lock was\n"
    sFile += "//    successfully claimed, or zero if the lock had already been claimed\n"
    sFile += "//    by a previous read (rp2040 datasheet, section 2.3.1.3 page 30).\n"
    sFile += interruptServiceName + ".spinlock.busy.wait:\n"
    sFile += "  ldr   r5, [r4]\n"
    sFile += "  cmp   r5, #0\n"
    sFile += "  beq   " + interruptServiceName +".spinlock.busy.wait\n"
    sFile += "//----------------------------------------- Call Interrupt handler\n"
    sFile += "  bl    interrupt.service." + interruptServiceName + "\n"
    sFile += "//----------------------------------------- Perform the context switch, if needed\n"
    sFile += "  b     handle.context.switch\n\n"
  cppFile = ""
  return (cppFile, sFile, interruptDictionary)

#---------------------------------------------------------------------------------------------------
